<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hubert个人博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-05T10:56:15.948Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Hubert</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>diff算法实现</title>
    <link href="http://example.com/2018/06/20/diff/"/>
    <id>http://example.com/2018/06/20/diff/</id>
    <published>2018-06-20T01:00:00.000Z</published>
    <updated>2022-10-05T10:56:15.948Z</updated>
    
    <content type="html"><![CDATA[<p>diff算法实现</p><ol><li>为什么要用Diff算法</li></ol><p>由于在浏览器中操作DOM是很昂贵的，频繁的操作DOM，会产生一定的性能问题，这就是虚拟DOM的产生原因。虚拟DOM本质上是JavaScript对象，是对真实DOM的抽象状态变更时，记录新树与旧树的差异，最后把差异更新到真正的DOM中。</p><p>即使使用了Virtual DOM来进行真实DOM的渲染，在页面更新的时候，也不能全量地将整颗Virtual DOM进行渲染，而是去渲染改变的部分，这时候就需要一个计算Virtual DOM树改变部分的算法了，这个算法就是Diff算法。</p><p>diff算法的作用：用来修改DOM的一小段，不会引起dom树的重绘</p><ol start="2"><li>传统的Diff算法</li></ol><p>传统的Diff算法通过循环递归对节点进行比较，然后判断每个节点的状态以及要做的操作（add，remove，change），最后 根据Virtual DOM进行DOM的渲染。</p><p>传统Diff算法的复杂度为O(n^3)，这个复杂度相对来说还是较高的。后来React开发者提供了一种复杂度仅为O(n) 的Diff算法。</p><ol start="3"><li>更高效的Diff算法</li></ol><p>React的开发者结合Web界面的特点做出了两个大胆的假设，使得Diff算法复杂度直接从O(n^3)降低到O(n)，假设如下：</p><p>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</p><p>基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)</p><p><strong>同层比较</strong><br>新的Diff算法是逐层进行比较，只比较同一层次的节点，不会跨层次比较，大大降低了复杂度</p><p><strong>不同类型节点的比较</strong><br>如果发现新旧两个节点类型不同时，Diff算法会直接删除旧的节点及其子节点并插入新的节点，这是由于前面提出的不同组件产生的DOM结构一般是不同的，所以可以不用浪费时间去比较。注意的是，删除节点意味着彻底销毁该节点，并不会将该节点去与后面的节点相比较。</p><p><strong>相同类型节点的比较</strong><br>若是两个节点类型相同时，Diff算法会重新设置该节点的属性，从而实现节点的更新。</p><p><strong>列表节点的比较</strong><br>列表节点的操作一般包括添加、删除和排序，列表节点需要我们给它一个key才能进行高效的比较。</p><p>4.Vue Diff算法的实现</p><p>了解了Diff算法的大体思路后，我们回过头来看下Vue中的Diff算法是如何实现的。</p><p>Vue的Diff算法与上面的思路大体相似，只比较同级的节点，若找不到与新节点类型相同的节点，则插入一个新节点，若有相同类型的节点则进行节点属性的更新，最后删除新节点列表中不包含的旧节点。具体的实现在vue源码的src/core/vdom/patch.js中的updateChildren方法中，由于代码较长，下面简单说一下整个的比较流程。</p><p>如上图，有一组新旧节点数组before：[A, B, C, D]、after：[E, C, F, G]，我们设置了四个哨兵节点，oldStartIdx、newStartIdx、oldEndIdx、newEndIdx分别指向新旧节点数组的起始下标和开始下标，值为0,0,3,3；oldStartVnode，newStartVnode，oldEndVnode，newEndVnode则分别指向了before和after节点列表中对应哨兵节点下标的值，值为before[oldStartVnode],after[newStartIdx],before[oldEndIdx],after[newEndIdx]。</p><p><strong>Diff</strong><br>当哨兵满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx的条件的时候，我们会循环进行一系列节点之间的比较。</p><p><strong>优先判断</strong><br>我们首先对上面声明的各个节点进行一些优先级较高的判断。</p><p>判断1：oldStartVnode是否为空，若为true则oldStartIdx向后移动，继续下一个节点的判断。判断代码如下：</p><p>判断2：oldEndVnode是否为空，若为true则oldEndIdx向前移动。判断代码如下：</p><p>判断3：使用 sameVnode判断before和after未判断的头节点是否为相同节点，若为true，则按照上面思路说的，对相同类型节点进行节点的属性的更新并修改哨兵位置。</p><p>判断4：使用上一步相同的方法对oldEndVnode和newEndVnode进行判断。并执行相同的更新操作。</p><p>判断5：使用sameVNode判断旧列表的头节点和新列表的尾节点进行判断，<br>sameVnode(oldStartVnode, newEndVnode)，若为true，更新相同节点，若该节点可以移动在真实DOM中将oldStartVnode，放到真实节点列表的最后。</p><p>判断6：使用sameVnode比较旧列表的尾节点和新列表的头节点，若为true，和上面一样，更新相同节点，将oldEndVnode放到真实节点列表的最开始。</p><p>通过这一系列的优先判断条件，一方面对于一些不需要做移动的DOM可以得到快速处理，另一方面使待处理节点变少，缩小了后续操作的处理范围，可以更快地完成同级节点的对比。</p><p>若节点不满足上面的所有判断，则会进入到最后一个条件分支，判断7：</p><p><strong>循环结束</strong><br>最后当oldStartIdx &gt; oldEndIdx || newStartIdx &gt; newEndIdx，也就是新或旧节点数组有一个被查找完之后则退出判断循环。当循环结束时，旧节点数组中剩下的节点即为要删除的节点，新节点数组中剩下的即为要新增的节点。只需要进行简单的新增和删除操作即可，代码如下：</p><p>经历过了这么多的判断之后，就完成了同级节点之间的Diff比较。</p><p><strong>就地复用</strong><br>在Diff中会使用到一种就地复用的策略。就地复用是指Vue会尽可能复用之前的DOM，尽可能不发生DOM的移动。</p><p>Vue判断新旧节点是否为相同节点（也就是上面的sameVnode方法），这个相同节点的意思并不是两个完全相同的节点，实际上它仅判断是否为同类节点（同类节点为类型相同且节点数据一致，如前后两个span，span标签上的属性没有改变，但是里面的内容变了，这样就算作同类节点），如果是同类节点，那么Vue会直接复用旧DOM节点，只要更新节点中的内容即可。这样可以大大减少列表中节点的移动操作。</p><p><strong>总结</strong><br>Vue中的Diff算法采用了React相似的思路，都是同层节点进行比较，在比较的过程中，使用了一些优先判断和就地复用策略，提高了Diff算法的效率。</p><p><strong>那么在面试工程中，可以怎么组织语言呢？</strong></p><p>答：diff算法的作用：用来修改DOM的一小段，不会引起dom树的重绘<br>diff算法的实现原理：diff算法将虚拟DOM的某个节点数据改变后生成新的的node节点与旧节点进行比较，并替换为新的节点，具体过程就是调用Patch方法，比较新旧节点，一边比较一边给真实DOM打补丁进行替换<br>简单来说，diff算法有以下过程<br>同级比较，再比较子节点<br>如果节点类型不同，直接干掉前面的节点，再创建并插入新节点，不会再比较这个节点以后的子节点。<br>（先判断一方有子节点一方 没有子节点的情况(如果新的children没有子节点，将旧的节点移除)）<br>比较都有子节点的情况(核心diff)<br>递归比较子节点<br>正常diff两个树的时间复杂度是O(n^3)， 但实际情况下我们很少会进行跨层级的移动DOM，所以vue将diff进行了优化，从O(n^3)–&gt;O(n)，只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较。<br>Vue2的核心diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助Key值找到可复用的节点，再进行相关操作。<br>新旧children中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的，需要在新旧children的节点中保存映射关系，以便能够在旧children的节点中找到可复用的节点。key也就是children中节点的唯一标识。<br>相比React的diff算法，同样情况下可以减少移动节点的次数，减少不必要的性能损耗，更加的优雅。<br>Vue3.x借鉴了ivi算法和inferno算法<br>在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升(实际的实现可以结合Vue3.x的源码看)<br>该算法中还运用了动态规划的思想求解最长递归子序列</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;diff算法实现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么要用Diff算法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于在浏览器中操作DOM是很昂贵的，频繁的操作DOM，会产生一定的性能问题，这就是虚拟DOM的产生原因。虚拟DOM本质上是JavaScript对象，是对真实DOM的抽象状态变更时</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝的区别？如何实现一个深拷贝？</title>
    <link href="http://example.com/2017/10/18/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/"/>
    <id>http://example.com/2017/10/18/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/</id>
    <published>2017-10-18T02:30:00.000Z</published>
    <updated>2022-10-05T11:32:47.302Z</updated>
    
    <content type="html"><![CDATA[<p>一、数据类型存储<br>前面文章我们讲到，JavaScript中存在两大数据类型：</p><p>基本类型<br>引用类型<br>基本类型数据保存在在栈内存中</p><p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p><p>#二、浅拷贝<br>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p><p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p><p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p><p>下面简单实现一个浅拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;big&quot;&gt;</span><br><span class="line">    function shallowClone(obj) &#123;</span><br><span class="line">    const newObj = &#123;&#125;;</span><br><span class="line">    for(let prop in obj) &#123;</span><br><span class="line">        if(obj.hasOwnProperty(prop))&#123;</span><br><span class="line">            newObj[prop] = obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在JavaScript中，存在浅拷贝的现象有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign</span><br><span class="line">Array.prototype.slice(), Array.prototype.concat()</span><br></pre></td></tr></table></figure><p>使用拓展运算符实现的复制</p><p>#Object.assign</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    age: 18,</span><br><span class="line">    nature: [&#x27;smart&#x27;, &#x27;good&#x27;],</span><br><span class="line">    names: &#123;</span><br><span class="line">        name1: &#x27;fx&#x27;,</span><br><span class="line">        name2: &#x27;xka&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    love: function () &#123;</span><br><span class="line">        console.log(&#x27;fx is a great girl&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var newObj = Object.assign(&#123;&#125;, fxObj);</span><br></pre></td></tr></table></figure><p>#slice()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">const fxArrs = fxArr.slice(0)</span><br><span class="line">fxArrs[1] = &quot;love&quot;;</span><br><span class="line">console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span><br></pre></td></tr></table></figure><p>#concat()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">const fxArrs = fxArr.concat()</span><br><span class="line">fxArrs[1] = &quot;love&quot;;</span><br><span class="line">console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span><br></pre></td></tr></table></figure><p>#拓展运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">const fxArrs = [...fxArr]</span><br><span class="line">fxArrs[1] = &quot;love&quot;;</span><br><span class="line">console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span><br></pre></td></tr></table></figure><p>#三、深拷贝<br>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p><p>常见的深拷贝方式有：</p><blockquote><p>_.cloneDeep()<br>jQuery.extend()<br>JSON.stringify()</p></blockquote><p>手写循环递归</p><p>#_.cloneDeep()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const _ = require(&#x27;lodash&#x27;);</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">const obj2 = _.cloneDeep(obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f);// false</span><br></pre></td></tr></table></figure><p>#jQuery.extend()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const $ = require(&#x27;jquery&#x27;);</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">const obj2 = $.extend(true, &#123;&#125;, obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f); // false</span><br></pre></td></tr></table></figure><p>#JSON.stringify()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj2=JSON.parse(JSON.stringify(obj1));</span><br></pre></td></tr></table></figure><p>但是这种方式存在弊端，会忽略undefined、symbol和函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    name1: undefined,</span><br><span class="line">    name3: function() &#123;&#125;,</span><br><span class="line">    name4:  Symbol(&#x27;A&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">const obj2 = JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(obj2); // &#123;name: &quot;A&quot;&#125;</span><br></pre></td></tr></table></figure><p>#循环递归</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj, hash = new WeakMap()) &#123;</span><br><span class="line">  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作</span><br><span class="line">  if (obj instanceof Date) return new Date(obj);</span><br><span class="line">  if (obj instanceof RegExp) return new RegExp(obj);</span><br><span class="line">  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span><br><span class="line">  if (typeof obj !== &quot;object&quot;) return obj;</span><br><span class="line">  // 是对象的话就要进行深拷贝</span><br><span class="line">  if (hash.get(obj)) return hash.get(obj);</span><br><span class="line">  let cloneObj = new obj.constructor();</span><br><span class="line">  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      // 实现一个递归拷贝</span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#四、区别<br>下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别<br><img src="https://static.vue-js.com/d9862c00-69b8-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样</p><p>浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浅拷贝</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">    name : &#x27;init&#x27;,</span><br><span class="line">    arr : [1,[2,3],4],</span><br><span class="line">&#125;;</span><br><span class="line">const obj3=shallowClone(obj1) // 一个浅拷贝方法</span><br><span class="line">obj3.name = &quot;update&quot;;</span><br><span class="line">obj3.arr[1] = [5,6,7] ; // 新旧对象还是共享同一块内存</span><br><span class="line"></span><br><span class="line">console.log(&#x27;obj1&#x27;,obj1) // obj1 &#123; name: &#x27;init&#x27;,  arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="line">console.log(&#x27;obj3&#x27;,obj3) // obj3 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br></pre></td></tr></table></figure><p>但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 深拷贝</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">    name : &#x27;init&#x27;,</span><br><span class="line">    arr : [1,[2,3],4],</span><br><span class="line">&#125;;</span><br><span class="line">const obj4=deepClone(obj1) // 一个深拷贝方法</span><br><span class="line">obj4.name = &quot;update&quot;;</span><br><span class="line">obj4.arr[1] = [5,6,7] ; // 新对象跟原对象不共享内存</span><br><span class="line"></span><br><span class="line">console.log(&#x27;obj1&#x27;,obj1) // obj1 &#123; name: &#x27;init&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;</span><br><span class="line">console.log(&#x27;obj4&#x27;,obj4) // obj4 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br></pre></td></tr></table></figure><p>#小结<br>前提为拷贝类型为引用类型的情况下：<br>1.浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址<br>2.深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</p>]]></content>
    
    
    <summary type="html">深拷贝和浅拷贝区别</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>说说JavaScript中的数据类型？存储上的差别？</title>
    <link href="http://example.com/2017/09/25/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2017/09/25/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F/</id>
    <published>2017-09-25T07:25:00.000Z</published>
    <updated>2022-10-05T11:13:23.642Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>在JavaScript中，我们可以分成两种类型：</p><p>基本类型<br>复杂类型<br>两种类型的区别是：存储位置不同</p><p>#一、基本类型<br>基本类型主要为以下6种：</p><p>Number<br>String<br>Boolean<br>Undefined<br>null<br>symbol<br>#Number<br>数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let intNum = 55 // 10进制的55</span><br><span class="line">let num1 = 070 // 8进制的56</span><br><span class="line">let hexNum1 = 0xA //16进制的10</span><br></pre></td></tr></table></figure><p>浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let floatNum1 = 1.1;</span><br><span class="line">let floatNum2 = 0.1;</span><br><span class="line">let floatNum3 = .1; // 有效，但不推荐</span><br><span class="line">let floatNum = 3.125e7; // 等于 31250000</span><br></pre></td></tr></table></figure><p>在数值类型中，存在一个特殊数值NaN，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(0/0); // NaN</span><br><span class="line">console.log(-0/+0); // NaN</span><br></pre></td></tr></table></figure><p>Undefined<br>Undefined 类型只有一个值，就是特殊值 undefined。当使用 var或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let message;</span><br><span class="line">console.log(message == undefined); // true</span><br></pre></td></tr></table></figure><p>包含undefined 值的变量跟未定义变量是有区别的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let message; // 这个变量被声明了，只是值为 undefined</span><br><span class="line"></span><br><span class="line">console.log(message); // &quot;undefined&quot;</span><br><span class="line">console.log(age); // 没有声明过这个变量，报错</span><br></pre></td></tr></table></figure><p>String<br>字符串可以使用双引号（”）、单引号（’）或反引号（`）标示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let firstName = &quot;John&quot;;</span><br><span class="line">let lastName = &#x27;Jacob&#x27;;</span><br><span class="line">let lastName = `Jingleheimerschmidt`</span><br></pre></td></tr></table></figure><p>字符串是不可变的，意思是一旦创建，它们的值就不能变了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let lang = &quot;Java&quot;;</span><br><span class="line">lang = lang + &quot;Script&quot;;  // 先销毁再创建</span><br></pre></td></tr></table></figure><p>Null<br>Null类型同样只有一个值，即特殊值 null</p><p>逻辑上讲， null 值表示一个空对象指针，这也是给typeof传一个 null 会返回 “object” 的原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let car = null;</span><br><span class="line">console.log(typeof car); // &quot;object&quot;</span><br></pre></td></tr></table></figure><p>undefined 值是由 null值派生而来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(null == undefined); // true</span><br></pre></td></tr></table></figure><p>只要变量要保存对象，而当时又没有那个对象可保存，就可用 null来填充该变量</p><p>#Boolean<br>Boolean（布尔值）类型有两个字面值： true 和false<br>通过Boolean可以将其他类型的数据转化成布尔值<br>规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型      转换为 true 的值      转换为 false 的值</span><br><span class="line"> String         非空字符串          &quot;&quot; </span><br><span class="line"> Number 非零数值（包括无穷值）0 、 NaN </span><br><span class="line"> Object  任意对象    null</span><br><span class="line">Undefined N/A （不存在） undefined</span><br></pre></td></tr></table></figure><p>Symbol<br>Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let genericSymbol = Symbol();</span><br><span class="line">let otherGenericSymbol = Symbol();</span><br><span class="line">console.log(genericSymbol == otherGenericSymbol); // false</span><br><span class="line"></span><br><span class="line">let fooSymbol = Symbol(&#x27;foo&#x27;);</span><br><span class="line">let otherFooSymbol = Symbol(&#x27;foo&#x27;);</span><br><span class="line">console.log(fooSymbol == otherFooSymbol); // false</span><br></pre></td></tr></table></figure><p>二、引用类型<br>复杂类型统称为Object，我们这里主要讲述下面三种：</p><p>Object<br>Array<br>Function<br>#Object<br>创建object常用方式为对象字面量表示法，属性名可以是字符串或数值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    &quot;age&quot;: 29,</span><br><span class="line">    5: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Array<br>JavaScript数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, 2, &#123;age: 20 &#125;]</span><br><span class="line">colors.push(2)</span><br></pre></td></tr></table></figure><p>Function<br>函数实际上是对象，每个函数都是 Function类型的实例，而 Function也有属性和方法，跟其他引用类型一样<br>函数存在三种常见的表达方式：<br>函数声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sum = function(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数：函数声明和函数表达式两种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sum = (num1, num2) =&gt; &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>三、存储区别<br>基本数据类型和引用数据类型存储在内存中的位置不同：</p><p>基本数据类型存储在栈中</p><p>引用类型的对象存储于堆中</p><p>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值</p><p>下面来举个例子</p><p>#基本类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 10;</span><br><span class="line">let b = a; // 赋值操作</span><br><span class="line">b = 20;</span><br><span class="line">console.log(a); // 10值</span><br></pre></td></tr></table></figure><p>a的值为一个基本类型，是存储在栈中，将a的值赋给b，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址</p><p>下图演示了基本类型赋值的过程：</p><p><img src="https://static.vue-js.com/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>引用类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;&#125;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.name = &quot;Xxx&quot;;</span><br><span class="line">console.log(obj1.name); // xxx</span><br></pre></td></tr></table></figure><p>引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。</p><p>obj1是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了obj2，实际上他们共同指向了同一个堆内存对象，所以更改obj2会对obj1产生影响</p><p>下图演示这个引用类型赋值过程<br><img src="https://static.vue-js.com/a34bdd10-6463-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>小结<br>声明变量时不同的内存地址分配：<br>简单类型的值存放在栈中，在栈中存放的是对应的值<br>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址<br>不同的类型数据导致赋值变量时的不同：<br>简单类型赋值，是生成相同的值，两个对象对应不同的地址<br>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</p>]]></content>
    
    
    <summary type="html">选择器继承！优先级是怎么排列？</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS提高性能的方法有哪些?</title>
    <link href="http://example.com/2017/09/13/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <id>http://example.com/2017/09/13/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/</id>
    <published>2017-09-13T03:00:00.000Z</published>
    <updated>2022-10-05T11:01:05.685Z</updated>
    
    <content type="html"><![CDATA[<p>一、前言<br>每一个网页都离不开css，但是很多人又认为，css主要是用来完成页面布局的，像一些细节或者优化，就不需要怎么考虑，实际上这种想法是不正确的</p><p>作为页面渲染和内容展现的重要环节，css影响着用户对整个网站的第一体验</p><p>因此，在整个产品研发过程中，css性能优化同样需要贯穿全程</p><p>#二、实现方式<br>实现方式有很多种，主要有如下：</p><p>内联首屏关键CSS<br>异步加载CSS<br>资源压缩<br>合理使用选择器<br>减少使用昂贵的属性<br>不要使用@import<br>#内联首屏关键CSS<br>在打开一个页面，页面首要内容出现在屏幕的时间影响着用户的体验，而通过内联css关键代码能够使浏览器在下载完html后就能立刻渲染</p><p>而如果外部引用css代码，在解析html结构过程中遇到外部css文件，才会开始下载css代码，再渲染</p><p>所以，CSS内联使用使渲染时间提前</p><p>注意：但是较大的css代码并不合适内联（初始拥塞窗口、没有缓存），而其余代码则采取外部引用方式</p><p>#异步加载CSS<br>在CSS文件请求、下载、解析完成之前，CSS会阻塞渲染，浏览器将不会渲染任何已处理的内容</p><p>前面加载内联代码后，后面的外部引用css则没必要阻塞浏览器渲染。这时候就可以采取异步加载的方案，主要有如下：</p><p>使用javascript将link标签插到head标签最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建link标签</span><br><span class="line">const myCSS = document.createElement( &quot;link&quot; );</span><br><span class="line">myCSS.rel = &quot;stylesheet&quot;;</span><br><span class="line">myCSS.href = &quot;mystyles.css&quot;;</span><br><span class="line">// 插入到header的最后位置</span><br><span class="line">document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling );</span><br></pre></td></tr></table></figure><p>设置link标签media属性为noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将media的值设为screen或all，从而让浏览器开始解析CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;mystyles.css&quot; media=&quot;noexist&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure><p>通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel设回stylesheet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;alternate stylesheet&quot; href=&quot;mystyles.css&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure><p>资源压缩<br>利用webpack、gulp/grunt、rollup等模块化工具，将css代码进行压缩，使文件变小，大大降低了浏览器的加载时间</p><p>#合理使用选择器<br>css匹配的规则是从右往左开始匹配，例如#markdown .content h3匹配规则如下：</p><p>先找到h3标签元素<br>然后去除祖先不是.content的元素<br>最后去除祖先不是#markdown的元素<br>如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高</p><p>所以我们在编写选择器的时候，可以遵循以下规则：</p><p>不要嵌套使用过多复杂选择器，最好不要三层以上<br>使用id选择器就没必要再进行嵌套<br>通配符和属性选择器效率最低，避免使用<br>#减少使用昂贵的属性<br>在页面发生重绘的时候，昂贵属性如box-shadow/border-radius/filter/透明度/:nth-child等，会降低浏览器的渲染性能</p><p>#不要使用@import<br>css样式文件有两种引入方式，一种是link元素，另一种是@import</p><p>@import会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时</p><p>而且多个@import可能会导致下载顺序紊乱</p><p>比如一个css文件index.css包含了以下内容：@import url(“reset.css”)</p><p>那么浏览器就必须先把index.css下载、解析和执行后，才下载、解析和执行第二个文件reset.css</p><p>#其他<br>减少重排操作，以及减少不必要的重绘<br>了解哪些属性可以继承而来，避免对这些属性重复编写<br>cssSprite，合成所有icon图片，用宽高加上backgroud-position的背景图方式显现出我们要的icon图，减少了http请求<br>把小的icon图片转成base64编码<br>CSS3动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性<br>#三、总结<br>css实现性能的方式可以从选择器嵌套、属性特性、减少http这三面考虑，同时还要注意css代码的加载顺序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、前言&lt;br&gt;每一个网页都离不开css，但是很多人又认为，css主要是用来完成页面布局的，像一些细节或者优化，就不需要怎么考虑，实际上这种想法是不正确的&lt;/p&gt;
&lt;p&gt;作为页面渲染和内容展现的重要环节，css影响着用户对整个网站的第一体验&lt;/p&gt;
&lt;p&gt;因此，在整个产品研</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新增了哪些新特性？</title>
    <link href="http://example.com/2017/08/30/CSS3%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F/CSS3%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F/"/>
    <id>http://example.com/2017/08/30/CSS3%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F/CSS3%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F/</id>
    <published>2017-08-30T08:30:00.000Z</published>
    <updated>2022-10-05T10:55:14.136Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>css，即层叠样式表（Cascading Style Sheets）的简称，是一种标记语言，由浏览器解释执行用来使页面变得更美观</p><p>css3是css的最新标准，是向后兼容的，CSS1/2的特性在CSS3 里都是可以使用的</p><p>而CSS3 也增加了很多新特性，为开发带来了更佳的开发体验</p><p>#二、选择器<br>css3中新增了一些选择器，主要为如下图所示：<br><img src="https://static.vue-js.com/e368cf20-9b5e-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>三、新样式<br>#边框<br>css3新增了三个边框属性，分别是：</p><p>border-radius：创建圆角边框</p><p>box-shadow：为元素添加阴影</p><p>border-image：使用图片来绘制边框</p><p>#box-shadow<br>设置元素阴影，设置属性如下：</p><p>水平阴影<br>垂直阴影<br>模糊距离(虚实)<br>阴影尺寸(影子大小)<br>阴影颜色<br>内/外阴影<br>其中水平阴影和垂直阴影是必须设置的</p><p>#背景<br>新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break</p><p>#background-clip<br>用于确定背景画区，有以下几种可能的属性：</p><p>background-clip: border-box; 背景从border开始显示<br>background-clip: padding-box; 背景从padding开始显示<br>background-clip: content-box; 背景显content区域开始显示<br>background-clip: no-clip; 默认属性，等同于border-box<br>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围</p><p>#background-origin<br>当我们设置背景图片时，图片是会以左上角对齐，但是是以border的左上角对齐还是以padding的左上角或者content的左上角对齐? border-origin正是用来设置这个的</p><p>background-origin: border-box; 从border开始计算background-position<br>background-origin: padding-box; 从padding开始计算background-position<br>background-origin: content-box; 从content开始计算background-position<br>默认情况是padding-box，即以padding的左上角为原点</p><p>#background-size<br>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p><p>background-size: contain; 缩小图片以适合元素（维持像素长宽比）<br>background-size: cover; 扩展元素以填补元素（维持像素长宽比）<br>background-size: 100px 100px; 缩小图片至指定的大小<br>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸<br>#background-break<br>元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示</p><p>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）<br>background-break: bounding-box; 把盒之间的距离计算在内；<br>background-break: each-box; 为每个盒子单独重绘背景<br>#文字<br>#word-wrap<br>语法：word-wrap: normal|break-word</p><p>normal：使用浏览器默认的换行<br>break-all：允许在单词内换行<br>#text-overflow<br>text-overflow设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：</p><p>clip：修剪文本<br>ellipsis：显示省略符号来代表被修剪的文本<br>#text-shadow<br>text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p><p>#text-decoration<br>CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p><p>text-fill-color: 设置文字内部填充颜色</p><p>text-stroke-color: 设置文字边界填充颜色</p><p>text-stroke-width: 设置文字边界宽度</p><p>#颜色<br>css3新增了新的颜色表示方式rgba与hsla</p><p>rgba分为两部分，rgb为颜色值，a为透明度<br>hala分为四部分，h为色相，s为饱和度，l为亮度，a为透明度<br>#四、transition 过渡<br>transition属性可以被指定为一个或多个CSS属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：</p><p>过度效果<br>持续时间<br>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)</span><br></pre></td></tr></table></figure><p>上面为简写模式，也可以分开写各个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transition-property: width; </span><br><span class="line">transition-duration: 1s;</span><br><span class="line">transition-timing-function: linear;</span><br><span class="line">transition-delay: 2s;</span><br></pre></td></tr></table></figure><p>五、transform 转换<br>transform属性允许你旋转，缩放，倾斜或平移给定元素</p><p>transform-origin：转换元素的位置（围绕那个点进行转换），默认值为(x,y,z):(50%,50%,0)</p><p>使用方式：</p><p>transform: translate(120px, 50%)：位移<br>transform: scale(2, 0.5)：缩放<br>transform: rotate(0.5turn)：旋转<br>transform: skew(30deg, 20deg)：倾斜<br>#六、animation 动画<br>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬</p><p>animation也有很多的属性</p><p>animation-name：动画名称<br>animation-duration：动画持续时间<br>animation-timing-function：动画时间函数<br>animation-delay：动画延迟时间<br>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环<br>animation-direction：动画执行方向<br>animation-paly-state：动画播放状态<br>animation-fill-mode：动画填充模式<br>#七、渐变<br>颜色渐变是指在两个颜色之间平稳的过渡，css3渐变包括</p><p>linear-gradient：线性渐变<br>background-image: linear-gradient(direction, color-stop1, color-stop2, …);</p><p>radial-gradient：径向渐变<br>linear-gradient(0deg, red, green);</p><p>#八、其他<br>关于css3其他的新特性还包括flex弹性布局、Grid栅格布局，这两个布局在以前就已经讲过，这里就不再展示</p><p>除此之外，还包括多列布局、媒体查询、混合模式等等…..</p>]]></content>
    
    
    <summary type="html">选择器继承！优先级是怎么排列？</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css中，有哪些方式可以隐藏页面元素？区别?</title>
    <link href="http://example.com/2017/07/19/css%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%9F%E5%8C%BA%E5%88%AB/css%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%9F%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2017/07/19/css%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%9F%E5%8C%BA%E5%88%AB/css%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%9F%E5%8C%BA%E5%88%AB/</id>
    <published>2017-07-19T11:00:00.000Z</published>
    <updated>2022-10-05T10:50:24.274Z</updated>
    
    <content type="html"><![CDATA[<p>一、前言<br>在平常的样式排版中，我们经常遇到将某个模块隐藏的场景</p><p>通过css隐藏元素的方法有很多种，它们看起来实现的效果是一致的</p><p>但实际上每一种方法都有一丝轻微的不同，这些不同决定了在一些特定场合下使用哪一种方法</p><p>#二、实现方式<br>通过css实现隐藏元素方法有如下：</p><p>display:none<br>visibility:hidden<br>opacity:0<br>设置height、width模型属性为0<br>position:absolute<br>clip-path<br>#display:none<br>设置元素的display为none是最常用的隐藏元素的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">    display:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将元素设置为display:none后，元素在页面上将彻底消失</p><p>元素本身占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘</p><p>消失后，自身绑定的事件不会触发，也不会有过渡效果</p><p>特点：元素不可见，不占据空间，无法响应点击事件</p><p>#visibility:hidden<br>设置元素的visibility为hidden也是一种常用的隐藏元素的方法</p><p>从页面上仅仅是隐藏该元素，DOM结果均会存在，只是当时在一个不可见的状态，不会触发重排，但是会触发重绘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.hidden&#123;</span><br><span class="line">    visibility:hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给人的效果是隐藏了，所以他自身的事件不会触发</p><p>特点：元素不可见，占据页面空间，无法响应点击事件</p><p>#opacity:0<br>opacity属性表示元素的透明度，将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的</p><p>不会引发重排，一般情况下也会引发重绘</p><p>如果利用 animation 动画，对 opacity 做变化（animation会默认触发GPU加速），则只会触发 GPU 层面的 composite，不会触发重绘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.transparent &#123;</span><br><span class="line">    opacity:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于其仍然是存在于页面上的，所以他自身的的事件仍然是可以触发的，但被他遮挡的元素是不能触发其事件的</p><p>需要注意的是：其子元素不能设置opacity来达到显示的效果</p><p>特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件</p><p>#设置height、width属性为0<br>将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其overflow:hidden来隐藏其子元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.hiddenBox &#123;</span><br><span class="line">    margin:0;     </span><br><span class="line">    border:0;</span><br><span class="line">    padding:0;</span><br><span class="line">    height:0;</span><br><span class="line">    width:0;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：元素不可见，不占据页面空间，无法响应点击事件</p><p>#position:absolute<br>将元素移出可视区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">   position: absolute;</span><br><span class="line">   top: -9999px;</span><br><span class="line">   left: -9999px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：元素不可见，不影响页面布局</p><p>#clip-path<br>通过裁剪的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">  clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：元素不可见，占据页面空间，无法响应点击事件</p><p>#小结<br>最常用的还是display:none和visibility:hidden，其他的方式只能认为是奇招，它们的真正用途并不是用于隐藏元素，所以并不推荐使用它们</p><p>#三、区别<br>关于display: none、visibility: hidden、opacity: 0的区别，如下表所示：</p><blockquote><pre><code>        display: none    visibility: hidden    opacity: 0</code></pre><p>页面中            不存在                存在                存在<br>重排            会                    不会                不会<br>重绘            会                    会                    不一定<br>自身绑定事件    不触发                不触发                   可触发<br>transition        不支持                支持                   支持<br>子元素可复原    不能                能                       不能<br>被遮挡的元素可触发事件    能             能                        不能</p></blockquote>]]></content>
    
    
    <summary type="html">隐藏页面元素的方式</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>说说em/px/rem/vh/vw区别?</title>
    <link href="http://example.com/2017/06/08/%E8%AF%B4%E8%AF%B4em-px-rem-vh-vw%E5%8C%BA%E5%88%AB/%E8%AF%B4%E8%AF%B4em-px-rem-vh-vw%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2017/06/08/%E8%AF%B4%E8%AF%B4em-px-rem-vh-vw%E5%8C%BA%E5%88%AB/%E8%AF%B4%E8%AF%B4em-px-rem-vh-vw%E5%8C%BA%E5%88%AB/</id>
    <published>2017-06-08T02:30:00.000Z</published>
    <updated>2022-10-05T11:34:39.612Z</updated>
    
    <content type="html"><![CDATA[<p>一、介绍<br>传统的项目开发中，我们只会用到px、%、em这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性</p><p>从CSS3开始，浏览器对计量单位的支持又提升到了另外一个境界，新增了rem、vh、vw、vm等一些新的计量单位</p><p>利用这些新的单位开发出比较良好的响应式页面，适应多种不同分辨率的终端，包括移动设备等</p><p>#二、单位<br>在css单位中，可以分为长度单位、绝对单位，如下表所指示</p><p>CSS单位<br>相对长度单位    em、ex、ch、rem、vw、vh、vmin、vmax、%<br>绝对长度单位    cm、mm、in、px、pt、pc<br>这里我们主要讲述px、em、rem、vh、vw</p><p>#px<br>px，表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的，所以像素为计量单位被分在了绝对长度单位中</p><p>有些人会把px认为是相对长度，原因在于在移动端中存在设备像素比，px实际显示的大小是不确定的</p><p>这里之所以认为px为绝对单位，在于px的大小和元素的其他属性无关</p><p>#em<br>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em = 16px）</p><p>为了简化 font-size 的换算，我们需要在css中的 body 选择器中声明font-size= 62.5%，这就使 em 值变为 16px*62.5% = 10px</p><p>这样 12px = 1.2em, 10px = 1em, 也就是说只需要将你的原来的px 数值除以 10，然后换上 em作为单位就行了</p><p>特点：</p><p>em 的值并不是固定的<br>em 会继承父级元素的字体大小<br>em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸<br>任意浏览器的默认字体高都是 16px<br>举个例子</p><blockquote><div class="big">    我是14px=1.4rem<div class="small">我是12px=1.2rem</div></div></blockquote><p>样式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    html &#123;font-size: 10px;  &#125; /*  公式16px*62.5%=10px  */  </span><br><span class="line">    .big&#123;font-size: 1.4rem&#125;</span><br><span class="line">    .small&#123;font-size: 1.2rem&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这时候.big元素的font-size为14px，而.small元素的font-size为12px<br>#rem<br>rem，相对单位，相对的只是HTML根元素font-size的值<br>同理，如果想要简化font-size的转化，我们可以在根元素html中加入font-size: 62.5%</p><blockquote><p>html {font-size: 62.5%;  } /*  公式16px*62.5%=10px  */ </p></blockquote><p>这样页面中1rem=10px、1.2rem=12px、1.4rem=14px、1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助<br>特点：<br>rem单位可谓集相对大小和绝对大小的优点于一身<br>和em不同的是rem总是相对于根元素，而不像em一样使用级联的方式来计算尺寸<br>#vh、vw<br>vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，vh则为窗口的高度<br>这里的窗口分成几种情况：<br>在桌面端，指的是浏览器的可视区域<br>移动端指的就是布局视口<br>像vw、vh，比较容易混淆的一个单位是%，不过百分比宽泛的讲是相对于父元素：<br>对于普通定位元素就是我们理解的父元素<br>对于position: absolute;的元素是相对于已定位的父元素<br>对于position: fixed;的元素是相对于 ViewPort（可视窗口）<br>#三、总结<br>px：绝对单位，页面按精确像素展示<br>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算，整个页面内1em不是一个固定的值<br>rem：相对单位，可理解为root em, 相对根节点html的字体大小来计算<br>vh、vw：主要用于页面视口大小布局，在页面布局上更加方便简单</p>]]></content>
    
    
    <summary type="html">px、%、em这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css选择器有哪些？优先级？哪些属性可以继承？</title>
    <link href="http://example.com/2017/05/11/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/"/>
    <id>http://example.com/2017/05/11/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/</id>
    <published>2017-05-11T08:30:00.000Z</published>
    <updated>2022-10-05T10:24:02.423Z</updated>
    
    <content type="html"><![CDATA[<p>一、选择器<br>CSS选择器是CSS规则的第一部分</p><p>它是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式</p><p>选择器所选择的元素，叫做“选择器的对象”</p><p>我们从一个Html结构开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;one&quot;&gt;</span><br><span class="line">        &lt;p class=&quot;one_1&quot;&gt;</span><br><span class="line">        &lt;/p &gt;</span><br><span class="line">        &lt;p class=&quot;one_1&quot;&gt;</span><br><span class="line">        &lt;/p &gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>关于css属性选择器常用的有：</p><p>id选择器（#box），选择id为box的元素</p><p>类选择器（.one），选择类名为one的所有元素</p><p>标签选择器（div），选择标签为div的所有元素</p><p>后代选择器（#box div），选择id为box元素内部所有的div元素</p><p>子选择器（.one&gt;one_1），选择父元素为.one的所有.one_1的元素</p><p>相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素</p><p>群组选择器（div,p），选择div、p的所有元素</p><p>还有一些使用频率相对没那么多的选择器：</p><p>伪类选择器</p><blockquote><p>:link ：选择未被访问的链接<br>:visited：选取已被访问的链接<br>:active：选择活动链接<br>:hover ：鼠标指针浮动在上面的元素<br>:focus ：选择具有焦点的<br>:first-child：父元素的首个子元素</p></blockquote><p>伪元素选择器</p><blockquote><p>:first-letter ：用于选取指定选择器的首字母<br>:first-line ：选取指定选择器的首行<br>:before : 选择器在被选元素的内容前面插入内容<br>:after : 选择器在被选元素的内容后面插入内容</p></blockquote><p>属性选择器</p><blockquote><p>[attribute] 选择带有attribute属性的元素<br>[attribute=value] 选择所有使用attribute=value的元素<br>[attribute~=value] 选择attribute属性包含value的元素<br>[attribute|=value]：选择attribute属性以value开头的元素</p></blockquote><p>在CSS3中新增的选择器有如下：<br>层次选择器（p~ul），选择前面有p元素的每个ul元素<br>伪类选择器</p><blockquote><p>:first-of-type 表示一组同级元素中其类型的第一个元素<br>:last-of-type 表示一组同级元素中其类型的最后一个元素<br>:only-of-type 表示没有同类型兄弟元素的元素<br>:only-child 表示没有任何兄弟的元素<br>:nth-child(n) 根据元素在一组同级中的位置匹配元素<br>:nth-last-of-type(n) 匹配给定类型的元素，基于它们在一组兄弟元素中的位置，从末尾开始计数<br>:last-child 表示一组兄弟元素中的最后一个元素<br>:root 设置HTML文档<br>:empty 指定空的元素<br>:enabled 选择可用元素<br>:disabled 选择被禁用元素<br>:checked 选择选中的元素<br>:not(selector) 选择与 <selector> 不匹配的所有元素</selector></p></blockquote><p>属性选择器</p><blockquote><p>[attribute*=value]：选择attribute属性值包含value的所有元素<br>[attribute^=value]：选择attribute属性开头为value的所有元素<br>[attribute$=value]：选择attribute属性结尾为value的所有元素</p></blockquote><p>二、优先级<br>相信大家对CSS选择器的优先级都不陌生：</p><p>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器<br>到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><p>如果存在内联样式，那么 A = 1, 否则 A = 0</p><p>B的值等于 ID选择器出现的次数</p><p>C的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数</p><p>D 的值等于 标签选择器 和 伪元素 出现的总次数</p><p>这里举个例子：</p><blockquote><p>#nav-global &gt; ul &gt; li &gt; a.nav-link</p></blockquote><p>套用上面的算法，依次求出 A B C D 的值：<br>因为没有内联样式 ，所以 A = 0<br>ID选择器总共出现了1次， B = 1<br>类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 C = (1 + 0 + 0) = 1<br>标签选择器出现了3次， 伪元素出现了0次，所以 D = (3 + 0) = 3</p><p>上面算出的A 、 B、C、D 可以简记作：(0, 1, 1, 3)</p><p>知道了优先级是如何计算之后，就来看看比较规则：</p><p>从左往右依次进行比较 ，较大者优先级更高<br>如果相等，则继续往右移动一位进行比较<br>如果4位全部相等，则后面的会覆盖前面的<br>经过上面的优先级计算规则，我们知道内联样式的优先级最高，如果外部样式需要覆盖内联样式，就需要使用!important</p><p>#三、继承属性<br>在css中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性</p><p>关于继承属性，可以分成：</p><p>字体系列属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">font:组合字体</span><br><span class="line">font-family:规定元素的字体系列</span><br><span class="line">font-weight:设置字体的粗细</span><br><span class="line">font-size:设置字体的尺寸</span><br><span class="line">font-style:定义字体的风格</span><br><span class="line">font-variant:偏大或偏小的字体</span><br></pre></td></tr></table></figure><p>文本系列属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">text-indent：文本缩进</span><br><span class="line">text-align：文本水平对刘</span><br><span class="line">line-height：行高</span><br><span class="line">word-spacing：增加或减少单词间的空白</span><br><span class="line">letter-spacing：增加或减少字符间的空白</span><br><span class="line">text-transform：控制文本大小写</span><br><span class="line">direction：规定文本的书写方向</span><br><span class="line">color：文本颜色</span><br></pre></td></tr></table></figure><p>元素可见性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visibility</span><br></pre></td></tr></table></figure><p>表格布局属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caption-side：定位表格标题位置</span><br><span class="line">border-collapse：合并表格边框</span><br><span class="line">border-spacing：设置相邻单元格的边框间的距离</span><br><span class="line">empty-cells：单元格的边框的出现与消失</span><br><span class="line">table-layout：表格的宽度由什么决定</span><br></pre></td></tr></table></figure><p>列表属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list-style-type：文字前面的小点点样式</span><br><span class="line">list-style-position：小点点位置</span><br><span class="line">list-style：以上的属性可通过这属性集合</span><br></pre></td></tr></table></figure><p>引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotes：设置嵌套引用的引号类型</span><br></pre></td></tr></table></figure><p>光标属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor：箭头可以变成需要的形状</span><br></pre></td></tr></table></figure><p>继承中比较特殊的几点：<br>a 标签的字体颜色不能被继承<br>h1-h6标签字体的大下也是不能被继承的</p><p>#无继承的属性<br>display<br>文本属性：vertical-align、text-decoration<br>盒子模型的属性：宽度、高度、内外边距、边框等<br>背景属性：背景图片、颜色、位置等<br>定位属性：浮动、清除浮动、定位position等<br>生成内容属性：content、counter-reset、counter-increment<br>轮廓样式属性：outline-style、outline-width、outline-color、outline<br>页面样式属性：size、page-break-before、page-break-after</p>]]></content>
    
    
    <summary type="html">选择器继承！优先级是怎么排列？</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>谈谈你对盒子模型的理解</title>
    <link href="http://example.com/2017/05/09/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2017/05/09/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2017-05-09T03:55:21.000Z</published>
    <updated>2022-10-05T04:03:45.941Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么？<br>当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）<br>一个盒子由四个部分组成：content、padding、border、margin<br><img src="https://static.vue-js.com/976789a0-8f9b-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>content，即实际内容，显示文本和图像<br>boreder，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成<br>padding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的background属性影响<br>margin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域<br>上述是一个从二维的角度观察盒子，下面再看看看三维图：</p><p><img src="https://static.vue-js.com/b2548b00-8f9b-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>下面来段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  盒子模型</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>当我们在浏览器查看元素时，却发现元素的大小变成了240px</p><p>这是因为，在CSS中，盒子模型可以分成：</p><p>W3C 标准盒子模型<br>IE 怪异盒子模型<br>默认情况下，盒子模型为W3C 标准盒子模型</p><p>#二、标准盒子模型<br>标准盒子模型，是浏览器默认的盒子模型</p><p>下面看看标准盒子模型的模型图：<br><img src="https://static.vue-js.com/c0e1d2e0-8f9b-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>从上图可以看到：</p><p>盒子总宽度 = width + padding + border + margin;</p><p>盒子总高度 = height + padding + border + margin</p><p>也就是，width/height 只是内容高度，不包含 padding 和 border值</p><p>所以上面问题中，设置width为200px，但由于存在padding，但实际上盒子的宽度有240px</p><p>#三、IE 怪异盒子模型<br>同样看看IE 怪异盒子模型的模型图：<br><img src="https://static.vue-js.com/cfbb3ef0-8f9b-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>从上图可以看到：</p><p>盒子总宽度 = width + margin;</p><p>盒子总高度 = height + margin;</p><p>也就是，width/height 包含了 padding和 border值</p><p>#Box-sizing<br>CSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选择器具有优先级</span><br><span class="line">box-sizing: content-box|border-box|inherit:</span><br></pre></td></tr></table></figure><p>content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致<br>border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致<br>inherit 指定 box-sizing 属性的值，应该从父元素继承<br>回到上面的例子里，设置盒子为 border-box 模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">选择器具有优先级</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  盒子模型</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这时候，就可以发现盒子的所占据的宽度为200px</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://www.bilibili.com/video/BV1R4411d7BH/?spm_id_from=333.788.recommend_more_video.0&vd_source=5d6cc5bbdeda6999838ad14775716893&t=7.5" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
    
    
    <summary type="html">简述盒子模型</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css基础概念</title>
    <link href="http://example.com/2017/05/08/css%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2017/05/08/css%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2017-05-08T00:55:21.000Z</published>
    <updated>2022-10-05T03:30:21.318Z</updated>
    
    <content type="html"><![CDATA[<p>一、css基础概念<br>1、描述<br>css叫做层叠样式表，或者级联样式表，用来控制网页的样式。</p><blockquote><p>说明：制作网页的三要素<br>1、html文档：做网页的布局（结构）————结构层<br>2、css：控制显示的样式（美观）————行为层<br>3、js：控制网页的行为（与用户交互）————交互层</p></blockquote><p>2、css的作用<br>使内容与表现完全分离<br>提高了代码的可重用性和可维护性，一个css文件可以被多个html引入，一个html文件可以引入多个css文件<br>3、引入css样式的方式<br>行内样式（内联样式）：<br>在标签内部使用 style属性进行设置，只对当前行生效，功能单一<br>内部样式：在head标签里，通过style标签引入，只对当前html文件生效<br>外部样式：在head标签里，通过link外部css文件的方式，方便多处使用，可重用、可维护性高<br>导入式：在head标签里的style里，通过@import的方式引入css文件</p><blockquote><p>说明：link和@import的区别<br>@import是先加载html文件再加载css，而link是同时加载hmtl和css文件<br>@import只能引入css文件，link可以引入多种文件，比如icon<br>@import具有兼容性，link没有兼容性<br>js只能操作link引入的样式，不能操作@import引入的样式</p></blockquote><p>二、css的特点<br>1、继承性<br>color、 text-开头的、line-开头的、font-开头的属性这些关于文字样式的，都可以被子代继承，所有关于盒子的、定位的、布局的属性都不能继承。</p><p>2、优先级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选择器具有优先级</span><br><span class="line">Id&gt;class&gt;元素&gt;通配符*（全局选择器）</span><br></pre></td></tr></table></figure><p>3、层叠性<br>CSS异常冲突处理能力—层叠性。</p><p>层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！<br>CSS像艺术家一样优雅，像工程师一样严谨。</p><p>当选择器，选择上了某个元素的时候，那么要这么统计权重：</p><p>id的数量，类的数量，标签的数量，还有先后顺序，当优先级相同的情况下，写在后面的会覆盖前面的样式</p>]]></content>
    
    
    <summary type="html">CSS基础概念详解</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础</title>
    <link href="http://example.com/2017/05/05/HTML%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2017/05/05/HTML%E5%9F%BA%E7%A1%80/</id>
    <published>2017-05-05T00:55:21.000Z</published>
    <updated>2022-10-05T03:22:47.602Z</updated>
    
    <content type="html"><![CDATA[<p>简释：一种为普通文件中某些字句加上标示的语言，其目的在于运用标记（tag）使文件达到预期的显示效果。<br>HTML 是在 SGML 定义下的一个描述性语言，或可说 HTML 是 SGML 的一个应用程式，HTML 不是程式语言，如 C++ 和 Java 之类，它只是标示语言，基本上你只要明白了各种 标记的用法便算学懂了 HTML，HTML 的格式非常简单，只是由文字及标记组合而成，于 编辑方面，任何文字编辑器都可以，只要能将文件另存成 ASCII 纯文字格式即可，当然 以专业的网页编辑软件为佳。<br>阅读须知：<br>这一篇HTML剖析偏重于标记的介绍，考虑到易懂及每节的篇幅问题，我并不按 W3C 的 HTML 分类，这可令你更易选择有兴趣的标记，其中只有文件标记是必读的，其 余可任意选择。这一篇不会提及任何网页编辑软件，只要掌握了 HTML ，任何网页 编辑工具都可以变成一把利器。<br>标记写法：<br>任何标记皆由”&lt;”及”&gt;”所围住，如</p><p>标记名与小于号之间不能留有空白字符。<br>某些标记　要加上参数，某些则不必。如 Hello<br>参数只可加于起始标记中。<br>在起始标记之标记名前加上符号”/“便是其终结标记，如<br>标记字母大小写皆可。</p><p>围堵标记与空标记：<br>标记按型态分为围堵标记与空标记<br>围堵标记<br>顾名思义，它以起始标记及终结标记将文字围住，令其达到预期显示效果。<br>例如 HTML Source ： Creation of Webpage is my favourite.<br>显示成： Creation of Webpage is my favourite.</p><p>其中 便称为围堵标记。<br>它以起始标记及终结标记标示文字 Creation of webpage ，令它显示成粗体，两者失其一都会发生错误显示。</p><p>空标记<br>是指标记单独出现，只有起始标记没有终结标记。<br>例如 HTML Source：<br>I love Creation of Webpage.<br>It’s a wonderful place.<br>显示成：<br>I love Creation of Webpage.<br>It’s a wonderful place.</p><p>其中换行标记<br>便属空标记。<br>它的作用便是将标记后所有东西显示于下一行，可见终结标记于它是没意义的， 但有些人会为空标记加上终结标记，这是为方便记认而己，对 HTML 没有影响。</p>]]></content>
    
    
    <summary type="html">掌握基础页面布局</summary>
    
    
    
    <category term="HTML" scheme="http://example.com/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>关于</title>
    <link href="http://example.com/2016/10/05/%E5%85%B3%E4%BA%8E/"/>
    <id>http://example.com/2016/10/05/%E5%85%B3%E4%BA%8E/</id>
    <published>2016-10-05T01:33:51.000Z</published>
    <updated>2022-10-05T01:35:09.375Z</updated>
    
    <content type="html"><![CDATA[<p>我的学习经历和心路历程！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的学习经历和心路历程！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
