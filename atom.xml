<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hubert个人博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-18T01:50:18.699Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Hubert</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue双向数据绑定是什么?</title>
    <link href="http://example.com/2018/11/30/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%98%AF%E4%BB%80%E4%B9%88/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://example.com/2018/11/30/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%98%AF%E4%BB%80%E4%B9%88/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2018-11-30T11:22:00.000Z</published>
    <updated>2022-10-18T01:50:18.699Z</updated>
    
    <content type="html"><![CDATA[<p>一、什么是双向绑定<br>我们先从单向绑定切入单向绑定非常简单，就是把 Model 绑定到 View，当我们用 JavaScript 代码更新 Model 时，View 就会自动更新双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了 View，Model 的数据也自动被更新了，这种情况就是双向绑定举个栗子<br><img src="https://static.vue-js.com/d65738d0-3ac9-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>当用户填写表单时，View 的状态就被更新了，如果此时可以自动更新 Model 的状态，那就相当于我们把 Model 和 View 做了双向绑定关系图如下<br><img src="https://static.vue-js.com/dcc1d4a0-3ac9-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>二、双向绑定的原理是什么<br>我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成</p><p>数据层（Model）：应用的数据及业务逻辑<br>视图层（View）：应用的展示效果，各类 UI 组件<br>业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来<br>而上面的这个分层的架构方案，可以用一个专业术语进行称呼：MVVM 这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理</p><p>#理解 ViewModel<br>它的主要职责就是：</p><p>数据变化后更新视图<br>视图变化后更新数据<br>当然，它还有两个主要部分组成</p><p>监听器（Observer）：对所有数据的属性进行监听<br>解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 #三、实现双向绑定<br>我们还是以 Vue 为例，先来看看 Vue 中的双向绑定流程是什么的</p><p>new Vue()首先执行初始化，对 data 执行响应化处理，这个过程发生 Observe 中<br>同时对模板执行编译，找到其中动态绑定的数据，从 data 中获取并初始化视图，这个过程发生在 Compile 中<br>同时定义⼀个更新函数和 Watcher，将来对应数据变化时 Watcher 会调用更新函数<br>由于 data 的某个 key 在⼀个视图中可能出现多次，所以每个 key 都需要⼀个管家 Dep 来管理多个 Watcher<br>将来 data 中数据⼀旦发生变化，会首先找到对应的 Dep，通知所有 Watcher 执行更新函数<br>流程图如下：<br><img src="https://static.vue-js.com/e5369850-3ac9-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>实现<br>先来一个构造函数：执行初始化，对 data 执行响应化处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Vue &#123;  </span><br><span class="line"> constructor(options) &#123;  </span><br><span class="line"> this.$options = options;  </span><br><span class="line">    this.$data = options.data;  </span><br><span class="line"> // 对 data 选项做响应式处理  </span><br><span class="line"> observe(this.$data);  </span><br><span class="line">    // 代理data到vm上  </span><br><span class="line">    proxy(this);  </span><br><span class="line">    // 执行编译  </span><br><span class="line">    new Compile(options.el, this);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对data选项执行响应化具体操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function observe(obj) &#123;  </span><br><span class="line">  if (typeof obj !== &quot;object&quot; || obj == null) &#123;  </span><br><span class="line">    return;  </span><br><span class="line">  &#125;  </span><br><span class="line">  new Observer(obj);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Observer &#123;  </span><br><span class="line">  constructor(value) &#123;  </span><br><span class="line">    this.value = value;  </span><br><span class="line">    this.walk(value);  </span><br><span class="line">  &#125;  </span><br><span class="line">  walk(obj) &#123;  </span><br><span class="line">    Object.keys(obj).forEach((key) =&gt; &#123;  </span><br><span class="line">      defineReactive(obj, key, obj[key]);  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>编译Compile<br>对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数<br><img src="https://static.vue-js.com/f27e19c0-3ac9-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Compile &#123;  </span><br><span class="line">  constructor(el, vm) &#123;  </span><br><span class="line">    this.$vm = vm;  </span><br><span class="line"> this.$el = document.querySelector(el);  // 获取dom  </span><br><span class="line">    if (this.$el) &#123;  </span><br><span class="line"> this.compile(this.$el);  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> compile(el) &#123;  </span><br><span class="line"> const childNodes = el.childNodes;  </span><br><span class="line"> Array.from(childNodes).forEach((node) =&gt; &#123; // 遍历子元素  </span><br><span class="line"> if (this.isElement(node)) &#123; // 判断是否为节点  </span><br><span class="line"> console.log(&quot;编译元素&quot; + node.nodeName);  </span><br><span class="line"> &#125; else if (this.isInterpolation(node)) &#123;  </span><br><span class="line"> console.log(&quot;编译插值⽂本&quot; + node.textContent); // 判断是否为插值文本</span><br><span class="line">&#125;  </span><br><span class="line"> if (node.childNodes &amp;&amp; node.childNodes.length &gt; 0) &#123; // 判断是否有子元素  </span><br><span class="line"> this.compile(node); // 对子元素进行递归遍历  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;);  </span><br><span class="line"> &#125;  </span><br><span class="line"> isElement(node) &#123;  </span><br><span class="line"> return node.nodeType == 1;  </span><br><span class="line"> &#125;  </span><br><span class="line"> isInterpolation(node) &#123;  </span><br><span class="line"> return node.nodeType == 3 &amp;&amp; /\&#123;\&#123;(.\*)\&#125;\&#125;/.test(node.textContent);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>依赖收集<br>视图中会用到 data 中某 key，这称为依赖。同⼀个 key 可能出现多次，每次都需要收集出来用⼀个 Watcher 来维护它们，此过程称为依赖收集多个 Watcher 需要⼀个 Dep 来管理，需要更新时由 Dep 统⼀通知<br><img src="https://static.vue-js.com/fa191f40-3ac9-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>实现思路</p><p>defineReactive 时为每⼀个 key 创建⼀个 Dep 实例<br>初始化视图时读取某个 key，例如 name1，创建⼀个 watcher1<br>由于触发 name1 的 getter 方法，便将 watcher1 添加到 name1 对应的 Dep 中<br>当 name1 更新，setter 触发时，便可通过对应 Dep 通知其管理所有 Watcher 更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 负责更新视图  </span><br><span class="line">class Watcher &#123;  </span><br><span class="line"> constructor(vm, key, updater) &#123;  </span><br><span class="line"> this.vm = vm  </span><br><span class="line"> this.key = key  </span><br><span class="line"> this.updaterFn = updater</span><br><span class="line"></span><br><span class="line">    // 创建实例时，把当前实例指定到Dep.target静态属性上</span><br><span class="line">    Dep.target = this</span><br><span class="line">    // 读一下key，触发get</span><br><span class="line">    vm[key]</span><br><span class="line">    // 置空</span><br><span class="line">    Dep.target = null</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"> // 未来执行 dom 更新函数，由 dep 调用的  </span><br><span class="line"> update() &#123;  </span><br><span class="line"> this.updaterFn.call(this.vm, this.vm[this.key])  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>声明 Dep</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dep &#123;  </span><br><span class="line"> constructor() &#123;  </span><br><span class="line"> this.deps = []; // 依赖管理  </span><br><span class="line"> &#125;  </span><br><span class="line"> addDep(dep) &#123;  </span><br><span class="line"> this.deps.push(dep);  </span><br><span class="line"> &#125;  </span><br><span class="line"> notify() &#123;  </span><br><span class="line"> this.deps.forEach((dep) =&gt; dep.update());  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 watcher 时触发 getter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Watcher &#123;  </span><br><span class="line"> constructor(vm, key, updateFn) &#123;  </span><br><span class="line"> Dep.target = this;  </span><br><span class="line"> this.vm[this.key];  </span><br><span class="line"> Dep.target = null;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>依赖收集，创建 Dep 实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive(obj, key, val) &#123;  </span><br><span class="line"> this.observe(val);  </span><br><span class="line"> const dep = new Dep();  </span><br><span class="line"> Object.defineProperty(obj, key, &#123;  </span><br><span class="line"> get() &#123;  </span><br><span class="line"> Dep.target &amp;&amp; dep.addDep(Dep.target);// Dep.target 也就是 Watcher 实例  </span><br><span class="line"> return val;  </span><br><span class="line"> &#125;,  </span><br><span class="line"> set(newVal) &#123;  </span><br><span class="line"> if (newVal === val) return;  </span><br><span class="line"> dep.notify(); // 通知 dep 执行更新方法  </span><br><span class="line"> &#125;,  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件之间的通信方式都有哪些？</title>
    <link href="http://example.com/2018/11/28/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>http://example.com/2018/11/28/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2018-11-28T11:33:00.000Z</published>
    <updated>2022-10-18T01:48:52.339Z</updated>
    
    <content type="html"><![CDATA[<p>一、组件间通信的概念<br>开始之前，我们把组件间通信这个词进行拆分</p><p>组件<br>通信<br>都知道组件是vue最强大的功能之一，vue中每一个.vue我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上，任何信息的交通都是通信组件间通信即指组件(.vue)通过某种方式来传递信息以达到某个目的举个栗子我们在使用UI框架中的table组件，可能会往table组件中传入某些数据，这个本质就形成了组件之间的通信</p><p>#二、组件间通信解决了什么<br>在古代，人们通过驿站、飞鸽传书、烽火报警、符号、语言、眼神、触碰等方式进行信息传递，到了今天，随着科技水平的飞速发展，通信基本完全利用有线或无线电完成，相继出现了有线电话、固定电话、无线电话、手机、互联网甚至视频电话等各种通信方式从上面这段话，我们可以看到通信的本质是信息同步，共享回到vue中，每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统</p><p>#二、组件间通信的分类<br>组件间通信的分类可以分成以下</p><p>父子组件之间的通信<br>兄弟组件之间的通信<br>祖孙与后代组件之间的通信<br>非关系组件间之间的通信<br>关系图:<br><img src="https://static.vue-js.com/85b92400-3aca-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>三、组件间通信的方案<br>整理vue中8种常规的通信方案</p><p>通过 props 传递<br>通过 $emit 触发自定义事件<br>使用 ref<br>EventBus<br>$parent 或$root<br>attrs 与 listeners<br>Provide 与 Inject<br>Vuex<br>#props传递数据<br><img src="https://static.vue-js.com/8f80a670-3aca-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>适用场景：父组件传递数据给子组件<br>子组件设置props属性，定义接收父组件传递过来的参数<br>父组件在使用子组件标签中通过字面量来传递值<br>Children.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;  </span><br><span class="line">    // 字符串形式  </span><br><span class="line"> name:String // 接收的类型参数  </span><br><span class="line">    // 对象形式  </span><br><span class="line">    age:&#123;    </span><br><span class="line">        type:Number, // 接收的类型为数值  </span><br><span class="line">        defaule:18,  // 默认值为18  </span><br><span class="line">       require:true // age属性必须传递  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>Father.vue组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Children name=&quot;jack&quot; age=18 /&gt;  </span><br></pre></td></tr></table></figure><p>$emit 触发自定义事件<br>适用场景：子组件传递数据给父组件<br>子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值<br>父组件绑定监听器获取到子组件传递过来的参数<br>Chilfen.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&#x27;add&#x27;, good)  </span><br></pre></td></tr></table></figure><p>Father.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Children @add=&quot;cartAdd($event)&quot; /&gt;  </span><br></pre></td></tr></table></figure><p>ref<br>父组件在使用子组件的时候设置ref<br>父组件通过设置子组件ref来获取数据<br>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Children ref=&quot;foo&quot; /&gt;  </span><br><span class="line">  </span><br><span class="line">this.$refs.foo  // 获取子组件实例，通过子组件实例我们就能拿到对应的数据  </span><br></pre></td></tr></table></figure><p>EventBus<br>使用场景：兄弟组件传值<br>创建一个中央事件总线EventBus<br>兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值<br>另一个兄弟组件通过$on监听自定义事件<br>Bus.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个中央时间总线类  </span><br><span class="line">class Bus &#123;  </span><br><span class="line">  constructor() &#123;  </span><br><span class="line">    this.callbacks = &#123;&#125;;   // 存放事件的名字  </span><br><span class="line">  &#125;  </span><br><span class="line">  $on(name, fn) &#123;  </span><br><span class="line">    this.callbacks[name] = this.callbacks[name] || [];  </span><br><span class="line">    this.callbacks[name].push(fn);  </span><br><span class="line">  &#125;  </span><br><span class="line">  $emit(name, args) &#123;  </span><br><span class="line">    if (this.callbacks[name]) &#123;  </span><br><span class="line">      this.callbacks[name].forEach((cb) =&gt; cb(args));  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">// main.js  </span><br><span class="line">Vue.prototype.$bus = new Bus() // 将$bus挂载到vue实例的原型上  </span><br><span class="line">// 另一种方式  </span><br><span class="line">Vue.prototype.$bus = new Vue() // Vue已经实现了Bus的功能  </span><br></pre></td></tr></table></figure><p>Children1.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$bus.$emit(&#x27;foo&#x27;)  </span><br></pre></td></tr></table></figure><p>Children2.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$bus.$on(&#x27;foo&#x27;, this.handle)  </span><br></pre></td></tr></table></figure><p>$parent 或$ root<br>通过共同祖辈$parent或者$root搭建通信桥连<br>兄弟组件</p><p>this.$parent.on(‘add’,this.add)</p><p>另一个兄弟组件</p><p>this.$parent.emit(‘add’)</p><p>#$attrs 与$ listeners<br>适用场景：祖先传递数据给子孙<br>设置批量向下传属性$attrs和 $listeners<br>包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。<br>可以通过 v-bind=”$attrs” 传⼊内部组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// child：并未在props中声明foo  </span><br><span class="line">&lt;p&gt;&lt;/p&gt;  </span><br><span class="line">  </span><br><span class="line">// parent  </span><br><span class="line">&lt;HelloWorld foo=&quot;foo&quot;/&gt;  </span><br><span class="line"></span><br><span class="line">// 给Grandson隔代传值，communication/index.vue  </span><br><span class="line">&lt;Child2 msg=&quot;lalala&quot; @some-event=&quot;onSomeEvent&quot;&gt;&lt;/Child2&gt;  </span><br><span class="line">  </span><br><span class="line">// Child2做展开  </span><br><span class="line">&lt;Grandson v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/Grandson&gt;  </span><br><span class="line">  </span><br><span class="line">// Grandson使⽤  </span><br><span class="line">&lt;div @click=&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/div&gt;  </span><br></pre></td></tr></table></figure><p>provide 与 inject<br>在祖先组件定义provide属性，返回传递的值<br>在后代组件通过inject接收组件传递过来的值<br>祖先组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">provide()&#123;  </span><br><span class="line">    return &#123;  </span><br><span class="line">        foo:&#x27;foo&#x27;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后代组件</p><p>inject:[‘foo’] // 获取到祖先组件传递过来的值  </p><p>vuex<br>适用场景: 复杂关系的组件数据传递</p><p>Vuex作用相当于一个用来存储共享变量的容器<br><img src="https://static.vue-js.com/fa207cd0-3aca-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>state用来存放共享变量的地方</p><p>getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值</p><p>mutations用来存放修改state的方法。</p><p>actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作</p><p>#小结<br>父子关系的组件数据传递选择 props  与 $emit进行传递，也可选择ref<br>兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递<br>祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject<br>复杂关系的组件数据传递可以通过vuex存放共享的变量</p>]]></content>
    
    
    <summary type="html">组件是vue最强大的功能之一，vue中每一个.vue我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中组件和插件有什么区别？</title>
    <link href="http://example.com/2018/11/26/Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2018/11/26/Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2018-11-26T11:40:00.000Z</published>
    <updated>2022-10-18T01:16:59.578Z</updated>
    
    <content type="html"><![CDATA[<p>一、组件是什么<br>回顾以前对组件的定义：</p><p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件</p><p>组件的优势</p><p>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</p><p>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</p><p>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</p><p>#二、插件是什么<br>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p><p>添加全局方法或者属性。如: vue-custom-element<br>添加全局资源：指令/过滤器/过渡等。如 vue-touch<br>通过全局混入来添加一些组件选项。如vue-router<br>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。<br>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如vue-router<br>#三、两者的区别<br>两者的区别主要表现在以下几个方面：</p><p>编写形式<br>注册形式<br>使用场景<br>#编写形式<br>#编写组件<br>编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件</p><p>vue文件标准格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>我们还可以通过template属性来编写一个组件，如果组件内容多，我们可以在外部定义template组件内容，如果组件内容并不多，我们可直接写在template属性上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;testComponent&quot;&gt;     // 组件显示的内容</span><br><span class="line">    &lt;div&gt;component!&lt;/div&gt;   </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&#x27;componentA&#x27;,&#123; </span><br><span class="line">    template: &#x27;#testComponent&#x27;  </span><br><span class="line">    template: `&lt;div&gt;component&lt;/div&gt;`  // 组件内容少可以通过这种形式</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>编写插件<br>vue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = function (Vue, options) &#123;</span><br><span class="line">  // 1. 添加全局方法或 property</span><br><span class="line">  Vue.myGlobalMethod = function () &#123;</span><br><span class="line">    // 逻辑...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 2. 添加全局资源</span><br><span class="line">  Vue.directive(&#x27;my-directive&#x27;, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      // 逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 3. 注入组件选项</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: function () &#123;</span><br><span class="line">      // 逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 4. 添加实例方法</span><br><span class="line">  Vue.prototype.$myMethod = function (methodOptions) &#123;</span><br><span class="line">    // 逻辑...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册形式<br>#组件注册<br>vue组件注册主要分为全局注册与局部注册</p><p>全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component-name&#x27;, &#123; /* ... */ &#125;)</span><br></pre></td></tr></table></figure><p>局部注册只需在用到的地方通过components属性注册一个组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const component1 = &#123;...&#125; // 定义一个组件</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">components:&#123;</span><br><span class="line">component1   // 局部注册</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件注册<br>插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(插件名字,&#123; /* ... */&#125; )</span><br></pre></td></tr></table></figure><p>注意的是：</p><p>注册插件的时候，需要在调用 new Vue() 启动应用之前完成</p><p>Vue.use会自动阻止多次注册相同插件，只会注册一次</p><p>#使用场景<br>具体的其实在插件是什么章节已经表述了，这里在总结一下</p><p>组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue</p><p>插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身</p><p>简单来说，插件就是指对Vue的功能的增强或补充</p>]]></content>
    
    
    <summary type="html">组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>动态给vue的data添加属性</title>
    <link href="http://example.com/2018/11/24/%E5%8A%A8%E6%80%81%E7%BB%99vue%E7%9A%84data%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/%E5%8A%A8%E6%80%81%E7%BB%99vue%E7%9A%84data%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/"/>
    <id>http://example.com/2018/11/24/%E5%8A%A8%E6%80%81%E7%BB%99vue%E7%9A%84data%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/%E5%8A%A8%E6%80%81%E7%BB%99vue%E7%9A%84data%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/</id>
    <published>2018-11-24T13:43:00.000Z</published>
    <updated>2022-10-18T01:11:17.094Z</updated>
    
    <content type="html"><![CDATA[<p>一、直接添加属性的问题<br>我们从一个例子开始</p><p>定义一个p标签，通过v-for指令进行遍历</p><p>然后给botton标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;(value,key) in item&quot; :key=&quot;key&quot;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;button @click=&quot;addProperty&quot;&gt;动态添加新属性&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>实例化一个vue实例，定义data属性和methods方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">   data:()=&gt;&#123;</span><br><span class="line">       item:&#123;</span><br><span class="line">            oldProperty:&quot;旧属性&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        addProperty()&#123;</span><br><span class="line">            this.items.newProperty = &quot;新属性&quot;  // 为items添加新属性</span><br><span class="line">            console.log(this.items)  // 输出带有newProperty的items</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>点击按钮，发现结果不及预期，数据虽然更新了（console打印出了新属性），但页面并没有更新</p><p>#二、原理分析<br>为什么产生上面的情况呢？</p><p>下面来分析一下</p><p>vue2是用过Object.defineProperty实现数据响应式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br><span class="line">Object.defineProperty(obj, &#x27;foo&#x27;, &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            console.log(`get foo:$&#123;val&#125;`);</span><br><span class="line">            return val</span><br><span class="line">        &#125;,</span><br><span class="line">        set(newVal) &#123;</span><br><span class="line">            if (newVal !== val) &#123;</span><br><span class="line">                console.log(`set foo:$&#123;newVal&#125;`);</span><br><span class="line">                val = newVal</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们访问foo属性或者设置foo值的时候都能够触发setter与getter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.foo   </span><br><span class="line">obj.foo = &#x27;new&#x27;</span><br></pre></td></tr></table></figure><p>但是我们为obj添加新属性的时候，却无法触发事件属性的拦截</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.bar  = &#x27;新属性&#x27;</span><br></pre></td></tr></table></figure><p>原因是一开始obj的foo属性被设成了响应式数据，而bar是后面新增的属性，并没有通过Object.defineProperty设置成响应式数据</p><p>#三、解决方案<br>Vue 不允许在已经创建的实例上动态添加新的响应式属性</p><p>若想实现数据与视图同步更新，可采取下面三种解决方案：</p><p>Vue.set()<br>Object.assign()<br>$forcecUpdated()<br>#Vue.set()<br>Vue.set( target, propertyName/index, value )</p><p>参数</p><p>{Object | Array} target<br>{string | number} propertyName/index<br>{any} value<br>返回值：设置的值</p><p>通过Vue.set向响应式对象中添加一个property，并确保这个新 property同样是响应式的，且触发视图更新</p><p>关于Vue.set源码（省略了很多与本节不相关的代码）</p><p>源码位置：src\core\observer\index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  ...</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里无非再次调用defineReactive方法，实现新增属性的响应式</p><p>关于defineReactive方法，内部还是通过Object.defineProperty实现属性拦截</p><p>大致代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive(obj, key, val) &#123;</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">            console.log(`get $&#123;key&#125;:$&#123;val&#125;`);</span><br><span class="line">            return val</span><br><span class="line">        &#125;,</span><br><span class="line">        set(newVal) &#123;</span><br><span class="line">            if (newVal !== val) &#123;</span><br><span class="line">                console.log(`set $&#123;key&#125;:$&#123;newVal&#125;`);</span><br><span class="line">                val = newVal</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object.assign()<br>直接使用Object.assign()添加到对象的新属性不会触发更新</p><p>应创建一个新的对象，合并原对象和混入对象的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.someObject = Object.assign(&#123;&#125;,this.someObject,&#123;newProperty1:1,newProperty2:2 ...&#125;)</span><br></pre></td></tr></table></figure><p>$forceUpdate<br>如果你发现你自己需要在 Vue中做一次强制更新，99.9% 的情况，是你在某个地方做错了事</p><p>$forceUpdate迫使Vue 实例重新渲染</p><p>PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p><p>#小结<br>如果为对象添加少量的新属性，可以直接采用Vue.set()</p><p>如果需要为新对象添加大量的新属性，则通过Object.assign()创建新对象</p><p>如果你实在不知道怎么操作时，可采取$forceUpdate()进行强制刷新 (不建议)</p><p>PS：vue3是用过proxy实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</p>]]></content>
    
    
    <summary type="html">实例和组件定义data的区别</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>为什么data属性是一个函数而不是一个对象？</title>
    <link href="http://example.com/2018/11/22/%E4%B8%BA%E4%BB%80%E4%B9%88data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F/%E4%B8%BA%E4%BB%80%E4%B9%88data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F/"/>
    <id>http://example.com/2018/11/22/%E4%B8%BA%E4%BB%80%E4%B9%88data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F/%E4%B8%BA%E4%BB%80%E4%B9%88data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F/</id>
    <published>2018-11-22T13:41:00.000Z</published>
    <updated>2022-10-18T01:06:23.558Z</updated>
    
    <content type="html"><![CDATA[<p>一、实例和组件定义data的区别<br>vue实例的时候定义data属性既可以是一个对象，也可以是一个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    // 对象格式</span><br><span class="line">    data:&#123;</span><br><span class="line">        foo:&quot;foo&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 函数格式</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">             foo:&quot;foo&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件中定义data属性，只能是一个函数</p><p>如果为组件data直接定义为一个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;component1&#x27;,&#123;</span><br><span class="line">    template:`&lt;div&gt;组件&lt;/div&gt;`,</span><br><span class="line">    data:&#123;</span><br><span class="line">        foo:&quot;foo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>则会得到警告信息<br><img src="https://static.vue-js.com/8e6fc0c0-3acc-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>警告说明：返回的data应该是一个函数在每一个组件实例中</p><p>#二、组件data定义函数与对象的区别<br>上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？</p><p>在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例</p><p>这里我们模仿组件构造函数，定义data属性，采用对象的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Component()&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">Component.prototype.data = &#123;</span><br><span class="line">count : 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个组件实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const componentA = new Component()</span><br><span class="line">const componentB = new Component()</span><br></pre></td></tr></table></figure><p>修改componentA组件data属性的值，componentB中的值也发生了改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(componentB.data.count)  // 0</span><br><span class="line">componentA.data.count = 1</span><br><span class="line">console.log(componentB.data.count)  // 1</span><br></pre></td></tr></table></figure><p>产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响</p><p>如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Component()&#123;</span><br><span class="line">this.data = this.data()</span><br><span class="line">&#125;</span><br><span class="line">Component.prototype.data = function ()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">   count : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改componentA组件data属性的值，componentB中的值不受影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(componentB.data.count)  // 0</span><br><span class="line">componentA.data.count = 1</span><br><span class="line">console.log(componentB.data.count)  // 0</span><br></pre></td></tr></table></figure><p>vue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染</p><p>#三、原理分析<br>首先可以看看vue初始化data的代码，data的定义可以是函数也可以是对象</p><p>源码位置：/vue-dev/src/core/instance/state.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function initData (vm: Component) &#123;</span><br><span class="line">  let data = vm.$options.data</span><br><span class="line">  data = vm._data = typeof data === &#x27;function&#x27;</span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data既能是object也能是function，那为什么还会出现上文警告呢？</p><p>别急，继续看下文</p><p>组件在创建的时候，会进行选项的合并</p><p>源码位置：/vue-dev/src/core/util/options.js</p><p>自定义组件会进入mergeOptions进行选项合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // merge options</span><br><span class="line">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      // optimize internal component instantiation</span><br><span class="line">      // since dynamic options merging is pretty slow, and none of the</span><br><span class="line">      // internal component options needs special treatment.</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>定义data会进行数据校验</p><p>源码位置：/vue-dev/src/core/instance/init.js</p><p>这时候vm实例为undefined，进入if判断，若data类型不是function，则出现警告提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">strats.data = function (</span><br><span class="line">  parentVal: any,</span><br><span class="line">  childVal: any,</span><br><span class="line">  vm?: Component</span><br><span class="line">): ?Function &#123;</span><br><span class="line">  if (!vm) &#123;</span><br><span class="line">    if (childVal &amp;&amp; typeof childVal !== &quot;function&quot;) &#123;</span><br><span class="line">      process.env.NODE_ENV !== &quot;production&quot; &amp;&amp;</span><br><span class="line">        warn(</span><br><span class="line">          &#x27;The &quot;data&quot; option should be a function &#x27; +</span><br><span class="line">            &quot;that returns a per-instance value in component &quot; +</span><br><span class="line">            &quot;definitions.&quot;,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      return parentVal;</span><br><span class="line">    &#125;</span><br><span class="line">    return mergeDataOrFn(parentVal, childVal);</span><br><span class="line">  &#125;</span><br><span class="line">  return mergeDataOrFn(parentVal, childVal, vm);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>#四、结论<br>根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况<br>组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象</p>]]></content>
    
    
    <summary type="html">实例和组件定义data的区别</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SPA首屏加载速度慢的怎么解决？</title>
    <link href="http://example.com/2018/11/20/SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
    <id>http://example.com/2018/11/20/SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</id>
    <published>2018-11-20T12:30:00.000Z</published>
    <updated>2022-10-18T01:02:26.250Z</updated>
    
    <content type="html"><![CDATA[<p>一、什么是首屏加载<br>首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容</p><p>首屏加载可以说是用户体验中最重要的环节</p><p>#关于计算首屏时间<br>利用performance.timing提供的数据：<br><img src="https://static.vue-js.com/2e2491a0-3acc-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>通过DOMContentLoad或者performance来计算出首屏时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 方案一：</span><br><span class="line">document.addEventListener(&#x27;DOMContentLoaded&#x27;, (event) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;first contentful painting&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">// 方案二：</span><br><span class="line">performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0].startTime</span><br><span class="line"></span><br><span class="line">// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]</span><br><span class="line">// 会返回一个 PerformancePaintTiming的实例，结构如下：</span><br><span class="line">&#123;</span><br><span class="line">  name: &quot;first-contentful-paint&quot;,</span><br><span class="line">  entryType: &quot;paint&quot;,</span><br><span class="line">  startTime: 507.80000002123415,</span><br><span class="line">  duration: 0,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二、加载慢的原因<br>在页面渲染的过程，导致加载速度慢的因素可能如下：</p><p>网络延时问题<br>资源文件体积是否过大<br>资源是否重复发送请求去加载了<br>加载脚本的时候，渲染内容堵塞了<br>#三、解决方案<br>常见的几种SPA首屏优化方式</p><p>减小入口文件积<br>静态资源本地缓存<br>UI框架按需加载<br>图片资源的压缩<br>组件重复打包<br>开启GZip压缩<br>使用SSR<br>#减小入口文件体积<br>常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加<br><img src="https://static.vue-js.com/486cee90-3acc-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>在vue-router配置路由的时候，采用动态加载路由的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">routes:[ </span><br><span class="line">    path: &#x27;Blogs&#x27;,</span><br><span class="line">    name: &#x27;ShowBlogs&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;./components/ShowBlogs.vue&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件</p><p>#静态资源本地缓存<br>后端返回资源问题：</p><p>采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头</p><p>采用Service Worker离线缓存</p><p>前端合理利用localStorage</p><p>#UI框架按需加载<br>在日常使用UI框架，例如element-UI、或者antd，我们经常性直接引用整个UI库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &#x27;element-ui&#x27;</span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Button, Input, Pagination, Table, TableColumn, MessageBox &#125; from &#x27;element-ui&#x27;;</span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Input)</span><br><span class="line">Vue.use(Pagination)</span><br></pre></td></tr></table></figure><p>组件重复打包<br>假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载</p><p>解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minChunks: 3</span><br></pre></td></tr></table></figure><p>minChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</p><p>#图片资源的压缩<br>图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素</p><p>对于所有的图片资源，我们可以进行适当的压缩</p><p>对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。</p><p>#开启GZip压缩<br>拆完包之后，我们再用gzip做一下压缩 安装compression-webpack-plugin</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnmp i compression-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>在vue.congig.js中引入并修改webpack配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">configureWebpack: (config) =&gt; &#123;</span><br><span class="line">        if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;</span><br><span class="line">            // 为生产环境修改配置...</span><br><span class="line">            config.mode = &#x27;production&#x27;</span><br><span class="line">            return &#123;</span><br><span class="line">                plugins: [new CompressionPlugin(&#123;</span><br><span class="line">                    test: /\.js$|\.html$|\.css/, //匹配文件名</span><br><span class="line">                    threshold: 10240, //对超过10k的数据进行压缩</span><br><span class="line">                    deleteOriginalAssets: false //是否删除原文件</span><br><span class="line">                &#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在服务器我们也要做相应的配置 如果发送请求的浏览器支持gzip，就发送给它gzip格式的文件 我的服务器是用express框架搭建的 只要安装一下compression就能使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const compression = require(&#x27;compression&#x27;)</span><br><span class="line">app.use(compression())  // 在其他中间件使用之前调用</span><br></pre></td></tr></table></figure><p>#使用SSR<br>SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器</p><p>从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染</p><p>#小结：<br>减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化</p><p>下图是更为全面的首屏优化的方案<br><img src="https://static.vue-js.com/4fafe900-3acc-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化</p>]]></content>
    
    
    <summary type="html">首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>v-if和v-for的优先级是什么？</title>
    <link href="http://example.com/2018/11/18/v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://example.com/2018/11/18/v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2018-11-18T12:30:00.000Z</published>
    <updated>2022-10-18T00:57:35.521Z</updated>
    
    <content type="html"><![CDATA[<p>一、作用<br>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染</p><p>v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名</p><p>在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化</p><p>两者在用法上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Modal v-if=&quot;isShow&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>二、优先级<br>v-if与v-for都是vue模板系统中的指令</p><p>在vue模板编译的时候，会将指令系统转化成可执行的render函数</p><p>#示例<br>编写一个p标签，同时使用v-if与 v-for</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in items&quot;&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>创建vue实例，存放isShow与items数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &quot;#app&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      items: [</span><br><span class="line">        &#123; title: &quot;foo&quot; &#125;,</span><br><span class="line">        &#123; title: &quot;baz&quot; &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    isShow() &#123;</span><br><span class="line">      return this.items &amp;&amp; this.items.length &gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>模板指令的代码都会生成在render函数中，通过app.$options.render就能得到渲染函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ƒ anonymous() &#123;</span><br><span class="line">  with (this) &#123; return </span><br><span class="line">    _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;, </span><br><span class="line">    _l((items), function (item) </span><br><span class="line">    &#123; return (isShow) ? _c(&#x27;p&#x27;, [_v(&quot;\n&quot; + _s(item.title) + &quot;\n&quot;)]) : _e() &#125;), 0) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_l是vue的列表渲染函数，函数内部都会进行一次if判断</p><p>初步得到结论：v-for优先级是比v-if高</p><p>再将v-for与v-if置于不同标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;template v-if=&quot;isShow&quot;&gt;</span><br><span class="line">        &lt;p v-for=&quot;item in items&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>再输出下render函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ƒ anonymous() &#123;</span><br><span class="line">  with(this)&#123;return </span><br><span class="line">    _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,</span><br><span class="line">    [(isShow)?[_v(&quot;\n&quot;),</span><br><span class="line">    _l((items),function(item)&#123;return _c(&#x27;p&#x27;,[_v(_s(item.title))])&#125;)]:_e()],2)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染</p><p>我们再在查看下vue源码</p><p>源码位置：\vue-dev\src\compiler\codegen\index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export function genElement (el: ASTElement, state: CodegenState): string &#123;</span><br><span class="line">  if (el.parent) &#123;</span><br><span class="line">    el.pre = el.pre || el.parent.pre</span><br><span class="line">  &#125;</span><br><span class="line">  if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">    return genStatic(el, state)</span><br><span class="line">  &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class="line">    return genOnce(el, state)</span><br><span class="line">  &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">    return genFor(el, state)</span><br><span class="line">  &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">    return genIf(el, state)</span><br><span class="line">  &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;</span><br><span class="line">    return genChildren(el, state) || &#x27;void 0&#x27;</span><br><span class="line">  &#125; else if (el.tag === &#x27;slot&#x27;) &#123;</span><br><span class="line">    return genSlot(el, state)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // component or element</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行if判断的时候，v-for是比v-if先进行判断</p><p>最终结论：v-for优先级比v-if高</p><p>#三、注意事项<br>永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）<br>如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环<br><template v-if="isShow"><br>    <p v-for="item in items"><br></p></template><br>如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    items: function() &#123;</span><br><span class="line">      return this.list.filter(function (item) &#123;</span><br><span class="line">        return item.isShow</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>请描述下你对vue生命周期的理解？</title>
    <link href="http://example.com/2018/11/15/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2018/11/15/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2018-11-15T12:40:00.000Z</published>
    <updated>2022-10-18T00:50:53.524Z</updated>
    
    <content type="html"><![CDATA[<p>一、生命周期是什么<br>生命周期（Life Cycle）的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程在Vue中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作PS：在Vue生命周期钩子会自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())</p><p>#二、生命周期有哪些<br>Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">生命周期描述</span><br><span class="line">beforeCreate组件实例被创建之初</span><br><span class="line">created组件实例已经完全创建</span><br><span class="line">beforeMount组件挂载之前</span><br><span class="line">mounted组件挂载到实例上去之后</span><br><span class="line">beforeUpdate组件数据发生变化，更新之前</span><br><span class="line">updated组件数据更新之后</span><br><span class="line">beforeDestroy组件实例销毁之前</span><br><span class="line">destroyed组件实例销毁之后</span><br><span class="line">activatedkeep-alive 缓存的组件激活时</span><br><span class="line">deactivatedkeep-alive 缓存的组件停用时调用</span><br><span class="line">errorCaptured捕获一个来自子孙组件的错误时被调用</span><br></pre></td></tr></table></figure><p>三、生命周期整体流程<br>Vue生命周期流程图<br><img src="https://static.vue-js.com/44114780-3aca-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>具体分析<br>beforeCreate -&gt; created</p><p>初始化vue实例，进行数据观测<br>created</p><p>完成数据观测，属性与方法的运算，watch、event事件回调的配置<br>可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算<br>此时vm.$el 并没有被创建<br>created -&gt; beforeMount</p><p>判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译<br>优先级：render &gt; template &gt; outerHTML<br>vm.el获取到的是挂载DOM的<br>beforeMount</p><p>在此阶段可获取到vm.el<br>此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上<br>beforeMount -&gt; mounted</p><p>此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM<br>mounted</p><p>vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM<br>beforeUpdate</p><p>更新的数据必须是被渲染在模板上的（el、template、render之一）<br>此时view层还未更新<br>若在beforeUpdate中再次修改数据，不会再次触发更新方法<br>updated</p><p>完成view层的更新<br>若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated）<br>beforeDestroy</p><p>实例被销毁前调用，此时实例属性与方法仍可访问<br>destroyed</p><p>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器<br>并不能清除DOM，仅仅销毁实例<br>使用场景分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">生命周期描述</span><br><span class="line">beforeCreate执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</span><br><span class="line">created组件初始化完毕，各种数据可以使用，常用于异步数据获取</span><br><span class="line">beforeMount未执行渲染、更新，dom未创建</span><br><span class="line">mounted初始化结束，dom已创建，可用于获取访问数据和dom元素</span><br><span class="line">beforeUpdate更新前，可用于获取更新前各种状态</span><br><span class="line">updated更新后，所有状态已是最新</span><br><span class="line">beforeDestroy销毁前，可用于一些定时器或订阅的取消</span><br><span class="line">destroyed组件已销毁，作用同上</span><br></pre></td></tr></table></figure><p>四、题外话：数据请求在created和mouted的区别<br>created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成；mounted是在页面dom节点渲染完毕之后就立刻执行的。触发时机上created是比mounted要更早的，两者的相同点：都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在mounted中的请求有可能导致页面闪动（因为此时页面dom结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在created生命周期当中</p>]]></content>
    
    
    <summary type="html">生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue实例挂载的过程</title>
    <link href="http://example.com/2018/11/13/Vue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/Vue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2018/11/13/Vue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/Vue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2018-11-13T12:56:00.000Z</published>
    <updated>2022-10-18T00:43:46.192Z</updated>
    
    <content type="html"><![CDATA[<p>一、思考<br>我们都听过知其然知其所以然这句话</p><p>那么不知道大家是否思考过new Vue()这个过程中究竟做了些什么？</p><p>过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等</p><p>#一、分析<br>首先找到vue的构造函数</p><p>源码位置：src\core\instance\index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>options是用户传递过来的配置项，如data、methods等常用的方法</p><p>vue构建函数调用_init方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initMixin(Vue);     // 定义 _init</span><br><span class="line">stateMixin(Vue);    // 定义 $set $get $delete $watch 等</span><br><span class="line">eventsMixin(Vue);   // 定义事件  $on  $once $off $emit</span><br><span class="line">lifecycleMixin(Vue);// 定义 _update  $forceUpdate  $destroy</span><br><span class="line">renderMixin(Vue);   // 定义 _render 返回虚拟dom</span><br></pre></td></tr></table></figure><p>首先可以看initMixin方法，发现该方法在Vue原型上定义了_init方法<br>源码位置：src\core\instance\init.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // a uid</span><br><span class="line">    vm._uid = uid++</span><br><span class="line">    let startTag, endTag</span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = `vue-perf-start:$&#123;vm._uid&#125;`</span><br><span class="line">      endTag = `vue-perf-end:$&#123;vm._uid&#125;`</span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // a flag to avoid this being observed</span><br><span class="line">    vm._isVue = true</span><br><span class="line">    // merge options</span><br><span class="line">    // 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法</span><br><span class="line">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      // optimize internal component instantiation</span><br><span class="line">      // since dynamic options merging is pretty slow, and none of the</span><br><span class="line">      // internal component options needs special treatment.</span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; else &#123; // 合并vue属性</span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">      // 初始化proxy拦截器</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    // expose real self</span><br><span class="line">    vm._self = vm</span><br><span class="line">    // 初始化组件生命周期标志位</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    // 初始化组件事件侦听</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    // 初始化渲染方法</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &#x27;beforeCreate&#x27;)</span><br><span class="line">    // 初始化依赖注入内容，在初始化data、props之前</span><br><span class="line">    initInjections(vm) // resolve injections before data/props</span><br><span class="line">    // 初始化props/data/method/watch/methods</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) // resolve provide after data/props</span><br><span class="line">    callHook(vm, &#x27;created&#x27;)</span><br><span class="line"></span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, false)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">    // 挂载元素</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>仔细阅读上面的代码，我们得到以下结论：</p><p>在调用beforeCreate之前，数据初始化并未完成，像data、props这些属性无法访问到</p><p>到了created的时候，数据已经初始化完成，能够访问data、props这些属性，但这时候并未完成dom的挂载，因此无法访问到dom元素</p><p>挂载方法是调用vm.$mount方法</p><p>initState方法是完成props/data/method/watch/methods的初始化</p><p>源码位置：src\core\instance\state.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function initState (vm: Component) &#123;</span><br><span class="line">  // 初始化组件的watcher列表</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  const opts = vm.$options</span><br><span class="line">  // 初始化props</span><br><span class="line">  if (opts.props) initProps(vm, opts.props)</span><br><span class="line">  // 初始化methods方法</span><br><span class="line">  if (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  if (opts.data) &#123;</span><br><span class="line">    // 初始化data  </span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, true /* asRootData */)</span><br><span class="line">  &#125;</span><br><span class="line">  if (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们和这里主要看初始化data的方法为initData，它与initState在同一文件上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function initData (vm: Component) &#123;</span><br><span class="line">  let data = vm.$options.data</span><br><span class="line">  // 获取到组件上的data</span><br><span class="line">  data = vm._data = typeof data === &#x27;function&#x27;</span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  if (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(</span><br><span class="line">      &#x27;data functions should return an object:\n&#x27; +</span><br><span class="line">      &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  // proxy data on instance</span><br><span class="line">  const keys = Object.keys(data)</span><br><span class="line">  const props = vm.$options.props</span><br><span class="line">  const methods = vm.$options.methods</span><br><span class="line">  let i = keys.length</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    const key = keys[i]</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">      // 属性名不能与方法名重复</span><br><span class="line">      if (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 属性名不能与state名称重复</span><br><span class="line">    if (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(</span><br><span class="line">        `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` +</span><br><span class="line">        `Use prop default value instead.`,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; else if (!isReserved(key)) &#123; // 验证key值的合法性</span><br><span class="line">      // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据</span><br><span class="line">      proxy(vm, `_data`, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // observe data</span><br><span class="line">  // 响应式监听data是数据的变化</span><br><span class="line">  observe(data, true /* asRootData */)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细阅读上面的代码，我们可以得到以下结论：</p><p>初始化顺序：props、methods、data</p><p>data定义的时候可选择函数形式或者对象形式（组件只能为函数形式）</p><p>关于数据响应式在这就不展开详细说明</p><p>上文提到挂载方法是调用vm.$mount方法</p><p>源码位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  // 获取或查询元素</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  // vue 不允许直接挂载到body或页面文档上</span><br><span class="line">  if (el === document.body || el === document.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(</span><br><span class="line">      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span><br><span class="line">    )</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const options = this.$options</span><br><span class="line">  // resolve template/el and convert to render function</span><br><span class="line">  if (!options.render) &#123;</span><br><span class="line">    let template = options.template</span><br><span class="line">    // 存在template模板，解析vue模板文件</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      if (typeof template === &#x27;string&#x27;) &#123;</span><br><span class="line">        if (template.charAt(0) === &#x27;#&#x27;) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          /* istanbul ignore if */</span><br><span class="line">          if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              `Template element not found or is empty: $&#123;options.template&#125;`,</span><br><span class="line">              this</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">          warn(&#x27;invalid template option:&#x27; + template, this)</span><br><span class="line">        &#125;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (el) &#123;</span><br><span class="line">      // 通过选择器获取元素内容</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    if (template) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&#x27;compile&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">      /**</span><br><span class="line">       *  1.将temmplate解析ast tree</span><br><span class="line">       *  2.将ast tree转换成render语法字符串</span><br><span class="line">       *  3.生成render方法</span><br><span class="line">       */</span><br><span class="line">      const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        outputSourceRange: process.env.NODE_ENV !== &#x27;production&#x27;,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, this)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(&#x27;compile end&#x27;)</span><br><span class="line">        measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return mount.call(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读上面代码，我们能得到以下结论：</p><p>不要将根元素放到body或者html上</p><p>可以在对象中定义template/render或者直接使用template、el表示元素选择器</p><p>最终都会解析成render函数，调用compileToFunctions，会将template解析成render函数</p><p>对template的解析步骤大致分为以下几步：</p><p>将html文档片段解析成ast描述符</p><p>将ast描述符解析成字符串</p><p>生成render函数</p><p>生成render函数，挂载到vm上后，会再次调用mount方法</p><p>源码位置：src\platforms\web\runtime\index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// public mount method</span><br><span class="line">Vue.prototype.$mount = function (</span><br><span class="line">  el?: string | Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : undefined</span><br><span class="line">  // 渲染组件</span><br><span class="line">  return mountComponent(this, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用mountComponent渲染组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  // 如果没有获取解析的render函数，则会抛出警告</span><br><span class="line">  // render是解析模板文件生成的</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#x27;You are using the runtime-only build of Vue where the template &#x27; +</span><br><span class="line">          &#x27;compiler is not available. Either pre-compile the templates into &#x27; +</span><br><span class="line">          &#x27;render functions, or use the compiler-included build.&#x27;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 没有获取到vue的模板文件</span><br><span class="line">        warn(</span><br><span class="line">          &#x27;Failed to mount component: template or render function not defined.&#x27;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 执行beforeMount钩子</span><br><span class="line">  callHook(vm, &#x27;beforeMount&#x27;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      const name = vm._name</span><br><span class="line">      const id = vm._uid</span><br><span class="line">      const startTag = `vue-perf-start:$&#123;id&#125;`</span><br><span class="line">      const endTag = `vue-perf-end:$&#123;id&#125;`</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; render`, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; patch`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 定义更新函数</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      // 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // we set this to vm._watcher inside the watcher&#x27;s constructor</span><br><span class="line">  // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span><br><span class="line">  // component&#x27;s mounted hook), which relies on vm._watcher being already defined</span><br><span class="line">  // 监听当前组件状态，当有数据变化时，更新组件</span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        // 数据更新引发的组件更新</span><br><span class="line">        callHook(vm, &#x27;beforeUpdate&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true /* isRenderWatcher */)</span><br><span class="line">  hydrating = false</span><br><span class="line"></span><br><span class="line">  // manually mounted instance, call mounted on self</span><br><span class="line">  // mounted is called for render-created child components in its inserted hook</span><br><span class="line">  if (vm.$vnode == null) &#123;</span><br><span class="line">    vm._isMounted = true</span><br><span class="line">    callHook(vm, &#x27;mounted&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读上面代码，我们得到以下结论：</p><p>会触发beforeCreate钩子<br>定义updateComponent渲染页面视图的方法<br>监听组件数据，一旦发生变化，触发beforeUpdate生命钩子<br>updateComponent方法主要执行在vue初始化时声明的render，update方法</p><p>render的作用主要是生成vnode</p><p>源码位置：src\core\instance\render.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 定义vue 原型上的render方法</span><br><span class="line">Vue.prototype._render = function (): VNode &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // render函数来自于组件的option</span><br><span class="line">    const &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    if (_parentVnode) &#123;</span><br><span class="line">        vm.$scopedSlots = normalizeScopedSlots(</span><br><span class="line">            _parentVnode.data.scopedSlots,</span><br><span class="line">            vm.$slots,</span><br><span class="line">            vm.$scopedSlots</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // set parent vnode. this allows render functions to have access</span><br><span class="line">    // to the data on the placeholder node.</span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    // render self</span><br><span class="line">    let vnode</span><br><span class="line">    try &#123;</span><br><span class="line">        // There&#x27;s no need to maintain a stack because all render fns are called</span><br><span class="line">        // separately from one another. Nested component&#x27;s render fns are called</span><br><span class="line">        // when parent component is patched.</span><br><span class="line">        currentRenderingInstance = vm</span><br><span class="line">        // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode</span><br><span class="line">        vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, vm, `render`)</span><br><span class="line">        // return error render result,</span><br><span class="line">        // or previous vnode to prevent render error causing blank component</span><br><span class="line">        /* istanbul ignore else */</span><br><span class="line">        if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                handleError(e, vm, `renderError`)</span><br><span class="line">                vnode = vm._vnode</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            vnode = vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        currentRenderingInstance = null</span><br><span class="line">    &#125;</span><br><span class="line">    // if the returned array contains only a single node, allow it</span><br><span class="line">    if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123;</span><br><span class="line">        vnode = vnode[0]</span><br><span class="line">    &#125;</span><br><span class="line">    // return empty vnode in case the render function errored out</span><br><span class="line">    if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">        if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123;</span><br><span class="line">            warn(</span><br><span class="line">                &#x27;Multiple root nodes returned from render function. Render function &#x27; +</span><br><span class="line">                &#x27;should return a single root node.&#x27;,</span><br><span class="line">                vm</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        vnode = createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    // set parent</span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_update主要功能是调用patch，将vnode转换为真实DOM，并且更新到页面中</p><p>源码位置：src\core\instance\lifecycle.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    const prevEl = vm.$el</span><br><span class="line">    const prevVnode = vm._vnode</span><br><span class="line">    // 设置当前激活的作用域</span><br><span class="line">    const restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    // Vue.prototype.__patch__ is injected in entry points</span><br><span class="line">    // based on the rendering backend used.</span><br><span class="line">    if (!prevVnode) &#123;</span><br><span class="line">      // initial render</span><br><span class="line">      // 执行具体的挂载逻辑</span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // updates</span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    restoreActiveInstance()</span><br><span class="line">    // update __vue__ reference</span><br><span class="line">    if (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = null</span><br><span class="line">    &#125;</span><br><span class="line">    if (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    // if parent is an HOC, update its $el as well</span><br><span class="line">    if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    // updated hook is called by the scheduler to ensure that children are</span><br><span class="line">    // updated in a parent&#x27;s updated hook.</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>三、结论<br>new Vue的时候调用会调用_init方法</p><p>定义 $set、$get 、$delete、$watch 等方法<br>定义 $on、$off、$emit、$off等事件<br>定义 _update、$forceUpdate、$destroy生命周期<br>调用$mount进行页面的挂载</p><p>挂载的时候主要是通过mountComponent方法</p><p>定义updateComponent更新函数</p><p>执行render生成虚拟DOM</p><p>_update将虚拟DOM生成真实DOM结构，并且渲染到页面中</p>]]></content>
    
    
    <summary type="html">v-show和v-if有什么区别？使用场景分别是什么？</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>v-show与v-if的区别</title>
    <link href="http://example.com/2018/11/08/v-show%E4%B8%8Ev-if%E7%9A%84%E5%8C%BA%E5%88%AB/v-show%E4%B8%8Ev-if%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2018/11/08/v-show%E4%B8%8Ev-if%E7%9A%84%E5%8C%BA%E5%88%AB/v-show%E4%B8%8Ev-if%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-11-08T11:55:00.000Z</published>
    <updated>2022-10-18T00:38:02.585Z</updated>
    
    <content type="html"><![CDATA[<p>一、v-show与v-if的共同点<br>我们都知道在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示</p><p>在用法上也是相同的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Model v-show=&quot;isShow&quot; /&gt;</span><br><span class="line">&lt;Model v-if=&quot;isShow&quot; /&gt;</span><br></pre></td></tr></table></figure><p>当表达式为true的时候，都会占据页面的位置<br>当表达式都为false时，都不会占据页面位置<br>#二、v-show与v-if的区别<br>控制手段不同<br>编译过程不同<br>编译条件不同<br>控制手段：v-show隐藏则是为该元素添加css–display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除</p><p>编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换</p><p>编译条件：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</p><p>v-show 由false变为true的时候不会触发组件的生命周期</p><p>v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法</p><p>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</p><p>#三、v-show与v-if原理分析<br>具体解析流程这里不展开讲，大致流程如下</p><p>将模板template转为ast结构的JS对象<br>用ast得到的JS对象拼装render和staticRenderFns函数<br>render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息<br>vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点<br>#v-show原理<br>不管初始条件是什么，元素总是会被渲染</p><p>我们看一下在vue中是如何实现的</p><p>代码很好理解，有transition就执行transition，没有就直接设置display属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.ts</span><br><span class="line">export const vShow: ObjectDirective&lt;VShowElement&gt; = &#123;</span><br><span class="line">  beforeMount(el, &#123; value &#125;, &#123; transition &#125;) &#123;</span><br><span class="line">    el._vod = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display</span><br><span class="line">    if (transition &amp;&amp; value) &#123;</span><br><span class="line">      transition.beforeEnter(el)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      setDisplay(el, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted(el, &#123; value &#125;, &#123; transition &#125;) &#123;</span><br><span class="line">    if (transition &amp;&amp; value) &#123;</span><br><span class="line">      transition.enter(el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  updated(el, &#123; value, oldValue &#125;, &#123; transition &#125;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUnmount(el, &#123; value &#125;) &#123;</span><br><span class="line">    setDisplay(el, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v-if原理<br>v-if在实现上比v-show要复杂的多，因为还有else else-if 等条件需要处理，这里我们也只摘抄源码中处理 v-if 的一小部分</p><p>返回一个node节点，render函数通过表达式的值来决定是否生成DOM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.ts</span><br><span class="line">export const transformIf = createStructuralDirectiveTransform(</span><br><span class="line">  /^(if|else|else-if)$/,</span><br><span class="line">  (node, dir, context) =&gt; &#123;</span><br><span class="line">    return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; &#123;</span><br><span class="line">      // ...</span><br><span class="line">      return () =&gt; &#123;</span><br><span class="line">        if (isRoot) &#123;</span><br><span class="line">          ifNode.codegenNode = createCodegenNodeForBranch(</span><br><span class="line">            branch,</span><br><span class="line">            key,</span><br><span class="line">            context</span><br><span class="line">          ) as IfConditionalExpression</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // attach this branch&#x27;s codegen node to the v-if root.</span><br><span class="line">          const parentCondition = getParentCondition(ifNode.codegenNode!)</span><br><span class="line">          parentCondition.alternate = createCodegenNodeForBranch(</span><br><span class="line">            branch,</span><br><span class="line">            key + ifNode.branches.length - 1,</span><br><span class="line">            context</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>四、v-show与v-if的使用场景<br>v-if 与 v-show 都能控制dom元素在页面的显示</p><p>v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）</p><p>如果需要非常频繁地切换，则使用 v-show 较好</p><p>如果在运行时条件很少改变，则使用 v-if 较好</p>]]></content>
    
    
    <summary type="html">v-show和v-if有什么区别？使用场景分别是什么？</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>spa应用是什么？</title>
    <link href="http://example.com/2018/11/07/spa%E5%BA%94%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/spa%E5%BA%94%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://example.com/2018/11/07/spa%E5%BA%94%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/spa%E5%BA%94%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2018-11-07T11:17:00.000Z</published>
    <updated>2022-10-18T00:34:28.225Z</updated>
    
    <content type="html"><![CDATA[<p>一、什么是SPA<br>SPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图<br><img src="https://static.vue-js.com/df14a5a0-3ac6-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>我们熟知的JS框架如react,vue,angular,ember都属于SPA</p><p>#二、SPA和MPA的区别<br>上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件，公共文件则根据需求按需加载如下图<br><img src="https://static.vue-js.com/eeb13aa0-3ac6-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>单页应用与多页应用的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单页面应用（SPA）多页面应用（MPA）</span><br><span class="line">组成一个主页面和多个页面片段多个主页面</span><br><span class="line">刷新方式局部刷新整页刷新</span><br><span class="line">url模式哈希模式历史模式</span><br><span class="line">SEO搜索引擎优化难实现，可使用SSR方式改善容易实现</span><br><span class="line">数据传递容易通过url、cookie、localStorage等传递</span><br><span class="line">页面切换速度快，用户体验良好切换加载资源，速度慢，用户体验差</span><br><span class="line">维护成本相对容易相对复杂</span><br></pre></td></tr></table></figure><p>单页应用优缺点<br>优点：</p><p>具有桌面应用的即时性、网站的可移植性和可访问性<br>用户体验好、快，内容的改变不需要重新加载整个页面<br>良好的前后端分离，分工更明确<br>缺点：</p><p>不利于搜索引擎的抓取<br>首次渲染速度相对较慢<br>#三、实现一个SPA<br>#原理<br>监听地址栏中hash变化驱动界面变化<br>用pushsate记录浏览器的历史，驱动界面发送变化<br><img src="https://static.vue-js.com/fc95bf60-3ac6-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>实现<br>#hash 模式<br>核心通过监听url中的hash来进行路由跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 定义 Router  </span><br><span class="line">class Router &#123;  </span><br><span class="line">    constructor () &#123;  </span><br><span class="line">        this.routes = &#123;&#125;; // 存放路由path及callback  </span><br><span class="line">        this.currentUrl = &#x27;&#x27;;  </span><br><span class="line">          </span><br><span class="line">        // 监听路由change调用相对应的路由回调  </span><br><span class="line">        window.addEventListener(&#x27;load&#x27;, this.refresh, false);  </span><br><span class="line">        window.addEventListener(&#x27;hashchange&#x27;, this.refresh, false);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    route(path, callback)&#123;  </span><br><span class="line">        this.routes[path] = callback;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    push(path) &#123;  </span><br><span class="line">        this.routes[path] &amp;&amp; this.routes[path]()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 使用 router  </span><br><span class="line">window.miniRouter = new Router();  </span><br><span class="line">miniRouter.route(&#x27;/&#x27;, () =&gt; console.log(&#x27;page1&#x27;))  </span><br><span class="line">miniRouter.route(&#x27;/page2&#x27;, () =&gt; console.log(&#x27;page2&#x27;))  </span><br><span class="line">  </span><br><span class="line">miniRouter.push(&#x27;/&#x27;) // page1  </span><br><span class="line">miniRouter.push(&#x27;/page2&#x27;) // page2  </span><br></pre></td></tr></table></figure><p>history模式<br>history 模式核心借用 HTML5 history api，api 提供了丰富的 router 相关属性先了解一个几个相关的api</p><p>history.pushState 浏览器历史纪录添加记录<br>history.replaceState修改浏览器历史纪录中当前纪录<br>history.popState 当 history 发生变化时触发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 定义 Router  </span><br><span class="line">class Router &#123;  </span><br><span class="line">    constructor () &#123;  </span><br><span class="line">        this.routes = &#123;&#125;;  </span><br><span class="line">        this.listerPopState()  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    init(path) &#123;  </span><br><span class="line">        history.replaceState(&#123;path: path&#125;, null, path);  </span><br><span class="line">        this.routes[path] &amp;&amp; this.routes[path]();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    route(path, callback)&#123;  </span><br><span class="line">        this.routes[path] = callback;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    push(path) &#123;  </span><br><span class="line">        history.pushState(&#123;path: path&#125;, null, path);  </span><br><span class="line">        this.routes[path] &amp;&amp; this.routes[path]();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    listerPopState () &#123;  </span><br><span class="line">        window.addEventListener(&#x27;popstate&#x27; , e =&gt; &#123;  </span><br><span class="line">            const path = e.state &amp;&amp; e.state.path;  </span><br><span class="line">            this.routers[path] &amp;&amp; this.routers[path]()  </span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 使用 Router  </span><br><span class="line">  </span><br><span class="line">window.miniRouter = new Router();  </span><br><span class="line">miniRouter.route(&#x27;/&#x27;, ()=&gt; console.log(&#x27;page1&#x27;))  </span><br><span class="line">miniRouter.route(&#x27;/page2&#x27;, ()=&gt; console.log(&#x27;page2&#x27;))  </span><br><span class="line">  </span><br><span class="line">// 跳转  </span><br><span class="line">miniRouter.push(&#x27;/page2&#x27;)  // page2  </span><br></pre></td></tr></table></figure><p>四、题外话：如何给SPA做SEO<br>下面给出基于Vue的SPA如何实现SEO的三种方式</p><p>SSR服务端渲染<br>将组件或页面通过服务器生成html，再返回给浏览器，如nuxt.js</p><p>静态化<br>目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果</p><p>使用Phantomjs针对爬虫处理<br>原理是通过Nginx配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个node server，再通过PhantomJS来解析完整的HTML，返回给爬虫。下面是大致流程图</p><p><img src="https://static.vue-js.com/25be6630-3ac7-11eb-ab90-d9ae814b240d.png" loading="lazy"></p>]]></content>
    
    
    <summary type="html">SPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>十个前端手写功能</title>
    <link href="http://example.com/2018/11/03/%E5%8D%81%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99%E5%8A%9F%E8%83%BD/%E5%8D%81%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99%E5%8A%9F%E8%83%BD/"/>
    <id>http://example.com/2018/11/03/%E5%8D%81%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99%E5%8A%9F%E8%83%BD/%E5%8D%81%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%89%8B%E5%86%99%E5%8A%9F%E8%83%BD/</id>
    <published>2018-11-03T14:14:00.000Z</published>
    <updated>2022-10-18T00:21:41.373Z</updated>
    
    <content type="html"><![CDATA[<p>一、防抖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, delay) &#123;</span><br><span class="line">  let timer</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(this, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">function task() &#123;</span><br><span class="line">  console.log(&#x27;run task&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">const debounceTask = debounce(task, 1000)</span><br><span class="line">window.addEventListener(&#x27;scroll&#x27;, debounceTask)</span><br></pre></td></tr></table></figure><p>二、节流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  let last = 0 // 上次触发时间</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    const now = Date.now()</span><br><span class="line">    if (now - last &gt; delay) &#123;</span><br><span class="line">      last = now</span><br><span class="line">      fn.apply(this, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">function task() &#123;</span><br><span class="line">  console.log(&#x27;run task&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">const throttleTask = throttle(task, 1000)</span><br><span class="line">window.addEventListener(&#x27;scroll&#x27;, throttleTask)</span><br></pre></td></tr></table></figure><p>三、深拷贝<br>JSON 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 不支持值为undefined、函数和循环引用的情况</span><br><span class="line">const cloneObj = JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure><p>递归拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj, cache = new WeakMap()) &#123;</span><br><span class="line">  if (obj === null || typeof obj !== &#x27;object&#x27;) return obj</span><br><span class="line">  if (obj instanceof Date) return new Date(obj)</span><br><span class="line">  if (obj instanceof RegExp) return new RegExp(obj)</span><br><span class="line">  </span><br><span class="line">  if (cache.has(obj)) return cache.get(obj) // 如果出现循环引用，则返回缓存的对象，防止递归进入死循环</span><br><span class="line">  let cloneObj = new obj.constructor() // 使用对象所属的构造函数创建一个新对象</span><br><span class="line">  cache.set(obj, cloneObj) // 缓存对象，用于循环引用的情况</span><br><span class="line"></span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      cloneObj[key] = deepClone(obj[key], cache) // 递归拷贝</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cloneObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">const obj = &#123; name: &#x27;Jack&#x27;, address: &#123; x: 100, y: 200 &#125; &#125;</span><br><span class="line">obj.a = obj // 循环引用</span><br><span class="line">const newObj = deepClone(obj)</span><br><span class="line">console.log(newObj.address === obj.address) // false</span><br></pre></td></tr></table></figure><p>四、手写promise</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this.status = &#x27;pending&#x27; // 初始状态为等待</span><br><span class="line">    this.value = null // 成功的值</span><br><span class="line">    this.reason = null // 失败的原因</span><br><span class="line">    this.onFulfilledCallbacks = [] // 成功的回调函数数组</span><br><span class="line">    this.onRejectedCallbacks = [] // 失败的回调函数数组</span><br><span class="line">    let resolve = value =&gt; &#123;</span><br><span class="line">      if (this.status === &#x27;pending&#x27;) &#123;</span><br><span class="line">        this.status = &#x27;fulfilled&#x27;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.onFulfilledCallbacks.forEach(fn =&gt; fn()) // 调用成功的回调函数</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let reject = reason =&gt; &#123;</span><br><span class="line">      if (this.status === &#x27;pending&#x27;) &#123;</span><br><span class="line">        this.status = &#x27;rejected&#x27;</span><br><span class="line">        this.reason = reason</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn()) // 调用失败的回调函数</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">      if (this.status === &#x27;fulfilled&#x27;) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          const x = onFulfilled(this.value);</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.status === &#x27;rejected&#x27;) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          const x = onRejected(this.reason)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.status === &#x27;pending&#x27;) &#123;</span><br><span class="line">        this.onFulfilledCallbacks.push(() =&gt; &#123; // 将成功的回调函数放入成功数组</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            const x = onFulfilled(this.value)</span><br><span class="line">            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.onRejectedCallbacks.push(() =&gt; &#123; // 将失败的回调函数放入失败数组</span><br><span class="line">          setTimeout(() =&gt; &#123;</span><br><span class="line">            const x = onRejected(this.reason)</span><br><span class="line">            x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">function p1() &#123;</span><br><span class="line">  return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, 1000, 1)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">  return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, 1000, 2)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">  console.log(res) // 1</span><br><span class="line">  return p2()</span><br><span class="line">&#125;).then(ret =&gt; &#123;</span><br><span class="line">  console.log(ret) // 2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>五、异步控制并发数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function limitRequest(urls = [], limit = 3) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const len = urls.length</span><br><span class="line">    let count = 0</span><br><span class="line"></span><br><span class="line">    // 同时启动limit个任务</span><br><span class="line">    while (limit &gt; 0) &#123;</span><br><span class="line">      start()</span><br><span class="line">      limit -= 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function start() &#123;</span><br><span class="line">      const url = urls.shift() // 从数组中拿取第一个任务</span><br><span class="line">      if (url) &#123;</span><br><span class="line">        axios.post(url).then(res =&gt; &#123;</span><br><span class="line">          // todo</span><br><span class="line">        &#125;).catch(err =&gt; &#123;</span><br><span class="line">          // todo</span><br><span class="line">        &#125;).finally(() =&gt; &#123;</span><br><span class="line">          if (count == len - 1) &#123;</span><br><span class="line">            // 最后一个任务完成</span><br><span class="line">            resolve()</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 完成之后，启动下一个任务</span><br><span class="line">            count++</span><br><span class="line">            start()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">limitRequest([&#x27;http://xxa&#x27;, &#x27;http://xxb&#x27;, &#x27;http://xxc&#x27;, &#x27;http://xxd&#x27;, &#x27;http://xxe&#x27;])</span><br></pre></td></tr></table></figure><p>六、继承<br>ES5继承（寄生组合继承）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.eat = function () &#123;</span><br><span class="line">  console.log(this.name + &#x27; is eating&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child(name, age) &#123;</span><br><span class="line">  Parent.call(this, name)</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = Object.create(Parent.prototype)</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">let xm = new Child(&#x27;xiaoming&#x27;, 12) </span><br><span class="line">console.log(xm.name) // xiaoming</span><br><span class="line">console.log(xm.age) // 12</span><br><span class="line">xm.eat() // xiaoming is eating</span><br></pre></td></tr></table></figure><p>ES6 继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    console.log(this.name + &#x27; is eating&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line">    super(name)</span><br><span class="line">    this.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">let xm = new Child(&#x27;xiaoming&#x27;, 12) </span><br><span class="line">console.log(xm.name) // xiaoming</span><br><span class="line">console.log(xm.age) // 12</span><br><span class="line">xm.eat() // xiaoming is eating</span><br></pre></td></tr></table></figure><p>七、数组排序<br>sort排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 对数字进行排序，简写</span><br><span class="line">const arr = [3, 2, 4, 1, 5]</span><br><span class="line">arr.sort((a, b) =&gt; a - b)</span><br><span class="line">console.log(arr) // [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">// 对字母进行排序，简写</span><br><span class="line">const arr = [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;e&#x27;, &#x27;d&#x27;]</span><br><span class="line">arr.sort()</span><br><span class="line">console.log(arr) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br></pre></td></tr></table></figure><p>冒泡排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">  let len = arr.length</span><br><span class="line">  for (let i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">    // 从第一个元素开始，比较相邻的两个元素，前者大就交换位置</span><br><span class="line">    for (let j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">        let num = arr[j]</span><br><span class="line">        arr[j] = arr[j + 1]</span><br><span class="line">        arr[j + 1] = num</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 每次遍历结束，都能找到一个最大值，放在数组最后</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试</span><br><span class="line">console.log(bubbleSort([2, 3, 1, 5, 4])) // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>八、数组去重<br>set去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const newArr = [...new Set(arr)]</span><br><span class="line">// 或</span><br><span class="line">const newArr = Array.from(new Set(arr))</span><br></pre></td></tr></table></figure><p>indexOf 去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const newArr = arr.filter((item, index) =&gt; arr.indexOf(item) === index)</span><br></pre></td></tr></table></figure><p>九、获取url参数<br>URLSearchParams 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个URLSearchParams实例</span><br><span class="line">const urlSearchParams = new URLSearchParams(window.location.search);</span><br><span class="line">// 把键值对列表转换为一个对象</span><br><span class="line">const params = Object.fromEntries(urlSearchParams.entries());</span><br></pre></td></tr></table></figure><p>split 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getParams(url) &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  if (url.includes(&#x27;?&#x27;)) &#123;</span><br><span class="line">    const str = url.split(&#x27;?&#x27;)[1]</span><br><span class="line">    const arr = str.split(&#x27;&amp;&#x27;)</span><br><span class="line">    arr.forEach(item =&gt; &#123;</span><br><span class="line">      const key = item.split(&#x27;=&#x27;)[0]</span><br><span class="line">      const val = item.split(&#x27;=&#x27;)[1]</span><br><span class="line">      res[key] = decodeURIComponent(val) // 解码</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">const user = getParams(&#x27;http://www.baidu.com?user=%E9%98%BF%E9%A3%9E&amp;age=16&#x27;)</span><br><span class="line">console.log(user) // &#123; user: &#x27;阿飞&#x27;, age: &#x27;16&#x27; &#125;</span><br></pre></td></tr></table></figure><p>十、发布订阅模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.cache = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(name, fn) &#123;</span><br><span class="line">    if (this.cache[name]) &#123;</span><br><span class="line">      this.cache[name].push(fn)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.cache[name] = [fn]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off(name, fn) &#123;</span><br><span class="line">    const tasks = this.cache[name]</span><br><span class="line">    if (tasks) &#123;</span><br><span class="line">      const index = tasks.findIndex((f) =&gt; f === fn || f.callback === fn)</span><br><span class="line">      if (index &gt;= 0) &#123;</span><br><span class="line">        tasks.splice(index, 1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(name, once = false) &#123;</span><br><span class="line">    if (this.cache[name]) &#123;</span><br><span class="line">      // 创建副本，如果回调函数内继续注册相同事件，会造成死循环</span><br><span class="line">      const tasks = this.cache[name].slice()</span><br><span class="line">      for (let fn of tasks) &#123;</span><br><span class="line">        fn();</span><br><span class="line">      &#125;</span><br><span class="line">      if (once) &#123;</span><br><span class="line">        delete this.cache[name]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">const eventBus = new EventEmitter()</span><br><span class="line">const task1 = () =&gt; &#123; console.log(&#x27;task1&#x27;); &#125;</span><br><span class="line">const task2 = () =&gt; &#123; console.log(&#x27;task2&#x27;); &#125;</span><br><span class="line"></span><br><span class="line">eventBus.on(&#x27;task&#x27;, task1)</span><br><span class="line">eventBus.on(&#x27;task&#x27;, task2)</span><br><span class="line">eventBus.off(&#x27;task&#x27;, task1)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  eventBus.emit(&#x27;task&#x27;) // task2</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">今天给大家带来的是10个常见的 JavaScript 手写功能，重要的地方已添加注释</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>说说你对vue的理解</title>
    <link href="http://example.com/2018/11/03/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2018/11/03/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2018-11-03T14:14:00.000Z</published>
    <updated>2022-10-18T00:31:06.221Z</updated>
    
    <content type="html"><![CDATA[<p>一、vue是什么<br>Vue.js（/vjuː/，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。2016年一项针对JavaScript的调查表明，Vue有着89%的开发者满意度。在GitHub上，该项目平均每天能收获95颗星，为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。Vue所关注的核心是MVC模式中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互PS: Vue作者尤雨溪是在为AngularJS工作之后开发出了这一框架。他声称自己的思路是提取Angular中为自己所喜欢的部分，构建出一款相当轻量的框架最早发布于2014年2月</p><p>#二、Vue核心特性<br>数据驱动（MVVM)<br>MVVM表示的是 Model-View-ViewModel</p><p>Model：模型层，负责处理业务逻辑以及和服务器端进行交互<br>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面<br>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁<br>这时候需要一张直观的关系图，如下<br><img src="https://static.vue-js.com/4402c560-3ac6-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>组件化<br>1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件2.组件化的优势</p><p>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现<br>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单<br>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级<br>#指令系统<br>解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><p>常用的指令</p><p>条件渲染指令 v-if<br>列表渲染指令v-for<br>属性绑定指令v-bind<br>事件绑定指令v-on<br>双向数据绑定指令v-model<br>没有指令之前我们是怎么做的？是不是先要获取到DOM然后在….干点啥</p><p>#三、Vue跟传统开发的区别<br>没有落地使用场景的革命不是好革命，就以一个高频的应用场景来示意吧注册账号这个需求大家应该很熟悉了，如下<br><img src="https://static.vue-js.com/5ae84840-3ac6-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>用jquery来实现大概的思路就是选择流程dom对象，点击按钮隐藏当前活动流程dom对象，显示下一流程dom对象如下图(代码就不上了，上了就篇文章就没了..)<br><img src="https://static.vue-js.com/65f89e60-3ac6-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>用vue来实现，我们知道vue基本不操作dom节点， 双向绑定使dom节点跟视图绑定后，通过修改变量的值控制dom节点的各类属性。所以其实现思路为：视图层使用一变量控制dom节点显示与否，点击按钮则改变该变量，如下图<br><img src="https://static.vue-js.com/6f916fb0-3ac6-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>总结就是：</p><p>Vue所有的界面事件，都是只去操作数据的，Jquery操作DOM<br>Vue所有界面的变动，都是根据数据自动绑定出来的，Jquery操作DOM<br>#四、Vue和React对比<br>这里就做几个简单的类比吧，当然没有好坏之分，只是使用场景不同</p><p>#相同点<br>都有组件化思想<br>都支持服务器端渲染<br>都有Virtual DOM（虚拟dom）<br>数据驱动视图<br>都有支持native的方案：Vue的weex、React的React native<br>都有自己的构建工具：Vue的vue-cli、React的Create React App<br>#区别<br>数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流<br>数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据<br>组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数<br>diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM</p>]]></content>
    
    
    <summary type="html">Vue.js（/vjuː/，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>BFC是什么?</title>
    <link href="http://example.com/2018/10/30/BFC%E6%98%AF%E4%BB%80%E4%B9%88/BFC%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://example.com/2018/10/30/BFC%E6%98%AF%E4%BB%80%E4%B9%88/BFC%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2018-10-30T12:31:00.000Z</published>
    <updated>2022-10-15T04:02:06.403Z</updated>
    
    <content type="html"><![CDATA[<p>BFC到底是什么东西<br>BFC 全称：Block Formatting Context， 名为 “块级格式化上下文”。<br>W3C官方解释为：BFC它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，Block Formatting Context提供了一个环境，HTML在这个环境中按照一定的规则进行布局。<br>简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用BFC呢，BFC可以看做是一个CSS元素属性</p><p>BFC的规则</p><p>1.BFC就是一个块级元素，块级元素会在垂直方向一个接一个的排列<br>2.BFC就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签<br>3.垂直方向的距离由margin决定， 属于同一个BFC的两个相邻的标签外边距会发生重叠<br>4.计算BFC的高度时，浮动元素也参与计算</p><p>不太好理解是吧，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box1&quot; id=&quot;BFC1&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box4&quot; id=&quot;BFC2&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>解释：<br>当BFC1为一块BFC区域时，这块区域包含box2、box3、box4，他们是BFC1的子元素<br>而当BFC2也是一块BFC区域时，他包含box5、box6<br>总结：<br>每一个BFC区域只包括其子元素，不包括其子元素的子元素。<br>每一个BFC区域都是独立隔绝的,互不影响<br>一个元素不能同时存在于多个BFC中</p><p>怎么生成一个BFC区域？<br>根元素（html）,或包含body的元素<br>设置浮动（float），且值不为none（为 left、right），<br>设置定位（position）, 不为static或relative（为 absolute 、 fixed）<br>设置 display 为这些值 inline-block、flex、grid、table、table-cell、table-caption<br>设置 overflow，且值不为visible (为 auto、scroll、hidden)</p><p>满足以上条件之一的即可形成BFC区域</p><p>根据BFC的特性，我们可以解决哪些问题？<br>1.根据特性1 &gt;&gt;&gt; 解决外边距的塌陷问题<br>当两个盒子设置100的外边距，会发现应该200px的外边距发生了塌陷，margin重叠只有100px<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1446cbe47e9d41409d37d51b127c5be8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br>解决这个问题，将两个盒子放在不同的BFC中即可，我们可以将其中一个元素设置成BFC区域，这里将box2设置为BFC区域，使box1，box2成为两个独立容器互不影响<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a1839d8ee4a4069b2c8575c56407d94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8d047f6c7a34caebb4166d5f7693469~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br>2.根据特性2 &gt;&gt;&gt; 解决父元素高度塌陷问题<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d369af7c65e486bb03ad486b8490c06~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ca8e8147384906b9f5239582aee6e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br>解决这个问题，将父元素设置为BFC区域即可<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3901ee047cb84c35b57fe29bf5038933~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62e5fd1547b45138af301da2150fc17~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br>3.根据特性3 &gt;&gt;&gt; 解决浮动重叠问题<br>.left设置了浮动，导致 .right 与之重叠<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/865dcb03ee6748109c552cae7e72c8e5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0e77ef7ec584fc9989aad9aaef70047~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br>解决浮动重叠，实现自适应两栏效果，使 .right 成为 BFC区域即可<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dadad93b69244598a508861846928aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97dda03cceba4631b10b230346054cae~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy"><br>写了这么些年css</p><p>只知道高度塌陷要overflow：hidden，清除浮动要overflow：hidden，外边距重叠高度不够多加点margin</p><p>遇到相关的样式问题就是打开控制台，一个个属性试</p>]]></content>
    
    
    <summary type="html">我将教你如何使用 CSS Grid(网格) 布局来创建一个超酷的图像网格，它会根据屏幕的宽度改变列的数量，以实现响应式布局</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css网格布局实现的响应式布局</title>
    <link href="http://example.com/2018/08/25/css%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/css%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2018/08/25/css%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/css%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2018-08-25T11:44:00.000Z</published>
    <updated>2022-10-15T03:13:45.722Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我将教你如何使用 CSS Grid(网格) 布局来创建一个超酷的图像网格，它会根据屏幕的宽度改变列的数量，以实现响应式布局。</p><p>而这篇文章中最漂亮的部分是：添加一行 CSS 代码即可实现响应式布局。</p><p>这意味着我们不必通过丑陋的类名（即 col-sm-4，col-md-8）来混淆 HTML ，或者为每一个屏幕尺寸创建媒体查询。</p><p>现在就让让我们开始吧！<br>设置<br>对于本文，我们将继续使用 5分钟学会 CSS Grid 布局 文章中使用的网格。然后我们将在文章的最后添加图片。以下是我们的初始网格的外观：<br><img src="https://www.html.cn/newimg88/2017/12/1_fJNIdDiScjhI9CZjdxv3Eg.png" loading="lazy"><br>这是HTML：</p><p>HTML 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;3&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;4&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;5&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>还有相应的 CSS ：</p><p>CSS 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: 100px 100px 100px;</span><br><span class="line">    grid-template-rows: 50px 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这个例子也有一些基本的样式，比如容器宽度，网格间隔，背景颜色什么的，我不会在这里介绍，因为它与 CSS Grid 没有任何关系。<br>如果这段代码让你感到困惑，我建议你阅读 5分钟学会 CSS Grid 布局 这篇文章，在那里我解释了 Grid 布局模块的基础知识。</p><p>让我们开始将 列 实现响应式布局。</p><p>使用等分(fr)单位实现基本的响应式<br>CSS Grid 带来了一个全新的值，称为等分单位，即 fr 。它允许你将容器可用空间分成你想要的多个等分空间。</p><p>让我们将每个列更改为一个等分单位宽度。</p><p>CSS 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: 1fr 1fr 1fr;</span><br><span class="line">    grid-template-rows: 50px 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发生的事情是，将整个网格的宽度分成三等分，每一列都占据一个 fr 单位。结果是：<br><img src="https://www.html.cn/newimg88/2017/12/1_JgGPqT2AfFNDD8DhG2wPdQ.gif" loading="lazy"><br>如果我们将 grid-template-columns 的值更改为 1fr 2fr 1fr，那么第 2 列现在将是另外 2 列的 2 倍。总宽度现在是 4 等分，第 2 列占据了 2 等分，而其他 2 列则各占 1 等分。看起来类似这样：<br><img src="https://www.html.cn/newimg88/2017/12/1_cpfokc1HBgCwOTNhRU9SHg.gif" loading="lazy"><br>换句话说，等分单位值使你可以非常容易地改变列的宽度。</p><p>更加高级的响应式<br>但是，上面的例子并没有给我们想要的响应式，因为这个网格总是包含 3 列。我们希望我们的网格根据容器的宽度来改变列的数量。要做到这一点，你必须学习三个新的概念。</p><p>repeat()<br>我们将从 repeat() 函数开始。 这是指定列和行更强大的方法。 让我们把原来的网格改成使用 repeat() ：</p><p>CSS 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: repeat(3, 100px);</span><br><span class="line">    grid-template-rows: repeat(2, 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换句话说，repeat(3, 100px) 与 100px 100px 100px 相同。 第一个参数指定了你想要的列数或行数，第二个参数指定了它们的宽度，所以上面的代码将为我们创建和第一个一样的布局。<br><img src="https://www.html.cn/newimg88/2017/12/1_fJNIdDiScjhI9CZjdxv3Eg.png" loading="lazy"><br>auto-fit （自适应）<br>然后是自适应。让我们跳过固定数量的列，而是用 auto-fit 取代 3 。</p><p>CSS 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-gap: 5px;</span><br><span class="line">    grid-template-columns: repeat(auto-fit, 100px);</span><br><span class="line">    grid-template-rows: repeat(2, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会达到以下效果：<br><img src="https://www.html.cn/newimg88/2017/12/1_vLZ9RD3dt0Q3hCieYfRuMg.gif" loading="lazy"><br>你会看到，现在这个网格已经可以通过容器的宽度来改变列的数量。</p><p>它只是试图尽可能多地将 100px 宽的列排列在容器中。</p><p>但是，如果我们将所有列硬编码为 100px ，我们永远得不到我们想要的灵活性，因为它们很少会加起来正好等于容器的宽度。正如你在上面的 gif 图中所看到的，网格通常会在右侧留下空白区域。</p><p>minmax()<br>为了解决这个问题，我们需要的最后一方法是 minmax()。我们只需用 minmax(100px, 1fr) 替换 100px 即可。这是最终的CSS。</p><p>CSS 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-gap: 5px;</span><br><span class="line">    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));</span><br><span class="line">    grid-template-rows: repeat(2, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，所有的响应都发生在一行 CSS 中。</p><p>这会达到以下效果：<br><img src="https://www.html.cn/newimg88/2017/12/1_1FOrkyNbaabo3_LJxcdDbg.gif" loading="lazy"><br>正如你们所见，这样很完美。minmax() 函数定义大于或等于 min 且小于或等于 max 的大小范围。</p><p>所以现在列的宽度至少 100px 。但是，如果有更多的可用空间，网格将简单地分配给每个列，因为列的值变成了一个等分单位 1fr ，而不是 100px 。</p><p>添加图片<br>现在最后一步是添加图片。 这与 CSS Grid 没有任何关系，但是我们还是要来看看代码。</p><p>我们将在每个网格项内添加一个 img 标签。</p><p>HTML 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;img src=&quot;img/forest.jpg&quot;/&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>为了使图像适合该网格项，我们将它设置为与网格项一样宽和高，然后使用 object-fit: cover;。这将使图片覆盖整个容器，如果需要的话，浏览器会裁剪该图片。<br>CSS 代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &gt; div &gt; img &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    object-fit: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.html.cn/newimg88/2017/12/1_jCNANupl0ECRzF6cOLuWNw.gif" loading="lazy"></p>]]></content>
    
    
    <summary type="html">我将教你如何使用 CSS Grid(网格) 布局来创建一个超酷的图像网格，它会根据屏幕的宽度改变列的数量，以实现响应式布局</summary>
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>你是怎么理解ES6中 Promise的？</title>
    <link href="http://example.com/2018/08/23/Promise%E7%9A%84%EF%BC%9F/Promise%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2018/08/23/Promise%E7%9A%84%EF%BC%9F/Promise%E7%9A%84%EF%BC%9F/</id>
    <published>2018-08-23T11:26:00.000Z</published>
    <updated>2022-10-12T13:41:10.603Z</updated>
    
    <content type="html"><![CDATA[<p>一、介绍<br>Promise，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p><p>在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSomething(function(result) &#123;</span><br><span class="line">  doSomethingElse(result, function(newResult) &#123;</span><br><span class="line">    doThirdThing(newResult, function(finalResult) &#123;</span><br><span class="line">      console.log(&#x27;得到最终结果: &#x27; + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure><p>阅读上面代码，是不是很难受，上述形成了经典的回调地狱</p><p>现在通过Promise的改写上面的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(function(result) &#123;</span><br><span class="line">  return doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(newResult) &#123;</span><br><span class="line">  return doThirdThing(newResult);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(finalResult) &#123;</span><br><span class="line">  console.log(&#x27;得到最终结果: &#x27; + finalResult);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure><p>瞬间感受到promise解决异步操作的优点：</p><p>链式操作减低了编码难度<br>代码可读性明显增强<br>下面我们正式来认识promise：</p><p>#状态<br>promise对象仅有三种状态</p><p>pending（进行中）<br>fulfilled（已成功）<br>rejected（已失败）<br>#特点<br>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态<br>一旦状态改变（从pending变为fulfilled和从pending变为rejected），就不会再变，任何时候都可以得到这个结果<br>#流程<br>认真阅读下图，我们能够轻松了解promise整个流程<br><img src="https://static.vue-js.com/1b02ae90-58a9-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>二、用法<br>Promise对象是一个构造函数，用来生成Promise实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;&#125;);</span><br></pre></td></tr></table></figure><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject</p><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”<br>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”<br>#实例方法<br>Promise构建出来的实例存在以下方法：</p><p>then()<br>catch()<br>finally()<br>#then()<br>then是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数</p><p>then方法返回的是一个新的Promise实例，也就是promise能链式书写的原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  return json.post;</span><br><span class="line">&#125;).then(function(post) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>#catch<br>catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&#x27;/posts.json&#x27;).then(function(posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  // 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br><span class="line">  console.log(&#x27;发生错误！&#x27;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&#x27;/post/1.json&#x27;).then(function(post) &#123;</span><br><span class="line">  return getJSON(post.commentURL);</span><br><span class="line">&#125;).then(function(comments) &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  // 处理前面三个Promise产生的错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一般来说，使用catch方法代替then()第二个参数</p><p>Promise对象抛出的错误不会传递到外层代码，即不会有任何反应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程</p><p>catch()方法之中，还能再抛出错误，通过后面catch方法捕获到</p><p>#finally()<br>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result =&gt; &#123;···&#125;)</span><br><span class="line">.catch(error =&gt; &#123;···&#125;)</span><br><span class="line">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>#构造函数方法<br>Promise构造函数存在以下方法：</p><p>all()<br>race()<br>allSettled()<br>resolve()<br>reject()<br>try()<br>#all()<br>Promise.all()方法用于将多个 Promise实例，包装成一个新的 Promise实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>接受一个数组（迭代对象）作为参数，数组成员都应为Promise实例</p><p>实例p的状态由p1、p2、p3决定，分为两种：</p><p>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数<br>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数<br>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&#x27;hello&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result)</span><br><span class="line">.catch(e =&gt; e);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;报错了&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result)</span><br><span class="line">.catch(e =&gt; e);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.then(result =&gt; console.log(result))</span><br><span class="line">.catch(e =&gt; console.log(e));</span><br><span class="line">// [&quot;hello&quot;, Error: 报错了]</span><br></pre></td></tr></table></figure><p>如果p2没有自己的catch方法，就会调用Promise.all()的catch方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&#x27;hello&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;报错了&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.then(result =&gt; console.log(result))</span><br><span class="line">.catch(e =&gt; console.log(e));</span><br><span class="line">// Error: 报错了</span><br></pre></td></tr></table></figure><p>#race()</p><p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变</p><p>率先改变的 Promise 实例的返回值则传递给p的回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([</span><br><span class="line">  fetch(&#x27;/resource-that-may-take-a-while&#x27;),</span><br><span class="line">  new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error(&#x27;request timeout&#x27;)), 5000)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(console.log)</span><br><span class="line">.catch(console.error);</span><br></pre></td></tr></table></figure><p>#allSettled()<br>Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p><p>只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promises = [</span><br><span class="line">  fetch(&#x27;/api-1&#x27;),</span><br><span class="line">  fetch(&#x27;/api-2&#x27;),</span><br><span class="line">  fetch(&#x27;/api-3&#x27;),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">await Promise.allSettled(promises);</span><br><span class="line">removeLoadingIndicator();</span><br></pre></td></tr></table></figure><p>resolve()<br>将现有对象转为 Promise对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#x27;foo&#x27;)</span><br><span class="line">// 等价于</span><br><span class="line">new Promise(resolve =&gt; resolve(&#x27;foo&#x27;))</span><br></pre></td></tr></table></figure><p>参数可以分成四种情况，分别如下：</p><p>参数是一个 Promise 实例，promise.resolve将不做任何修改、原封不动地返回这个实例<br>参数是一个thenable对象，promise.resolve会将这个对象转为 Promise对象，然后就立即执行thenable对象的then()方法<br>参数不是具有then()方法的对象，或根本就不是对象，Promise.resolve()会返回一个新的 Promise 对象，状态为resolved<br>没有参数时，直接返回一个resolved状态的 Promise 对象<br>#reject()<br>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">// 等同于</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))</span><br><span class="line"></span><br><span class="line">p.then(null, function (s) &#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure><p>Promise.reject()方法的参数，会原封不动地变成后续方法的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&#x27;出错了&#x27;)</span><br><span class="line">.catch(e =&gt; &#123;</span><br><span class="line">  console.log(e === &#x27;出错了&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>// true<br>#三、使用场景<br>将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const preloadImage = function (path) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    const image = new Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过链式操作，将多个渲染数据分别给个then，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 各司其职</span><br><span class="line">getInfo().then(res=&gt;&#123;</span><br><span class="line">    let &#123; bannerList &#125; = res</span><br><span class="line">    //渲染轮播图</span><br><span class="line">    console.log(bannerList)</span><br><span class="line">    return res</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    let &#123; storeList &#125; = res</span><br><span class="line">    //渲染店铺列表</span><br><span class="line">    console.log(storeList)</span><br><span class="line">    return res</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    let &#123; categoryList &#125; = res</span><br><span class="line">    console.log(categoryList)</span><br><span class="line">    //渲染分类列表</span><br><span class="line">    return res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过all()实现多个请求合并在一起，汇总所有请求结果，只需设置一个loading即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function initLoad()&#123;</span><br><span class="line">    // loading.show() //加载loading</span><br><span class="line">    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=&gt;&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        loading.hide() //关闭loading</span><br><span class="line">    &#125;).catch(err=&gt;&#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">        loading.hide()//关闭loading</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//数据初始化    </span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure><p>通过race可以设置图片请求超时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//请求某个图片资源</span><br><span class="line">function requestImg()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        img.onload = function()&#123;</span><br><span class="line">           resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">        //img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的</span><br><span class="line">        img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时函数，用于给请求计时</span><br><span class="line">function timeout()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            reject(&#x27;图片请求超时&#x27;);</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise</span><br><span class="line">.race([requestImg(), timeout()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Promise，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>call、apply、bind区别？</title>
    <link href="http://example.com/2018/08/21/%E5%8C%BA%E5%88%AB%EF%BC%9F/%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2018/08/21/%E5%8C%BA%E5%88%AB%EF%BC%9F/%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2018-08-21T12:43:00.000Z</published>
    <updated>2022-10-12T13:34:45.583Z</updated>
    
    <content type="html"><![CDATA[<p>一、作用<br>call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向</p><p>那么什么情况下需要改变this的指向呢？下面举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;lucy&quot;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &quot;martin&quot;,</span><br><span class="line">    say: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.say(); // martin，this 指向 obj 对象</span><br><span class="line">setTimeout(obj.say,0); // lucy，this 指向 window 对象</span><br></pre></td></tr></table></figure><p>从上面可以看到，正常情况say方法输出martin</p><p>但是我们把say放在setTimeout方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候this指向window，所以输出lucy</p><p>我们实际需要的是this指向obj对象，这时候就需要该改变this指向了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(obj.say.bind(obj),0); //martin，this指向obj对象</span><br></pre></td></tr></table></figure><p>#二、区别<br>下面再来看看apply、call、bind的使用</p><p>#apply<br>apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入</p><p>改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(...args)&#123;</span><br><span class="line">    console.log(this,args);</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    myname:&quot;张三&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.apply(obj,[1,2]); // this会变成传入的obj，传入的参数必须是一个数组；</span><br><span class="line">fn(1,2) // this指向window</span><br></pre></td></tr></table></figure><p>当第一个参数为null、undefined的时候，默认指向window(在浏览器中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.apply(null,[1,2]); // this指向window</span><br><span class="line">fn.apply(undefined,[1,2]); // this指向window</span><br></pre></td></tr></table></figure><p>#call<br>call方法的第一个参数也是this的指向，后面传入的是一个参数列表</p><p>跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(...args)&#123;</span><br><span class="line">    console.log(this,args);</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    myname:&quot;张三&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj,1,2); // this会变成传入的obj，传入的参数必须是一个数组；</span><br><span class="line">fn(1,2) // this指向window</span><br></pre></td></tr></table></figure><p>同样的，当第一个参数为null、undefined的时候，默认指向window(在浏览器中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(null,[1,2]); // this指向window</span><br><span class="line">fn.call(undefined,[1,2]); // this指向window</span><br></pre></td></tr></table></figure><p>#bind<br>bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)</p><p>改变this指向后不会立即执行，而是返回一个永久改变this指向的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(...args)&#123;</span><br><span class="line">    console.log(this,args);</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    myname:&quot;张三&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bindFn = fn.bind(obj); // this 也会变成传入的obj ，bind不是立即执行需要执行一次</span><br><span class="line">bindFn(1,2) // this指向obj</span><br><span class="line">fn(1,2) // this指向window</span><br></pre></td></tr></table></figure><p>#小结<br>从上面可以看到，apply、call、bind三者的区别在于：</p><p>三者都可以改变函数的this对象指向<br>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window<br>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入<br>bind是返回绑定this之后的函数，apply、call 则是立即执行<br>#三、实现<br>实现bind的步骤，我们可以分解成为三部分：</p><p>修改this指向<br>动态传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 方式一：只在bind中传递函数参数</span><br><span class="line">fn.bind(obj,1,2)()</span><br><span class="line"></span><br><span class="line">// 方式二：在bind中传递函数参数，也在返回函数中传递参数</span><br><span class="line">fn.bind(obj,1)(2)</span><br></pre></td></tr></table></figure><p>兼容new关键字<br>整体实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">    // 判断调用对象是否为函数</span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(&quot;Error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取参数</span><br><span class="line">    const args = [...arguments].slice(1),</span><br><span class="line">          fn = this;</span><br><span class="line"></span><br><span class="line">    return function Fn() &#123;</span><br><span class="line"></span><br><span class="line">        // 根据调用方式，传入不同绑定值</span><br><span class="line">        return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>什么是防抖和节流？</title>
    <link href="http://example.com/2018/08/19/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F/"/>
    <id>http://example.com/2018/08/19/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F/</id>
    <published>2018-08-19T14:37:00.000Z</published>
    <updated>2022-10-12T13:22:43.988Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>本质上是优化高频率执行代码的一种手段</p><p>如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p><p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率</p><p>#定义<br>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效<br>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时<br>一个经典的比喻:</p><p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p><p>假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制</p><p>电梯第一个人进来后，15秒后准时运送一次，这是节流</p><p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖</p><p>#代码实现<br>#节流<br>完成节流可以使用时间戳与定时器的写法</p><p>使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throttled1(fn, delay = 500) &#123;</span><br><span class="line">    let oldtime = Date.now()</span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        let newtime = Date.now()</span><br><span class="line">        if (newtime - oldtime &gt;= delay) &#123;</span><br><span class="line">            fn.apply(null, args)</span><br><span class="line">            oldtime = Date.now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function throttled2(fn, delay = 500) &#123;</span><br><span class="line">    let timer = null</span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        if (!timer) &#123;</span><br><span class="line">            timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                fn.apply(this, args)</span><br><span class="line">                timer = null</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function throttled(fn, delay) &#123;</span><br><span class="line">    let timer = null</span><br><span class="line">    let starttime = Date.now()</span><br><span class="line">    return function () &#123;</span><br><span class="line">        let curTime = Date.now() // 当前时间</span><br><span class="line">        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间</span><br><span class="line">        let context = this</span><br><span class="line">        let args = arguments</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        if (remaining &lt;= 0) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">            starttime = Date.now()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timer = setTimeout(fn, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#防抖<br>简单版本的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    let timeout;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        let context = this; // 保存this指向</span><br><span class="line">        let args = arguments; // 拿到event对象</span><br><span class="line"></span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(function()&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line"></span><br><span class="line">    let timeout;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        let context = this;</span><br><span class="line">        let args = arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout); // timeout 不为null</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发</span><br><span class="line">            timeout = setTimeout(function () &#123;</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) &#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timeout = setTimeout(function () &#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#二、区别<br>相同点：</p><p>都可以通过使用 setTimeout 实现<br>目的都是，降低回调执行频率。节省计算资源<br>不同点：</p><p>函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能<br>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次<br>例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次</p><p>如下图所示：<br><img src="https://static.vue-js.com/a2c81b50-8787-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>三、应用场景<br>防抖在连续的事件，只需触发一次回调的场景有：</p><p>搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>手机号、邮箱验证输入检测<br>窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。<br>节流在间隔一段时间执行一次回调的场景有：</p><p>滚动加载，加载更多或滚到底部监听<br>搜索框，搜索联想功能</p>]]></content>
    
    
    <summary type="html">本质上是优化高频率执行代码的一种手段</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>说说你对函数式编程的理解？</title>
    <link href="http://example.com/2018/08/16/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/"/>
    <id>http://example.com/2018/08/16/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/</id>
    <published>2018-08-16T13:32:00.000Z</published>
    <updated>2022-10-12T13:23:55.050Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>函数式编程是一种”编程范式”（programming paradigm），一种编写程序的方法论</p><p>主要的编程范式有三种：命令式编程，声明式编程和函数式编程</p><p>相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程</p><p>举个例子，将数组每个元素进行平方操作，命令式编程与函数式编程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 命令式编程</span><br><span class="line">var array = [0, 1, 2, 3]</span><br><span class="line">for(let i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    array[i] = Math.pow(array[i], 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数式方式</span><br><span class="line">[0, 1, 2, 3].map(num =&gt; Math.pow(num, 2))</span><br></pre></td></tr></table></figure><p>简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果</p><p>即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值<br><img src="https://static.vue-js.com/f9f83900-8534-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>可以看到，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合</p><p>#二、概念<br>#纯函数<br>函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数，也就是纯函数</p><p>纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变<br><img src="https://static.vue-js.com/04f50720-8535-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>举一个简单的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let double = value=&gt;value*2;</span><br></pre></td></tr></table></figure><p>特性：</p><p>函数内部传入指定的值，就会返回确定唯一的值<br>不会造成超出作用域的变化，例如修改全局变量或引用传递的参数<br>优势：</p><p>使用纯函数，我们可以产生可测试的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(&#x27;double(2) 等于 4&#x27;, () =&gt; &#123;</span><br><span class="line">  expect(double(2)).toBe(4);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不依赖外部环境计算，不会产生副作用，提高函数的复用性</p><p>可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读</p><p>可以组装成复杂任务的可能性。符合模块化概念及单一职责原则</p><p>#高阶函数<br>在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数</p><p>编程工作也就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据，如下图所示<br><img src="https://static.vue-js.com/104af1c0-8535-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>在这里，就是高阶函数的作用。高级函数，就是以函数作为输入或者输出的函数被称为高阶函数</p><p>通过高阶函数抽象过程，注重结果，如下面例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const forEach = function(arr,fn)&#123;</span><br><span class="line">    for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        fn(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3];</span><br><span class="line">forEach(arr,(item)=&gt;&#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面通过高阶函数 forEach来抽象循环如何做的逻辑，直接关注做了什么</p><p>高阶函数存在缓存的特性，主要是利用闭包作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const once = (fn)=&gt;&#123;</span><br><span class="line">    let done = false;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(!done)&#123;</span><br><span class="line">            fn.apply(this,fn);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;该函数已经执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        done = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>柯里化<br>柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程</p><p>一个二元函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fn = (x,y)=&gt;x+y;</span><br></pre></td></tr></table></figure><p>转化成柯里化函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const curry = function(fn)&#123;</span><br><span class="line">    return function(x)&#123;</span><br><span class="line">        return function(y)&#123;</span><br><span class="line">            return fn(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myfn = curry(fn);</span><br><span class="line">console.log( myfn(1)(2) );</span><br></pre></td></tr></table></figure><p>上面的curry函数只能处理二元情况，下面再来实现一个实现多参数的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 多参数柯里化；</span><br><span class="line">const curry = function(fn)&#123;</span><br><span class="line">    return function curriedFn(...args)&#123;</span><br><span class="line">        if(args.length&lt;fn.length)&#123;</span><br><span class="line">            return function()&#123;</span><br><span class="line">                return curriedFn(...args.concat([...arguments]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const fn = (x,y,z,a)=&gt;x+y+z+a;</span><br><span class="line">const myfn = curry(fn);</span><br><span class="line">console.log(myfn(1)(2)(3)(1));</span><br></pre></td></tr></table></figure><p>关于柯里化函数的意义如下：</p><p>让纯函数更纯，每次接受一个参数，松散解耦<br>惰性执行<br>#组合与管道<br>组合函数，目的是将多个函数组合成一个函数</p><p>举个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function afn(a)&#123;</span><br><span class="line">    return a*2;</span><br><span class="line">&#125;</span><br><span class="line">function bfn(b)&#123;</span><br><span class="line">    return b*3;</span><br><span class="line">&#125;</span><br><span class="line">const compose = (a,b)=&gt;c=&gt;a(b(c));</span><br><span class="line">let myfn =  compose(afn,bfn);</span><br><span class="line">console.log( myfn(2));</span><br></pre></td></tr></table></figure><p>可以看到compose实现一个简单的功能：形成了一个新的函数，而这个函数就是一条从 bfn -&gt; afn 的流水线</p><p>下面再来看看如何实现一个多函数组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const compose = (...fns)=&gt;val=&gt;fns.reverse().reduce((acc,fn)=&gt;fn(acc),val);</span><br></pre></td></tr></table></figure><p>compose执行是从右到左的。而管道函数，执行顺序是从左到右执行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const pipe = (...fns)=&gt;val=&gt;fns.reduce((acc,fn)=&gt;fn(acc),val);</span><br></pre></td></tr></table></figure><p>组合函数与管道函数的意义在于：可以把很多小函数组合起来完成更复杂的逻辑</p><p>#三、优缺点<br>#优点<br>更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</p><p>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响</p><p>更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性</p><p>隐性好处。减少代码量，提高维护性</p><p>#缺点：<br>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销</p><p>资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式</p><p>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</p><p>#参考文献</p>]]></content>
    
    
    <summary type="html">函数式编程是一种&quot;编程范式&quot;（programming paradigm），一种编写程序的方法论</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript本地存储的方式有哪些？</title>
    <link href="http://example.com/2018/08/13/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>http://example.com/2018/08/13/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2018-08-13T14:25:00.000Z</published>
    <updated>2022-10-12T10:57:56.909Z</updated>
    
    <content type="html"><![CDATA[<p>一、方式<br>javaScript本地缓存的方法我们主要讲述以下四种：</p><p>cookie<br>sessionStorage<br>localStorage<br>indexedDB<br>#cookie<br>Cookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP无状态导致的问题</p><p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie有效期、安全性、使用范围的可选属性组成</p><p>但是cookie在每次请求中都会被发送，如果不使用 HTTPS并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 cookie保持登录态的网站上，如果 cookie被窃取，他人很容易利用你的 cookie来假扮成你登录网站</p><p>关于cookie常用的属性如下：</p><p>Expires 用于设置 Cookie 的过期时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires=Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><p>Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比Expires高）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max-Age=604800</span><br></pre></td></tr></table></figure><p>Domain指定了 Cookie 可以送达的主机名<br>Path指定了一个 URL路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path=/docs   # /docs/Web/ 下的资源会带 Cookie 首部</span><br></pre></td></tr></table></figure><p>标记为 Secure的 Cookie只应通过被HTTPS协议加密过的请求发送给服务端<br>通过上述，我们可以看到cookie又开始的作用并不是为了缓存而设计出来，只是借用了cookie的特性实现缓存</p><p>关于cookie的使用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &#x27;名字=值&#x27;;</span><br></pre></td></tr></table></figure><p>关于cookie的修改，首先要确定domain和path属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie:name=aa; domain=aa.net; path=/  # 服务端设置</span><br><span class="line">document.cookie =name=bb; domain=aa.net; path=/  # 客户端设置</span><br></pre></td></tr></table></figure><p>最后cookie的删除，最常用的方法就是给cookie设置一个过期的事件，这样cookie过期后会被浏览器删除</p><p>#localStorage<br>HTML5新方法，IE8及以上浏览器都兼容</p><p>#特点<br>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的<br>存储的信息在同一域中是共享的<br>当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。<br>大小：5M（跟浏览器厂商有关系）<br>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡<br>受同源策略的限制<br>下面再看看关于localStorage的使用</p><p>设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;username&#x27;,&#x27;cfangxu&#x27;);</span><br></pre></td></tr></table></figure><p>获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(&#x27;username&#x27;)</span><br></pre></td></tr></table></figure><p>获取键名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.key(0) //获取第一个键名</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(&#x27;username&#x27;)</span><br></pre></td></tr></table></figure><p>一次性清除所有存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure><p>localStorage 也不是完美的，它有两个缺点：</p><p>无法像Cookie一样设置过期时间<br>只能存入字符串，无法直接存对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;key&#x27;, &#123;name: &#x27;value&#x27;&#125;);</span><br><span class="line">console.log(localStorage.getItem(&#x27;key&#x27;)); // &#x27;[object, Object]&#x27;</span><br></pre></td></tr></table></figure><p>#sessionStorage<br>sessionStorage和 localStorage使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据</p><p>#扩展的前端存储方式<br>indexedDB是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索</p><p>虽然 Web Storage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案</p><p>#优点：<br>储存量理论上没有上限<br>所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时<br>原生支持储存JS的对象<br>是个正经的数据库，意味着数据库能干的事它都能干<br>#缺点：<br>操作非常繁琐<br>本身有一定门槛<br>关于indexedDB的使用基本使用步骤如下：</p><p>打开数据库并且开始一个事务</p><p>创建一个 object store</p><p>构建一个请求来执行一些数据库操作，像增加或提取数据等。</p><p>通过监听正确类型的 DOM 事件以等待操作完成。</p><p>在操作结果上进行一些操作（可以在 request对象中找到）</p><p>关于使用indexdb的使用会比较繁琐，大家可以通过使用Godb.js库进行缓存，最大化的降低操作难度</p><p>#二、区别<br>关于cookie、sessionStorage、localStorage三者的区别主要如下：</p><p>存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p><p>有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p><p>数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</p><p>#三、应用场景<br>在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：</p><p>标记用户与跟踪用户行为的情况，推荐使用cookie<br>适合长期保存在本地的数据（令牌），推荐使用localStorage<br>敏感账号一次性登录，推荐使用sessionStorage<br>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB</p>]]></content>
    
    
    <summary type="html">javaScript本地缓存的方法我们主要讲述以下四种：</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
