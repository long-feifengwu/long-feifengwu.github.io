<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hubert个人博客</title>
  
  <subtitle>个人博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-12T13:41:10.603Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Hubert</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你是怎么理解ES6中 Promise的？</title>
    <link href="http://example.com/2018/08/23/Promise%E7%9A%84%EF%BC%9F/Promise%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2018/08/23/Promise%E7%9A%84%EF%BC%9F/Promise%E7%9A%84%EF%BC%9F/</id>
    <published>2018-08-23T11:26:00.000Z</published>
    <updated>2022-10-12T13:41:10.603Z</updated>
    
    <content type="html"><![CDATA[<p>一、介绍<br>Promise，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p><p>在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSomething(function(result) &#123;</span><br><span class="line">  doSomethingElse(result, function(newResult) &#123;</span><br><span class="line">    doThirdThing(newResult, function(finalResult) &#123;</span><br><span class="line">      console.log(&#x27;得到最终结果: &#x27; + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure><p>阅读上面代码，是不是很难受，上述形成了经典的回调地狱</p><p>现在通过Promise的改写上面的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(function(result) &#123;</span><br><span class="line">  return doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(newResult) &#123;</span><br><span class="line">  return doThirdThing(newResult);</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(finalResult) &#123;</span><br><span class="line">  console.log(&#x27;得到最终结果: &#x27; + finalResult);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure><p>瞬间感受到promise解决异步操作的优点：</p><p>链式操作减低了编码难度<br>代码可读性明显增强<br>下面我们正式来认识promise：</p><p>#状态<br>promise对象仅有三种状态</p><p>pending（进行中）<br>fulfilled（已成功）<br>rejected（已失败）<br>#特点<br>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态<br>一旦状态改变（从pending变为fulfilled和从pending变为rejected），就不会再变，任何时候都可以得到这个结果<br>#流程<br>认真阅读下图，我们能够轻松了解promise整个流程<br><img src="https://static.vue-js.com/1b02ae90-58a9-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>二、用法<br>Promise对象是一个构造函数，用来生成Promise实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;&#125;);</span><br></pre></td></tr></table></figure><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject</p><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”<br>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”<br>#实例方法<br>Promise构建出来的实例存在以下方法：</p><p>then()<br>catch()<br>finally()<br>#then()<br>then是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数</p><p>then方法返回的是一个新的Promise实例，也就是promise能链式书写的原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  return json.post;</span><br><span class="line">&#125;).then(function(post) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>#catch<br>catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&#x27;/posts.json&#x27;).then(function(posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  // 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br><span class="line">  console.log(&#x27;发生错误！&#x27;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&#x27;/post/1.json&#x27;).then(function(post) &#123;</span><br><span class="line">  return getJSON(post.commentURL);</span><br><span class="line">&#125;).then(function(comments) &#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  // 处理前面三个Promise产生的错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一般来说，使用catch方法代替then()第二个参数</p><p>Promise对象抛出的错误不会传递到外层代码，即不会有任何反应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    // 下面一行会报错，因为x没有声明</span><br><span class="line">    resolve(x + 2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程</p><p>catch()方法之中，还能再抛出错误，通过后面catch方法捕获到</p><p>#finally()<br>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result =&gt; &#123;···&#125;)</span><br><span class="line">.catch(error =&gt; &#123;···&#125;)</span><br><span class="line">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>#构造函数方法<br>Promise构造函数存在以下方法：</p><p>all()<br>race()<br>allSettled()<br>resolve()<br>reject()<br>try()<br>#all()<br>Promise.all()方法用于将多个 Promise实例，包装成一个新的 Promise实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>接受一个数组（迭代对象）作为参数，数组成员都应为Promise实例</p><p>实例p的状态由p1、p2、p3决定，分为两种：</p><p>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数<br>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数<br>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&#x27;hello&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result)</span><br><span class="line">.catch(e =&gt; e);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;报错了&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result)</span><br><span class="line">.catch(e =&gt; e);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.then(result =&gt; console.log(result))</span><br><span class="line">.catch(e =&gt; console.log(e));</span><br><span class="line">// [&quot;hello&quot;, Error: 报错了]</span><br></pre></td></tr></table></figure><p>如果p2没有自己的catch方法，就会调用Promise.all()的catch方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&#x27;hello&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;报错了&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; result);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2])</span><br><span class="line">.then(result =&gt; console.log(result))</span><br><span class="line">.catch(e =&gt; console.log(e));</span><br><span class="line">// Error: 报错了</span><br></pre></td></tr></table></figure><p>#race()</p><p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变</p><p>率先改变的 Promise 实例的返回值则传递给p的回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([</span><br><span class="line">  fetch(&#x27;/resource-that-may-take-a-while&#x27;),</span><br><span class="line">  new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error(&#x27;request timeout&#x27;)), 5000)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(console.log)</span><br><span class="line">.catch(console.error);</span><br></pre></td></tr></table></figure><p>#allSettled()<br>Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p><p>只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promises = [</span><br><span class="line">  fetch(&#x27;/api-1&#x27;),</span><br><span class="line">  fetch(&#x27;/api-2&#x27;),</span><br><span class="line">  fetch(&#x27;/api-3&#x27;),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">await Promise.allSettled(promises);</span><br><span class="line">removeLoadingIndicator();</span><br></pre></td></tr></table></figure><p>resolve()<br>将现有对象转为 Promise对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#x27;foo&#x27;)</span><br><span class="line">// 等价于</span><br><span class="line">new Promise(resolve =&gt; resolve(&#x27;foo&#x27;))</span><br></pre></td></tr></table></figure><p>参数可以分成四种情况，分别如下：</p><p>参数是一个 Promise 实例，promise.resolve将不做任何修改、原封不动地返回这个实例<br>参数是一个thenable对象，promise.resolve会将这个对象转为 Promise对象，然后就立即执行thenable对象的then()方法<br>参数不是具有then()方法的对象，或根本就不是对象，Promise.resolve()会返回一个新的 Promise 对象，状态为resolved<br>没有参数时，直接返回一个resolved状态的 Promise 对象<br>#reject()<br>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">// 等同于</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))</span><br><span class="line"></span><br><span class="line">p.then(null, function (s) &#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;);</span><br><span class="line">// 出错了</span><br></pre></td></tr></table></figure><p>Promise.reject()方法的参数，会原封不动地变成后续方法的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&#x27;出错了&#x27;)</span><br><span class="line">.catch(e =&gt; &#123;</span><br><span class="line">  console.log(e === &#x27;出错了&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>// true<br>#三、使用场景<br>将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const preloadImage = function (path) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    const image = new Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过链式操作，将多个渲染数据分别给个then，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 各司其职</span><br><span class="line">getInfo().then(res=&gt;&#123;</span><br><span class="line">    let &#123; bannerList &#125; = res</span><br><span class="line">    //渲染轮播图</span><br><span class="line">    console.log(bannerList)</span><br><span class="line">    return res</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    let &#123; storeList &#125; = res</span><br><span class="line">    //渲染店铺列表</span><br><span class="line">    console.log(storeList)</span><br><span class="line">    return res</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    let &#123; categoryList &#125; = res</span><br><span class="line">    console.log(categoryList)</span><br><span class="line">    //渲染分类列表</span><br><span class="line">    return res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过all()实现多个请求合并在一起，汇总所有请求结果，只需设置一个loading即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function initLoad()&#123;</span><br><span class="line">    // loading.show() //加载loading</span><br><span class="line">    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=&gt;&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        loading.hide() //关闭loading</span><br><span class="line">    &#125;).catch(err=&gt;&#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">        loading.hide()//关闭loading</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//数据初始化    </span><br><span class="line">initLoad()</span><br></pre></td></tr></table></figure><p>通过race可以设置图片请求超时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//请求某个图片资源</span><br><span class="line">function requestImg()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        img.onload = function()&#123;</span><br><span class="line">           resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">        //img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的</span><br><span class="line">        img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时函数，用于给请求计时</span><br><span class="line">function timeout()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            reject(&#x27;图片请求超时&#x27;);</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise</span><br><span class="line">.race([requestImg(), timeout()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Promise，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>call、apply、bind区别？</title>
    <link href="http://example.com/2018/08/21/%E5%8C%BA%E5%88%AB%EF%BC%9F/%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2018/08/21/%E5%8C%BA%E5%88%AB%EF%BC%9F/%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2018-08-21T12:43:00.000Z</published>
    <updated>2022-10-12T13:34:45.583Z</updated>
    
    <content type="html"><![CDATA[<p>一、作用<br>call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向</p><p>那么什么情况下需要改变this的指向呢？下面举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;lucy&quot;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &quot;martin&quot;,</span><br><span class="line">    say: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.say(); // martin，this 指向 obj 对象</span><br><span class="line">setTimeout(obj.say,0); // lucy，this 指向 window 对象</span><br></pre></td></tr></table></figure><p>从上面可以看到，正常情况say方法输出martin</p><p>但是我们把say放在setTimeout方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候this指向window，所以输出lucy</p><p>我们实际需要的是this指向obj对象，这时候就需要该改变this指向了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(obj.say.bind(obj),0); //martin，this指向obj对象</span><br></pre></td></tr></table></figure><p>#二、区别<br>下面再来看看apply、call、bind的使用</p><p>#apply<br>apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入</p><p>改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(...args)&#123;</span><br><span class="line">    console.log(this,args);</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    myname:&quot;张三&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.apply(obj,[1,2]); // this会变成传入的obj，传入的参数必须是一个数组；</span><br><span class="line">fn(1,2) // this指向window</span><br></pre></td></tr></table></figure><p>当第一个参数为null、undefined的时候，默认指向window(在浏览器中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.apply(null,[1,2]); // this指向window</span><br><span class="line">fn.apply(undefined,[1,2]); // this指向window</span><br></pre></td></tr></table></figure><p>#call<br>call方法的第一个参数也是this的指向，后面传入的是一个参数列表</p><p>跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn(...args)&#123;</span><br><span class="line">    console.log(this,args);</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    myname:&quot;张三&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call(obj,1,2); // this会变成传入的obj，传入的参数必须是一个数组；</span><br><span class="line">fn(1,2) // this指向window</span><br></pre></td></tr></table></figure><p>同样的，当第一个参数为null、undefined的时候，默认指向window(在浏览器中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(null,[1,2]); // this指向window</span><br><span class="line">fn.call(undefined,[1,2]); // this指向window</span><br></pre></td></tr></table></figure><p>#bind<br>bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)</p><p>改变this指向后不会立即执行，而是返回一个永久改变this指向的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn(...args)&#123;</span><br><span class="line">    console.log(this,args);</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    myname:&quot;张三&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const bindFn = fn.bind(obj); // this 也会变成传入的obj ，bind不是立即执行需要执行一次</span><br><span class="line">bindFn(1,2) // this指向obj</span><br><span class="line">fn(1,2) // this指向window</span><br></pre></td></tr></table></figure><p>#小结<br>从上面可以看到，apply、call、bind三者的区别在于：</p><p>三者都可以改变函数的this对象指向<br>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window<br>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入<br>bind是返回绑定this之后的函数，apply、call 则是立即执行<br>#三、实现<br>实现bind的步骤，我们可以分解成为三部分：</p><p>修改this指向<br>动态传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 方式一：只在bind中传递函数参数</span><br><span class="line">fn.bind(obj,1,2)()</span><br><span class="line"></span><br><span class="line">// 方式二：在bind中传递函数参数，也在返回函数中传递参数</span><br><span class="line">fn.bind(obj,1)(2)</span><br></pre></td></tr></table></figure><p>兼容new关键字<br>整体实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">    // 判断调用对象是否为函数</span><br><span class="line">    if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">        throw new TypeError(&quot;Error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取参数</span><br><span class="line">    const args = [...arguments].slice(1),</span><br><span class="line">          fn = this;</span><br><span class="line"></span><br><span class="line">    return function Fn() &#123;</span><br><span class="line"></span><br><span class="line">        // 根据调用方式，传入不同绑定值</span><br><span class="line">        return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>什么是防抖和节流？</title>
    <link href="http://example.com/2018/08/19/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F/"/>
    <id>http://example.com/2018/08/19/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F/</id>
    <published>2018-08-19T14:37:00.000Z</published>
    <updated>2022-10-12T13:22:43.988Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>本质上是优化高频率执行代码的一种手段</p><p>如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p><p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率</p><p>#定义<br>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效<br>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时<br>一个经典的比喻:</p><p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p><p>假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制</p><p>电梯第一个人进来后，15秒后准时运送一次，这是节流</p><p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖</p><p>#代码实现<br>#节流<br>完成节流可以使用时间戳与定时器的写法</p><p>使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throttled1(fn, delay = 500) &#123;</span><br><span class="line">    let oldtime = Date.now()</span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        let newtime = Date.now()</span><br><span class="line">        if (newtime - oldtime &gt;= delay) &#123;</span><br><span class="line">            fn.apply(null, args)</span><br><span class="line">            oldtime = Date.now()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function throttled2(fn, delay = 500) &#123;</span><br><span class="line">    let timer = null</span><br><span class="line">    return function (...args) &#123;</span><br><span class="line">        if (!timer) &#123;</span><br><span class="line">            timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                fn.apply(this, args)</span><br><span class="line">                timer = null</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function throttled(fn, delay) &#123;</span><br><span class="line">    let timer = null</span><br><span class="line">    let starttime = Date.now()</span><br><span class="line">    return function () &#123;</span><br><span class="line">        let curTime = Date.now() // 当前时间</span><br><span class="line">        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间</span><br><span class="line">        let context = this</span><br><span class="line">        let args = arguments</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        if (remaining &lt;= 0) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">            starttime = Date.now()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timer = setTimeout(fn, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#防抖<br>简单版本的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">    let timeout;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        let context = this; // 保存this指向</span><br><span class="line">        let args = arguments; // 拿到event对象</span><br><span class="line"></span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(function()&#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line"></span><br><span class="line">    let timeout;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        let context = this;</span><br><span class="line">        let args = arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout); // timeout 不为null</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发</span><br><span class="line">            timeout = setTimeout(function () &#123;</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) &#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timeout = setTimeout(function () &#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#二、区别<br>相同点：</p><p>都可以通过使用 setTimeout 实现<br>目的都是，降低回调执行频率。节省计算资源<br>不同点：</p><p>函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能<br>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次<br>例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次</p><p>如下图所示：<br><img src="https://static.vue-js.com/a2c81b50-8787-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>三、应用场景<br>防抖在连续的事件，只需触发一次回调的场景有：</p><p>搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>手机号、邮箱验证输入检测<br>窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。<br>节流在间隔一段时间执行一次回调的场景有：</p><p>滚动加载，加载更多或滚到底部监听<br>搜索框，搜索联想功能</p>]]></content>
    
    
    <summary type="html">本质上是优化高频率执行代码的一种手段</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>说说你对函数式编程的理解？</title>
    <link href="http://example.com/2018/08/16/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/"/>
    <id>http://example.com/2018/08/16/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/</id>
    <published>2018-08-16T13:32:00.000Z</published>
    <updated>2022-10-12T13:23:55.050Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>函数式编程是一种”编程范式”（programming paradigm），一种编写程序的方法论</p><p>主要的编程范式有三种：命令式编程，声明式编程和函数式编程</p><p>相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程</p><p>举个例子，将数组每个元素进行平方操作，命令式编程与函数式编程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 命令式编程</span><br><span class="line">var array = [0, 1, 2, 3]</span><br><span class="line">for(let i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    array[i] = Math.pow(array[i], 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数式方式</span><br><span class="line">[0, 1, 2, 3].map(num =&gt; Math.pow(num, 2))</span><br></pre></td></tr></table></figure><p>简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果</p><p>即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值<br><img src="https://static.vue-js.com/f9f83900-8534-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>可以看到，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合</p><p>#二、概念<br>#纯函数<br>函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数，也就是纯函数</p><p>纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变<br><img src="https://static.vue-js.com/04f50720-8535-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>举一个简单的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let double = value=&gt;value*2;</span><br></pre></td></tr></table></figure><p>特性：</p><p>函数内部传入指定的值，就会返回确定唯一的值<br>不会造成超出作用域的变化，例如修改全局变量或引用传递的参数<br>优势：</p><p>使用纯函数，我们可以产生可测试的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(&#x27;double(2) 等于 4&#x27;, () =&gt; &#123;</span><br><span class="line">  expect(double(2)).toBe(4);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不依赖外部环境计算，不会产生副作用，提高函数的复用性</p><p>可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读</p><p>可以组装成复杂任务的可能性。符合模块化概念及单一职责原则</p><p>#高阶函数<br>在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数</p><p>编程工作也就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据，如下图所示<br><img src="https://static.vue-js.com/104af1c0-8535-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>在这里，就是高阶函数的作用。高级函数，就是以函数作为输入或者输出的函数被称为高阶函数</p><p>通过高阶函数抽象过程，注重结果，如下面例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const forEach = function(arr,fn)&#123;</span><br><span class="line">    for(let i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        fn(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [1,2,3];</span><br><span class="line">forEach(arr,(item)=&gt;&#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面通过高阶函数 forEach来抽象循环如何做的逻辑，直接关注做了什么</p><p>高阶函数存在缓存的特性，主要是利用闭包作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const once = (fn)=&gt;&#123;</span><br><span class="line">    let done = false;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(!done)&#123;</span><br><span class="line">            fn.apply(this,fn);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            console.log(&quot;该函数已经执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        done = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>柯里化<br>柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程</p><p>一个二元函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fn = (x,y)=&gt;x+y;</span><br></pre></td></tr></table></figure><p>转化成柯里化函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const curry = function(fn)&#123;</span><br><span class="line">    return function(x)&#123;</span><br><span class="line">        return function(y)&#123;</span><br><span class="line">            return fn(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myfn = curry(fn);</span><br><span class="line">console.log( myfn(1)(2) );</span><br></pre></td></tr></table></figure><p>上面的curry函数只能处理二元情况，下面再来实现一个实现多参数的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 多参数柯里化；</span><br><span class="line">const curry = function(fn)&#123;</span><br><span class="line">    return function curriedFn(...args)&#123;</span><br><span class="line">        if(args.length&lt;fn.length)&#123;</span><br><span class="line">            return function()&#123;</span><br><span class="line">                return curriedFn(...args.concat([...arguments]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const fn = (x,y,z,a)=&gt;x+y+z+a;</span><br><span class="line">const myfn = curry(fn);</span><br><span class="line">console.log(myfn(1)(2)(3)(1));</span><br></pre></td></tr></table></figure><p>关于柯里化函数的意义如下：</p><p>让纯函数更纯，每次接受一个参数，松散解耦<br>惰性执行<br>#组合与管道<br>组合函数，目的是将多个函数组合成一个函数</p><p>举个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function afn(a)&#123;</span><br><span class="line">    return a*2;</span><br><span class="line">&#125;</span><br><span class="line">function bfn(b)&#123;</span><br><span class="line">    return b*3;</span><br><span class="line">&#125;</span><br><span class="line">const compose = (a,b)=&gt;c=&gt;a(b(c));</span><br><span class="line">let myfn =  compose(afn,bfn);</span><br><span class="line">console.log( myfn(2));</span><br></pre></td></tr></table></figure><p>可以看到compose实现一个简单的功能：形成了一个新的函数，而这个函数就是一条从 bfn -&gt; afn 的流水线</p><p>下面再来看看如何实现一个多函数组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const compose = (...fns)=&gt;val=&gt;fns.reverse().reduce((acc,fn)=&gt;fn(acc),val);</span><br></pre></td></tr></table></figure><p>compose执行是从右到左的。而管道函数，执行顺序是从左到右执行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const pipe = (...fns)=&gt;val=&gt;fns.reduce((acc,fn)=&gt;fn(acc),val);</span><br></pre></td></tr></table></figure><p>组合函数与管道函数的意义在于：可以把很多小函数组合起来完成更复杂的逻辑</p><p>#三、优缺点<br>#优点<br>更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</p><p>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响</p><p>更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性</p><p>隐性好处。减少代码量，提高维护性</p><p>#缺点：<br>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销</p><p>资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式</p><p>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</p><p>#参考文献</p>]]></content>
    
    
    <summary type="html">函数式编程是一种&quot;编程范式&quot;（programming paradigm），一种编写程序的方法论</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript本地存储的方式有哪些？</title>
    <link href="http://example.com/2018/08/13/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>http://example.com/2018/08/13/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2018-08-13T14:25:00.000Z</published>
    <updated>2022-10-12T10:57:56.909Z</updated>
    
    <content type="html"><![CDATA[<p>一、方式<br>javaScript本地缓存的方法我们主要讲述以下四种：</p><p>cookie<br>sessionStorage<br>localStorage<br>indexedDB<br>#cookie<br>Cookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP无状态导致的问题</p><p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie有效期、安全性、使用范围的可选属性组成</p><p>但是cookie在每次请求中都会被发送，如果不使用 HTTPS并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 cookie保持登录态的网站上，如果 cookie被窃取，他人很容易利用你的 cookie来假扮成你登录网站</p><p>关于cookie常用的属性如下：</p><p>Expires 用于设置 Cookie 的过期时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires=Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure><p>Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比Expires高）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max-Age=604800</span><br></pre></td></tr></table></figure><p>Domain指定了 Cookie 可以送达的主机名<br>Path指定了一个 URL路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Path=/docs   # /docs/Web/ 下的资源会带 Cookie 首部</span><br></pre></td></tr></table></figure><p>标记为 Secure的 Cookie只应通过被HTTPS协议加密过的请求发送给服务端<br>通过上述，我们可以看到cookie又开始的作用并不是为了缓存而设计出来，只是借用了cookie的特性实现缓存</p><p>关于cookie的使用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &#x27;名字=值&#x27;;</span><br></pre></td></tr></table></figure><p>关于cookie的修改，首先要确定domain和path属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的cookie</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie:name=aa; domain=aa.net; path=/  # 服务端设置</span><br><span class="line">document.cookie =name=bb; domain=aa.net; path=/  # 客户端设置</span><br></pre></td></tr></table></figure><p>最后cookie的删除，最常用的方法就是给cookie设置一个过期的事件，这样cookie过期后会被浏览器删除</p><p>#localStorage<br>HTML5新方法，IE8及以上浏览器都兼容</p><p>#特点<br>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的<br>存储的信息在同一域中是共享的<br>当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。<br>大小：5M（跟浏览器厂商有关系）<br>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡<br>受同源策略的限制<br>下面再看看关于localStorage的使用</p><p>设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;username&#x27;,&#x27;cfangxu&#x27;);</span><br></pre></td></tr></table></figure><p>获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(&#x27;username&#x27;)</span><br></pre></td></tr></table></figure><p>获取键名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.key(0) //获取第一个键名</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(&#x27;username&#x27;)</span><br></pre></td></tr></table></figure><p>一次性清除所有存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure><p>localStorage 也不是完美的，它有两个缺点：</p><p>无法像Cookie一样设置过期时间<br>只能存入字符串，无法直接存对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;key&#x27;, &#123;name: &#x27;value&#x27;&#125;);</span><br><span class="line">console.log(localStorage.getItem(&#x27;key&#x27;)); // &#x27;[object, Object]&#x27;</span><br></pre></td></tr></table></figure><p>#sessionStorage<br>sessionStorage和 localStorage使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据</p><p>#扩展的前端存储方式<br>indexedDB是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索</p><p>虽然 Web Storage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案</p><p>#优点：<br>储存量理论上没有上限<br>所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时<br>原生支持储存JS的对象<br>是个正经的数据库，意味着数据库能干的事它都能干<br>#缺点：<br>操作非常繁琐<br>本身有一定门槛<br>关于indexedDB的使用基本使用步骤如下：</p><p>打开数据库并且开始一个事务</p><p>创建一个 object store</p><p>构建一个请求来执行一些数据库操作，像增加或提取数据等。</p><p>通过监听正确类型的 DOM 事件以等待操作完成。</p><p>在操作结果上进行一些操作（可以在 request对象中找到）</p><p>关于使用indexdb的使用会比较繁琐，大家可以通过使用Godb.js库进行缓存，最大化的降低操作难度</p><p>#二、区别<br>关于cookie、sessionStorage、localStorage三者的区别主要如下：</p><p>存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p><p>有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p><p>数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</p><p>#三、应用场景<br>在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：</p><p>标记用户与跟踪用户行为的情况，推荐使用cookie<br>适合长期保存在本地的数据（令牌），推荐使用localStorage<br>敏感账号一次性登录，推荐使用sessionStorage<br>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB</p>]]></content>
    
    
    <summary type="html">javaScript本地缓存的方法我们主要讲述以下四种：</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>说说你对BOM的理解</title>
    <link href="http://example.com/2018/08/11/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9BOM%E7%9A%84%E7%90%86%E8%A7%A3/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9BOM%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2018/08/11/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9BOM%E7%9A%84%E7%90%86%E8%A7%A3/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9BOM%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2018-08-11T12:19:00.000Z</published>
    <updated>2022-10-07T07:33:48.503Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象</p><p>其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率</p><p>浏览器的全部内容可以看成DOM，整个浏览器可以看成BOM。区别如下：<br><img src="https://static.vue-js.com/482f33e0-8089-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>二、window<br>Bom的核心对象是window，它表示浏览器的一个实例</p><p>在浏览器中，window对象有双重角色，即是浏览器窗口的一个接口，又是全局对象</p><p>因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;js每日一题&#x27;;</span><br><span class="line">function lookName()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(window.name);  //js每日一题</span><br><span class="line">lookName();                //js每日一题</span><br><span class="line">window.lookName();         //js每日一题</span><br></pre></td></tr></table></figure><p>关于窗口控制方法如下：</p><p>moveBy(x,y)：从当前位置水平移动窗体x个像素，垂直移动窗体y个像素，x为负数，将向左移动窗体，y为负数，将向上移动窗体<br>moveTo(x,y)：移动窗体左上角到相对于屏幕左上角的(x,y)点<br>resizeBy(w,h)：相对窗体当前的大小，宽度调整w个像素，高度调整h个像素。如果参数为负值，将缩小窗体，反之扩大窗体<br>resizeTo(w,h)：把窗体宽度调整为w个像素，高度调整为h个像素<br>scrollTo(x,y)：如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置<br>scrollBy(x,y)： 如果有滚动条，将横向滚动条向左移动x个像素，将纵向滚动条向下移动y个像素<br>window.open() 既可以导航到一个特定的url，也可以打开一个新的浏览器窗口</p><p>如果 window.open() 传递了第二个参数，且该参数是已有窗口或者框架的名称，那么就会在目标窗口加载第一个参数指定的URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.open(&#x27;htttp://www.vue3js.cn&#x27;,&#x27;topFrame&#x27;)</span><br><span class="line">==&gt; &lt; a href=&quot; &quot; target=&quot;topFrame&quot;&gt;&lt;/ a&gt;</span><br></pre></td></tr></table></figure><p>window.open() 会返回新窗口的引用，也就是新窗口的 window 对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myWin = window.open(&#x27;http://www.vue3js.cn&#x27;,&#x27;myWin&#x27;)</span><br></pre></td></tr></table></figure><p>window.close() 仅用于通过 window.open() 打开的窗口</p><p>新创建的 window 对象有一个 opener 属性，该属性指向打开他的原始窗口对象</p><p>#三、location<br>url地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents</span><br></pre></td></tr></table></figure><p>location属性描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">属性名例子说明</span><br><span class="line">hash&quot;#contents&quot;utl中#后面的字符，没有则返回空串</span><br><span class="line">hostwww.wrox.com:80服务器名称和端口号</span><br><span class="line">hostnamewww.wrox.com域名，不带端口号</span><br><span class="line">hrefhttp://www.wrox.com:80/WileyCDA/?q=javascript#contents完整url</span><br><span class="line">pathname&quot;/WileyCDA/&quot;服务器下面的文件路径</span><br><span class="line">port80url的端口号，没有则为空</span><br><span class="line">protocolhttp:使用的协议</span><br><span class="line">search?q=javascripturl的查询字符串，通常为？后面的内容</span><br></pre></td></tr></table></figure><p>除了 hash之外，只要修改location的一个属性，就会导致页面重新加载新URL</p><p>location.reload()，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载</p><p>如果要强制从服务器中重新加载，传递一个参数true即可</p><p>#四、navigator<br>navigator 对象主要用来获取浏览器的属性，区分浏览器类型。属性较多，且兼容性比较复杂</p><p>下表列出了navigator对象接口定义的属性和方法：<br><img src="https://static.vue-js.com/6797ab40-8089-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>五、screen<br>保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度<br><img src="https://static.vue-js.com/7d6b21e0-8089-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>六、history<br>history对象主要用来操作浏览器URL的历史记录，可以通过参数向前，向后，或者向指定URL跳转</p><p>常用的属性如下：</p><p>history.go()<br>接收一个整数数字或者字符串参数：向最近的一个记录中包含指定字符串的页面跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.go(&#x27;maixaofei.com&#x27;)</span><br></pre></td></tr></table></figure><p>当参数为整数数字的时候，正数表示向前跳转指定的页面，负数为向后跳转指定的页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.go(3) //向前跳转三个记录</span><br><span class="line">history.go(-1) //向后跳转一个记录</span><br></pre></td></tr></table></figure><p>history.forward()：向前跳转一个页面<br>history.back()：向后跳转一个页面<br>history.length：获取历史记录数</p>]]></content>
    
    
    <summary type="html">BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DOM常见的操作</title>
    <link href="http://example.com/2018/07/16/DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2018/07/16/DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2018-07-16T13:23:00.000Z</published>
    <updated>2022-10-07T07:25:30.490Z</updated>
    
    <content type="html"><![CDATA[<p>一、DOM<br>文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口</p><p>它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容</p><p>任何 HTML或XML文档都可以用 DOM表示为一个由节点构成的层级结构</p><p>节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系，如下所示：</p><html>    <head>        <title>Page</title>    </head>    <body>        <p>Hello World!</p>    </body></html>DOM像原子包含着亚原子微粒那样，也有很多类型的DOM节点包含着其他类型的节点。接下来我们先看看其中的三种：<div>    <p title="title">        content    </p></div>上述结构中，div、p就是元素节点，content就是文本节点，title就是属性节点<p>二、操作<br>日常前端开发，我们都离不开DOM操作</p><p>在以前，我们使用Jquery，zepto等库来操作DOM，之后在vue，Angular，React等框架出现后，我们通过操作数据来控制DOM（绝大多数时候），越来越少的去直接操作DOM</p><p>但这并不代表原生操作不重要。相反，DOM操作才能有助于我们理解框架深层的内容</p><p>下面就来分析DOM常见的操作，主要分为：</p><p>创建节点<br>查询节点<br>更新节点<br>添加节点<br>删除节点<br>创建节点<br>createElement<br>创建新元素，接受一个参数，即要创建元素的标签名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const divEl = document.createElement(&quot;div&quot;);</span><br></pre></td></tr></table></figure><p>createTextNode<br>创建一个文本节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const textEl = document.createTextNode(&quot;content&quot;);</span><br></pre></td></tr></table></figure><p>createDocumentFragment<br>用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到DOM中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fragment = document.createDocumentFragment();</span><br></pre></td></tr></table></figure><p>当请求把一个DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment自身，而是它的所有子孙节点</p><p>createAttribute<br>创建属性节点，可以是自定义属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const dataAttribute = document.createAttribute(&#x27;custom&#x27;);</span><br><span class="line">consle.log(dataAttribute);</span><br></pre></td></tr></table></figure><p>获取节点<br>querySelector<br>传入任何有效的css 选择器，即可选中单个 DOM元素（首个）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&#x27;.element&#x27;)</span><br><span class="line">document.querySelector(&#x27;element&#x27;)</span><br><span class="line">document.querySelector(&#x27;div&#x27;)</span><br><span class="line">document.querySelector(&#x27;[name=&quot;username&quot;]&#x27;)</span><br><span class="line">document.querySelector(&#x27;div + p &gt; span&#x27;)</span><br></pre></td></tr></table></figure><p>如果页面上没有指定的元素时，返回 null</p><p>querySelectorAll<br>返回一个包含节点子树内所有与之相匹配的Element节点列表，如果没有相匹配的，则返回一个空节点列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const notLive = document.querySelectorAll(&quot;p&quot;);</span><br></pre></td></tr></table></figure><p>需要注意的是，该方法返回的是一个 NodeList的静态实例，它是一个静态的“快照”，而非“实时”的查询</p><p>关于获取DOM元素的方法还有如下，就不一一述说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#x27;id属性值&#x27;);返回拥有指定id的对象的引用</span><br><span class="line">document.getElementsByClassName(&#x27;class属性值&#x27;);返回拥有指定class的对象集合</span><br><span class="line">document.getElementsByTagName(&#x27;标签名&#x27;);返回拥有指定标签名的对象集合</span><br><span class="line">document.getElementsByName(&#x27;name属性值&#x27;); 返回拥有指定名称的对象结合</span><br><span class="line">document/element.querySelector(&#x27;CSS选择器&#x27;);  仅返回第一个匹配的元素</span><br><span class="line">document/element.querySelectorAll(&#x27;CSS选择器&#x27;);   返回所有匹配的元素</span><br><span class="line">document.documentElement;  获取页面中的HTML标签</span><br><span class="line">document.body; 获取页面中的BODY标签</span><br><span class="line">document.all[&#x27;&#x27;];  获取页面中的所有元素节点的对象集合型</span><br></pre></td></tr></table></figure><p>除此之外，每个DOM元素还有parentNode、childNodes、firstChild、lastChild、nextSibling、previousSibling属性，关系图如下图所示<br><img src="https://static.vue-js.com/c100f450-7fdc-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>更新节点<br>innerHTML<br>不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 获取&lt;p id=&quot;p&quot;&gt;...&lt;/p &gt;</span><br><span class="line">var p = document.getElementById(&#x27;p&#x27;);</span><br><span class="line">// 设置文本为abc:</span><br><span class="line">p.innerHTML = &#x27;ABC&#x27;; // &lt;p id=&quot;p&quot;&gt;ABC&lt;/p &gt;</span><br><span class="line">// 设置HTML:</span><br><span class="line">p.innerHTML = &#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;;</span><br><span class="line">// &lt;p&gt;...&lt;/p &gt;的内部结构已修改</span><br></pre></td></tr></table></figure><p>innerText、textContent<br>自动对字符串进行HTML编码，保证无法设置任何HTML标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p &gt;</span><br><span class="line">var p = document.getElementById(&#x27;p-id&#x27;);</span><br><span class="line">// 设置文本:</span><br><span class="line">p.innerText = &#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;;</span><br><span class="line">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span><br><span class="line">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p &gt;</span><br></pre></td></tr></table></figure><p>两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本</p><p>style<br>DOM节点的style属性对应所有的CSS，可以直接获取或设置。遇到-需要转化为驼峰命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p &gt;</span><br><span class="line">const p = document.getElementById(&#x27;p-id&#x27;);</span><br><span class="line">// 设置CSS:</span><br><span class="line">p.style.color = &#x27;ff0000&#x27;;</span><br><span class="line">p.style.fontSize = &#x27;20px&#x27;; // 驼峰命名</span><br><span class="line">p.style.paddingTop = &#x27;2em&#x27;;</span><br></pre></td></tr></table></figure><p>添加节点<br>innerHTML<br>如果这个DOM节点是空的，例如，<div></div>，那么，直接使用innerHTML = ‘<span>child</span>‘就可以修改DOM节点的内容，相当于添加了新的DOM节点</p><p>如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点</p><p>appendChild<br>把一个子节点添加到父节点的最后一个子节点</p><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p &gt;</span><br><span class="line">&lt;div id=&quot;list&quot;&gt;</span><br><span class="line">    &lt;p id=&quot;java&quot;&gt;Java&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;python&quot;&gt;Python&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p &gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>添加一个p元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const js = document.getElementById(&#x27;js&#x27;)</span><br><span class="line">js.innerHTML = &quot;JavaScript&quot;</span><br><span class="line">const list = document.getElementById(&#x27;list&#x27;);</span><br><span class="line">list.appendChild(js);</span><br></pre></td></tr></table></figure><p>现在HTML结构变成了下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML结构 --&gt;</span><br><span class="line">&lt;div id=&quot;list&quot;&gt;</span><br><span class="line">    &lt;p id=&quot;java&quot;&gt;Java&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;python&quot;&gt;Python&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p &gt;</span><br><span class="line">    &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p &gt;  &lt;!-- 添加元素 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上述代码中，我们是获取DOM元素后再进行添加操作，这个js节点是已经存在当前文档树中，因此这个节点首先会从原先的位置删除，再插入到新的位置</p><p>如果动态添加新的节点，则先创建一个新的节点，然后插入到指定的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const list = document.getElementById(&#x27;list&#x27;),</span><br><span class="line">const haskell = document.createElement(&#x27;p&#x27;);</span><br><span class="line">haskell.id = &#x27;haskell&#x27;;</span><br><span class="line">haskell.innerText = &#x27;Haskell&#x27;;</span><br><span class="line">list.appendChild(haskell);</span><br></pre></td></tr></table></figure><p>insertBefore<br>把子节点插入到指定的位置，使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentElement.insertBefore(newElement, referenceElement)</span><br></pre></td></tr></table></figure><p>子节点会插入到referenceElement之前</p><p>setAttribute<br>在指定元素中添加一个属性节点，如果元素中已有该属性改变属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const div = document.getElementById(&#x27;id&#x27;)</span><br><span class="line">div.setAttribute(&#x27;class&#x27;, &#x27;white&#x27;);//第一个参数属性名，第二个参数属性值。</span><br></pre></td></tr></table></figure><p>删除节点<br>删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 拿到待删除节点:</span><br><span class="line">const self = document.getElementById(&#x27;to-be-removed&#x27;);</span><br><span class="line">// 拿到父节点:</span><br><span class="line">const parent = self.parentElement;</span><br><span class="line">// 删除:</span><br><span class="line">const removed = parent.removeChild(self);</span><br><span class="line">removed === self; // true</span><br></pre></td></tr></table></figure><p>删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置</p>]]></content>
    
    
    <summary type="html">DOM是文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件循环怎么理解?</title>
    <link href="http://example.com/2018/07/02/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2018/07/02/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3/</id>
    <published>2018-07-02T02:13:00.000Z</published>
    <updated>2022-10-07T07:15:34.555Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>首先，JavaScript是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环</p><p>在JavaScript中，所有的任务都可以分为</p><p>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</p><p>异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等</p><p>同步任务与异步任务的运行流程图如下：<br><img src="https://static.vue-js.com/61efbc20-7cb8-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环</p><p>二、宏任务与微任务<br>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;new Promise&#x27;)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;then&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure><p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p><p>console.log(1)，同步任务，主线程中执行<br>setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2)回调推入 Event Queue 中<br>new Promise ，同步任务，主线程直接执行<br>.then ，异步任务，放到 Event Table<br>console.log(3)，同步任务，主线程执行<br>所以按照分析，它的结果应该是 1 =&gt; ‘new Promise’ =&gt; 3 =&gt; 2 =&gt; ‘then’</p><p>但是实际结果是：1=&gt;’new Promise’=&gt; 3 =&gt; ‘then’ =&gt; 2</p><p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p><p>例子中 setTimeout回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏相反</p><p>原因在于异步任务还可以细分为微任务与宏任务</p><p>微任务<br>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p><p>常见的微任务有：</p><p>Promise.then</p><p>MutaionObserver</p><p>Object.observe（已废弃；Proxy 对象替代）</p><p>process.nextTick（Node.js）</p><p>宏任务<br>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p><p>常见的宏任务有：</p><p>script (可以理解为外层同步代码)<br>setTimeout/setInterval<br>UI rendering/UI事件<br>postMessage、MessageChannel<br>setImmediate、I/O（Node.js）<br>这时候，事件循环，宏任务，微任务的关系如图所示<br><img src="https://static.vue-js.com/6e80e5e0-7cb8-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>按照这个流程，它的执行机制是：</p><p>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中<br>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完<br>回到上面的题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 0)</span><br><span class="line">new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;new Promise&#x27;)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;then&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure><p>流程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 遇到 console.log(1) ，直接打印 1</span><br><span class="line">// 遇到定时器，属于新的宏任务，留着后面执行</span><br><span class="line">// 遇到 new Promise，这个是直接执行的，打印 &#x27;new Promise&#x27;</span><br><span class="line">// .then 属于微任务，放入微任务队列，后面再执行</span><br><span class="line">// 遇到 console.log(3) 直接打印 3</span><br><span class="line">// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 &#x27;then&#x27;</span><br><span class="line">// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2</span><br></pre></td></tr></table></figure><p>三、async与await<br>async 是异步的意思，await则可以理解为 async wait。所以可以理解async就是用来声明一个异步方法，而 await是用来等待异步方法执行</p><p>async<br>async函数返回一个promise对象，下面两种方法是等效的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">    return Promise.resolve(&#x27;TEST&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// asyncF is equivalent to f!</span><br><span class="line">async function asyncF() &#123;</span><br><span class="line">    return &#x27;TEST&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await<br>正常情况下，await命令后面是一个 Promise对象，返回该对象的结果。如果不是 Promise对象，就直接返回对应的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function f()&#123;</span><br><span class="line">    // 等同于</span><br><span class="line">    // return 123</span><br><span class="line">    return await 123</span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; console.log(v)) // 123</span><br></pre></td></tr></table></figure><p>不管await后面跟着的是什么，await都会阻塞后面的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function fn1 ()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    await fn2()</span><br><span class="line">    console.log(2) // 阻塞</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn2 ()&#123;</span><br><span class="line">    console.log(&#x27;fn2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure><p>上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码</p><p>所以上述输出结果为：1，fn2，3，2</p><p>四、流程分析<br>通过对上面的了解，我们对JavaScript对各种场景的执行顺序有了大致的了解</p><p>这里直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&#x27;async1 start&#x27;)</span><br><span class="line">    await async2()</span><br><span class="line">    console.log(&#x27;async1 end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&#x27;async2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;script start&#x27;)</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&#x27;settimeout&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">async1()</span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&#x27;promise2&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br></pre></td></tr></table></figure><p>分析过程：</p><p>执行整段代码，遇到 console.log(‘script start’) 直接打印结果，输出 script start<br>遇到定时器了，它是宏任务，先放着不执行<br>遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到await怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码<br>跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行<br>最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await下面的代码，打印 async1 end<br>继续执行下一个微任务，即执行 then 的回调，打印 promise2<br>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout<br>所以最后的结果是：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout</p>]]></content>
    
    
    <summary type="html">事件循环</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>diff算法实现</title>
    <link href="http://example.com/2018/06/20/diff/"/>
    <id>http://example.com/2018/06/20/diff/</id>
    <published>2018-06-20T01:00:00.000Z</published>
    <updated>2022-10-05T10:56:15.948Z</updated>
    
    <content type="html"><![CDATA[<p>diff算法实现</p><ol><li>为什么要用Diff算法</li></ol><p>由于在浏览器中操作DOM是很昂贵的，频繁的操作DOM，会产生一定的性能问题，这就是虚拟DOM的产生原因。虚拟DOM本质上是JavaScript对象，是对真实DOM的抽象状态变更时，记录新树与旧树的差异，最后把差异更新到真正的DOM中。</p><p>即使使用了Virtual DOM来进行真实DOM的渲染，在页面更新的时候，也不能全量地将整颗Virtual DOM进行渲染，而是去渲染改变的部分，这时候就需要一个计算Virtual DOM树改变部分的算法了，这个算法就是Diff算法。</p><p>diff算法的作用：用来修改DOM的一小段，不会引起dom树的重绘</p><ol start="2"><li>传统的Diff算法</li></ol><p>传统的Diff算法通过循环递归对节点进行比较，然后判断每个节点的状态以及要做的操作（add，remove，change），最后 根据Virtual DOM进行DOM的渲染。</p><p>传统Diff算法的复杂度为O(n^3)，这个复杂度相对来说还是较高的。后来React开发者提供了一种复杂度仅为O(n) 的Diff算法。</p><ol start="3"><li>更高效的Diff算法</li></ol><p>React的开发者结合Web界面的特点做出了两个大胆的假设，使得Diff算法复杂度直接从O(n^3)降低到O(n)，假设如下：</p><p>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</p><p>基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)</p><p><strong>同层比较</strong><br>新的Diff算法是逐层进行比较，只比较同一层次的节点，不会跨层次比较，大大降低了复杂度</p><p><strong>不同类型节点的比较</strong><br>如果发现新旧两个节点类型不同时，Diff算法会直接删除旧的节点及其子节点并插入新的节点，这是由于前面提出的不同组件产生的DOM结构一般是不同的，所以可以不用浪费时间去比较。注意的是，删除节点意味着彻底销毁该节点，并不会将该节点去与后面的节点相比较。</p><p><strong>相同类型节点的比较</strong><br>若是两个节点类型相同时，Diff算法会重新设置该节点的属性，从而实现节点的更新。</p><p><strong>列表节点的比较</strong><br>列表节点的操作一般包括添加、删除和排序，列表节点需要我们给它一个key才能进行高效的比较。</p><p>4.Vue Diff算法的实现</p><p>了解了Diff算法的大体思路后，我们回过头来看下Vue中的Diff算法是如何实现的。</p><p>Vue的Diff算法与上面的思路大体相似，只比较同级的节点，若找不到与新节点类型相同的节点，则插入一个新节点，若有相同类型的节点则进行节点属性的更新，最后删除新节点列表中不包含的旧节点。具体的实现在vue源码的src/core/vdom/patch.js中的updateChildren方法中，由于代码较长，下面简单说一下整个的比较流程。</p><p>如上图，有一组新旧节点数组before：[A, B, C, D]、after：[E, C, F, G]，我们设置了四个哨兵节点，oldStartIdx、newStartIdx、oldEndIdx、newEndIdx分别指向新旧节点数组的起始下标和开始下标，值为0,0,3,3；oldStartVnode，newStartVnode，oldEndVnode，newEndVnode则分别指向了before和after节点列表中对应哨兵节点下标的值，值为before[oldStartVnode],after[newStartIdx],before[oldEndIdx],after[newEndIdx]。</p><p><strong>Diff</strong><br>当哨兵满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx的条件的时候，我们会循环进行一系列节点之间的比较。</p><p><strong>优先判断</strong><br>我们首先对上面声明的各个节点进行一些优先级较高的判断。</p><p>判断1：oldStartVnode是否为空，若为true则oldStartIdx向后移动，继续下一个节点的判断。判断代码如下：</p><p>判断2：oldEndVnode是否为空，若为true则oldEndIdx向前移动。判断代码如下：</p><p>判断3：使用 sameVnode判断before和after未判断的头节点是否为相同节点，若为true，则按照上面思路说的，对相同类型节点进行节点的属性的更新并修改哨兵位置。</p><p>判断4：使用上一步相同的方法对oldEndVnode和newEndVnode进行判断。并执行相同的更新操作。</p><p>判断5：使用sameVNode判断旧列表的头节点和新列表的尾节点进行判断，<br>sameVnode(oldStartVnode, newEndVnode)，若为true，更新相同节点，若该节点可以移动在真实DOM中将oldStartVnode，放到真实节点列表的最后。</p><p>判断6：使用sameVnode比较旧列表的尾节点和新列表的头节点，若为true，和上面一样，更新相同节点，将oldEndVnode放到真实节点列表的最开始。</p><p>通过这一系列的优先判断条件，一方面对于一些不需要做移动的DOM可以得到快速处理，另一方面使待处理节点变少，缩小了后续操作的处理范围，可以更快地完成同级节点的对比。</p><p>若节点不满足上面的所有判断，则会进入到最后一个条件分支，判断7：</p><p><strong>循环结束</strong><br>最后当oldStartIdx &gt; oldEndIdx || newStartIdx &gt; newEndIdx，也就是新或旧节点数组有一个被查找完之后则退出判断循环。当循环结束时，旧节点数组中剩下的节点即为要删除的节点，新节点数组中剩下的即为要新增的节点。只需要进行简单的新增和删除操作即可，代码如下：</p><p>经历过了这么多的判断之后，就完成了同级节点之间的Diff比较。</p><p><strong>就地复用</strong><br>在Diff中会使用到一种就地复用的策略。就地复用是指Vue会尽可能复用之前的DOM，尽可能不发生DOM的移动。</p><p>Vue判断新旧节点是否为相同节点（也就是上面的sameVnode方法），这个相同节点的意思并不是两个完全相同的节点，实际上它仅判断是否为同类节点（同类节点为类型相同且节点数据一致，如前后两个span，span标签上的属性没有改变，但是里面的内容变了，这样就算作同类节点），如果是同类节点，那么Vue会直接复用旧DOM节点，只要更新节点中的内容即可。这样可以大大减少列表中节点的移动操作。</p><p><strong>总结</strong><br>Vue中的Diff算法采用了React相似的思路，都是同层节点进行比较，在比较的过程中，使用了一些优先判断和就地复用策略，提高了Diff算法的效率。</p><p><strong>那么在面试工程中，可以怎么组织语言呢？</strong></p><p>答：diff算法的作用：用来修改DOM的一小段，不会引起dom树的重绘<br>diff算法的实现原理：diff算法将虚拟DOM的某个节点数据改变后生成新的的node节点与旧节点进行比较，并替换为新的节点，具体过程就是调用Patch方法，比较新旧节点，一边比较一边给真实DOM打补丁进行替换<br>简单来说，diff算法有以下过程<br>同级比较，再比较子节点<br>如果节点类型不同，直接干掉前面的节点，再创建并插入新节点，不会再比较这个节点以后的子节点。<br>（先判断一方有子节点一方 没有子节点的情况(如果新的children没有子节点，将旧的节点移除)）<br>比较都有子节点的情况(核心diff)<br>递归比较子节点<br>正常diff两个树的时间复杂度是O(n^3)， 但实际情况下我们很少会进行跨层级的移动DOM，所以vue将diff进行了优化，从O(n^3)–&gt;O(n)，只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较。<br>Vue2的核心diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助Key值找到可复用的节点，再进行相关操作。<br>新旧children中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的，需要在新旧children的节点中保存映射关系，以便能够在旧children的节点中找到可复用的节点。key也就是children中节点的唯一标识。<br>相比React的diff算法，同样情况下可以减少移动节点的次数，减少不必要的性能损耗，更加的优雅。<br>Vue3.x借鉴了ivi算法和inferno算法<br>在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升(实际的实现可以结合Vue3.x的源码看)<br>该算法中还运用了动态规划的思想求解最长递归子序列</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;diff算法实现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么要用Diff算法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于在浏览器中操作DOM是很昂贵的，频繁的操作DOM，会产生一定的性能问题，这就是虚拟DOM的产生原因。虚拟DOM本质上是JavaScript对象，是对真实DOM的抽象状态变更时</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>ES6中数组新增了哪些扩展？</title>
    <link href="http://example.com/2018/06/19/ES6%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%EF%BC%9F/ES6%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%EF%BC%9F/"/>
    <id>http://example.com/2018/06/19/ES6%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%EF%BC%9F/ES6%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%EF%BC%9F/</id>
    <published>2018-06-19T14:03:00.000Z</published>
    <updated>2022-10-07T07:08:08.367Z</updated>
    
    <content type="html"><![CDATA[<p>一、扩展运算符的应用<br>ES6通过扩展元素符…，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(&#x27;div&#x27;)]</span><br><span class="line">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></pre></td></tr></table></figure><p>主要用于函数调用的时候，将一个数组变为参数序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure><p>可以将某些数据结构转为数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...document.querySelectorAll(&#x27;div&#x27;)]</span><br></pre></td></tr></table></figure><p>能够更简单实现数组复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">const [...a2] = a1;</span><br><span class="line">// [1,2]</span><br></pre></td></tr></table></figure><p>数组的合并也更为简洁了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class="line">const arr2 = [&#x27;c&#x27;];</span><br><span class="line">const arr3 = [&#x27;d&#x27;, &#x27;e&#x27;];</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span><br></pre></td></tr></table></figure><p>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组</p><p>下面看个例子就清楚多了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&#x27;a&#x27;, &#x27;b&#x27;,[1,2]];</span><br><span class="line">const arr2 = [&#x27;c&#x27;];</span><br><span class="line">const arr3  = [...arr1,...arr2]</span><br><span class="line">arr[1][0] = 9999 // 修改arr1里面数组成员值</span><br><span class="line">console.log(arr[3]) // 影响到arr3,[&#x27;a&#x27;,&#x27;b&#x27;,[9999,2],&#x27;c&#x27;]</span><br></pre></td></tr></table></figure><p>扩展运算符可以与解构赋值结合起来，用于生成数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [];</span><br><span class="line">first // undefined</span><br><span class="line">rest  // []</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [&quot;foo&quot;];</span><br><span class="line">first  // &quot;foo&quot;</span><br><span class="line">rest   // []</span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [...butLast, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line"></span><br><span class="line">const [first, ...middle, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure><p>可以将字符串转为真正的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...&#x27;hello&#x27;]</span><br><span class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></pre></td></tr></table></figure><p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let nodeList = document.querySelectorAll(&#x27;div&#x27;);</span><br><span class="line">let array = [...nodeList];</span><br><span class="line"></span><br><span class="line">let map = new Map([</span><br><span class="line">  [1, &#x27;one&#x27;],</span><br><span class="line">  [2, &#x27;two&#x27;],</span><br><span class="line">  [3, &#x27;three&#x27;],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let arr = [...map.keys()]; // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let arr = [...obj]; // TypeError: Cannot spread non-iterable object</span><br></pre></td></tr></table></figure><p>#二、构造函数新增的方法<br>关于构造函数，数组新增的方法有如下：</p><p>Array.from()<br>Array.of()<br>#Array.from()<br>将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &#x27;0&#x27;: &#x27;a&#x27;,</span><br><span class="line">    &#x27;1&#x27;: &#x27;b&#x27;,</span><br><span class="line">    &#x27;2&#x27;: &#x27;c&#x27;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure><p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([1, 2, 3], (x) =&gt; x * x)</span><br><span class="line">// [1, 4, 9]</span><br></pre></td></tr></table></figure><p>#Array.of()<br>用于将一组值，转换为数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br></pre></td></tr></table></figure><p>没有参数的时候，返回一个空数组</p><p>当参数只有一个的时候，实际上是指定数组的长度</p><p>参数个数不少于 2 个时，Array()才会返回由参数组成的新数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array() // []</span><br><span class="line">Array(3) // [, , ,]</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br></pre></td></tr></table></figure><p>#三、实例对象新增的方法<br>关于数组实例对象新增的方法有如下：</p><p>copyWithin()<br>find()、findIndex()<br>fill()<br>entries()，keys()，values()<br>includes()<br>flat()，flatMap()<br>#copyWithin()<br>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p><p>参数如下：</p><p>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。<br>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2</span><br><span class="line">// [4, 5, 3, 4, 5] </span><br></pre></td></tr></table></figure><p>#find()、findIndex()<br>find()用于找出第一个符合条件的数组成员</p><p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].find(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) // 10</span><br></pre></td></tr></table></figure><p>findIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure><p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(v)&#123;</span><br><span class="line">  return v &gt; this.age;</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;name: &#x27;John&#x27;, age: 20&#125;;</span><br><span class="line">[10, 12, 26, 15].find(f, person);    // 26</span><br></pre></td></tr></table></figure><p>#fill()<br>使用给定值，填充一个数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br></pre></td></tr></table></figure><p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7, 1, 2)</span><br><span class="line">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure><p>注意，如果填充的类型为对象，则是浅拷贝</p><p>#entries()，keys()，values()<br>keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">or (let index of [&#x27;a&#x27;, &#x27;b&#x27;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&#x27;a&#x27;, &#x27;b&#x27;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &#x27;a&#x27;</span><br><span class="line">// &#x27;b&#x27;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&#x27;a&#x27;, &#x27;b&#x27;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br></pre></td></tr></table></figure><p>#includes()<br>用于判断数组是否包含给定的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2)     // true</span><br><span class="line">[1, 2, 3].includes(4)     // false</span><br><span class="line">[1, 2, NaN].includes(NaN) // true</span><br></pre></td></tr></table></figure><p>方法的第二个参数表示搜索的起始位置，默认为0</p><p>参数为负数则表示倒数的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(3, 3);  // false</span><br><span class="line">[1, 2, 3].includes(3, -1); // true</span><br></pre></td></tr></table></figure><p>#flat()，flatMap()<br>将数组扁平化处理，返回一个新数组，对原数据没有影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, 4]].flat()</span><br><span class="line">// [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, [4, 5]]].flat()</span><br><span class="line">// [1, 2, 3, [4, 5]]</span><br><span class="line"></span><br><span class="line">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class="line">// [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>flatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span><br><span class="line">[2, 3, 4].flatMap((x) =&gt; [x, x * 2])</span><br><span class="line">// [2, 4, 3, 6, 4, 8]</span><br></pre></td></tr></table></figure><p>flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this</p><p>#四、数组的空位<br>数组的空位指，数组的某一个位置没有任何值</p><p>ES6 则是明确将空位转为undefined，包括Array.from、扩展运算符、copyWithin()、fill()、entries()、keys()、values()、find()和findIndex()</p><p>建议大家在日常书写中，避免出现空位</p><p>#五、排序稳定性<br>将sort()默认设置为稳定的排序算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const arr = [</span><br><span class="line">  &#x27;peach&#x27;,</span><br><span class="line">  &#x27;straw&#x27;,</span><br><span class="line">  &#x27;apple&#x27;,</span><br><span class="line">  &#x27;spork&#x27;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const stableSorting = (s1, s2) =&gt; &#123;</span><br><span class="line">  if (s1[0] &lt; s2[0]) return -1;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">arr.sort(stableSorting)</span><br><span class="line">// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]</span><br></pre></td></tr></table></figure><p>排序结果中，straw在spork的前面，跟原始顺序一致</p>]]></content>
    
    
    <summary type="html">ES6中数组</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>说说var、let、const之间的区别</title>
    <link href="http://example.com/2018/06/11/%E8%AF%B4%E8%AF%B4var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/%E8%AF%B4%E8%AF%B4var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2018/06/11/%E8%AF%B4%E8%AF%B4var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/%E8%AF%B4%E8%AF%B4var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-06-11T11:23:00.000Z</published>
    <updated>2022-10-07T07:01:16.834Z</updated>
    
    <content type="html"><![CDATA[<p>一、var<br>在ES5中，顶层对象的属性和全局变量是等价的，用var声明的变量既是全局变量，也是顶层变量</p><p>注意：顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">console.log(window.a) // 10</span><br></pre></td></tr></table></figure><p>使用var声明的变量存在变量提升的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) // undefined</span><br><span class="line">var a = 20</span><br></pre></td></tr></table></figure><p>在编译阶段，编译器会将其变成以下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a</span><br><span class="line">console.log(a)</span><br><span class="line">a = 20</span><br></pre></td></tr></table></figure><p>使用var，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 20 </span><br><span class="line">var a = 30</span><br><span class="line">console.log(a) // 30</span><br></pre></td></tr></table></figure><p>在函数中使用使用var声明变量时候，该变量是局部的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 20</span><br><span class="line">function change()&#123;</span><br><span class="line">    var a = 30</span><br><span class="line">&#125;</span><br><span class="line">change()</span><br><span class="line">console.log(a) // 20 </span><br></pre></td></tr></table></figure><p>而如果在函数内不使用var，该变量是全局的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 20</span><br><span class="line">function change()&#123;</span><br><span class="line">   a = 30</span><br><span class="line">&#125;</span><br><span class="line">change()</span><br><span class="line">console.log(a) // 30 </span><br></pre></td></tr></table></figure><p>二、let<br>let是ES6新增的命令，用来声明变量</p><p>用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let a = 20</span><br><span class="line">&#125;</span><br><span class="line">console.log(a) // ReferenceError: a is not defined.</span><br></pre></td></tr></table></figure><p>不存在变量提升</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) // 报错ReferenceError</span><br><span class="line">let a = 2</span><br></pre></td></tr></table></figure><p>这表示在声明它之前，变量a是不存在的，这时如果用到它，就会抛出一个错误</p><p>只要块级作用域内存在let命令，这个区域就不再受外部影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 123</span><br><span class="line">if (true) &#123;</span><br><span class="line">    a = &#x27;abc&#x27; // ReferenceError</span><br><span class="line">    let a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用let声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”</p><p>最后，let不允许在相同作用域中重复声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 20</span><br><span class="line">let a = 30</span><br><span class="line">// Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br></pre></td></tr></table></figure><p>注意的是相同作用域，下面这种情况是不会报错的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 20</span><br><span class="line">&#123;</span><br><span class="line">    let a = 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们不能在函数内部重新声明参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function func(arg) &#123;</span><br><span class="line">  let arg;</span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line">// Uncaught SyntaxError: Identifier &#x27;arg&#x27; has already been declared</span><br></pre></td></tr></table></figure><p>三、const<br>const声明一个只读的常量，一旦声明，常量的值就不能改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a = 1</span><br><span class="line">a = 3</span><br><span class="line">// TypeError: Assignment to constant variable</span><br></pre></td></tr></table></figure><p>这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a;</span><br><span class="line">// SyntaxError: Missing initializer in const declaration</span><br></pre></td></tr></table></figure><p>如果之前用var或let声明过变量，再用const声明同样会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 20</span><br><span class="line">let b = 20</span><br><span class="line">const a = 30</span><br><span class="line">const b = 30</span><br><span class="line">// 都会报错</span><br></pre></td></tr></table></figure><p>const实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p><p>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</p><p>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，并不能确保改变量的结构不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 为 foo 添加一个属性，可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">foo.prop // 123</span><br><span class="line"></span><br><span class="line">// 将 foo 指向另一个对象，就会报错</span><br><span class="line">foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only</span><br></pre></td></tr></table></figure><p>其它情况，const与let一致</p><p>#四、区别<br>var、let、const三者区别可以围绕下面五点展开：</p><p>变量提升<br>暂时性死区<br>块级作用域<br>重复声明<br>修改声明的变量<br>使用<br>#变量提升<br>var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined</p><p>let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// var</span><br><span class="line">console.log(a)  // undefined</span><br><span class="line">var a = 10</span><br><span class="line"></span><br><span class="line">// let </span><br><span class="line">console.log(b)  // Cannot access &#x27;b&#x27; before initialization</span><br><span class="line">let b = 10</span><br><span class="line"></span><br><span class="line">// const</span><br><span class="line">console.log(c)  // Cannot access &#x27;c&#x27; before initialization</span><br><span class="line">const c = 10</span><br></pre></td></tr></table></figure><p>暂时性死区<br>var不存在暂时性死区</p><p>let和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// var</span><br><span class="line">console.log(a)  // undefined</span><br><span class="line">var a = 10</span><br><span class="line"></span><br><span class="line">// let</span><br><span class="line">console.log(b)  // Cannot access &#x27;b&#x27; before initialization</span><br><span class="line">let b = 10</span><br><span class="line"></span><br><span class="line">// const</span><br><span class="line">console.log(c)  // Cannot access &#x27;c&#x27; before initialization</span><br><span class="line">const c = 10</span><br></pre></td></tr></table></figure><p>块级作用域<br>var不存在块级作用域</p><p>let和const存在块级作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// var</span><br><span class="line">&#123;</span><br><span class="line">    var a = 20</span><br><span class="line">&#125;</span><br><span class="line">console.log(a)  // 20</span><br><span class="line"></span><br><span class="line">// let</span><br><span class="line">&#123;</span><br><span class="line">    let b = 20</span><br><span class="line">&#125;</span><br><span class="line">console.log(b)  // Uncaught ReferenceError: b is not defined</span><br><span class="line"></span><br><span class="line">// const</span><br><span class="line">&#123;</span><br><span class="line">    const c = 20</span><br><span class="line">&#125;</span><br><span class="line">console.log(c)  // Uncaught ReferenceError: c is not defined</span><br></pre></td></tr></table></figure><p>重复声明<br>var允许重复声明变量</p><p>let和const在同一作用域不允许重复声明变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// var</span><br><span class="line">var a = 10</span><br><span class="line">var a = 20 // 20</span><br><span class="line"></span><br><span class="line">// let</span><br><span class="line">let b = 10</span><br><span class="line">let b = 20 // Identifier &#x27;b&#x27; has already been declared</span><br><span class="line"></span><br><span class="line">// const</span><br><span class="line">const c = 10</span><br><span class="line">const c = 20 // Identifier &#x27;c&#x27; has already been declared</span><br></pre></td></tr></table></figure><p>修改声明的变量<br>var和let可以</p><p>const声明一个只读的常量。一旦声明，常量的值就不能改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// var</span><br><span class="line">var a = 10</span><br><span class="line">a = 20</span><br><span class="line">console.log(a)  // 20</span><br><span class="line"></span><br><span class="line">//let</span><br><span class="line">let b = 10</span><br><span class="line">b = 20</span><br><span class="line">console.log(b)  // 20</span><br><span class="line"></span><br><span class="line">// const</span><br><span class="line">const c = 10</span><br><span class="line">c = 20</span><br><span class="line">console.log(c) // Uncaught TypeError: Assignment to constant variable</span><br></pre></td></tr></table></figure><p>使用<br>能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var</p>]]></content>
    
    
    <summary type="html">说说var、let、const之间的区别</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue自定义插件及使用</title>
    <link href="http://example.com/2018/05/17/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%BD%BF%E7%94%A8/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2018/05/17/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%BD%BF%E7%94%A8/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2018-05-17T13:14:00.000Z</published>
    <updated>2022-10-07T02:28:42.782Z</updated>
    
    <content type="html"><![CDATA[<p>一、Vue插件有什么用</p><p>插件通常会为 Vue 添加全局功能。<br>所谓全局：<br>即不需要像组件那样，每次使用他前都需要先引入一次。对于插件只要在最开始引入一次，在任何组件就可以直接使用。（类似于我们在window上添加的方法属性那样，任何地方都可以用）<br>插件能实现的功能没有限制，不过常见下面几种：</p><p>通过插件，添加全局方法或者属性<br>通过插件，添加全局资源：指令/过滤器/过渡等<br>通过插件(使用全局 mixin 方法)，添加一些组件选项<br>通过插件,添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。<br>一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router</p><p>二、插件原理<br>所谓vue插件其实就是一个简单的js对象而已，然后这个插件对象有一个公开属性 install ，他的值为一个函数，此函数接受两个参数。第一个参数是 Vue 构造器 , 第二个参数是一个可选的选项对象。<br><img src="https://img2018.cnblogs.com/blog/1744497/201908/1744497-20190805230239328-678884142.png" loading="lazy"><br>三、插件编写及举例<br> 1、编写插件<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// install函数</span><br><span class="line"></span><br><span class="line">let Valid = &#123;&#125;</span><br><span class="line">Valid.install = function(Vue, options = &#123; triggEvent: &quot;input&quot; &#125;) &#123;</span><br><span class="line">    // static props 静态属性</span><br><span class="line">    // Vue.t1703C=&quot;hello everyone&quot;</span><br><span class="line">    // Vue.t1703C = &quot;1703C&quot;</span><br><span class="line">    // console.log(this) this指向vue  可一直往上查找,可查找到new Vue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 所有需要验证的组成一个列表</span><br><span class="line">    let regList = [&#123;</span><br><span class="line">        &quot;type&quot;: &quot;phone&quot;,</span><br><span class="line">        &quot;RegExp&quot;: /^1[345679]d&#123;9&#125;$/,</span><br><span class="line">        &quot;msg&quot;: &quot;手机需要11位数字&quot;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        &quot;type&quot;: &quot;pwd&quot;,</span><br><span class="line">        &quot;RegExp&quot;: /w&#123;6,9&#125;/</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        &quot;type&quot;: &quot;code&quot;,</span><br><span class="line">        &quot;RegExp&quot;: /d&#123;4&#125;/</span><br><span class="line">    &#125;]</span><br><span class="line"></span><br><span class="line">    Vue.directive(&quot;valid&quot;, &#123;</span><br><span class="line">        bind(el, binding) &#123;</span><br><span class="line">            // el:dom节点 binding:对象（可使用value）</span><br><span class="line">            // console.log(binding)</span><br><span class="line"></span><br><span class="line">            // 失去焦点事件</span><br><span class="line">            el.addEventListener(options.triggEvent, function(e) &#123;</span><br><span class="line">                // console.log(e.target.value)</span><br><span class="line"></span><br><span class="line">                // 找到符合条件的对象</span><br><span class="line">                let validObj = regList.find(item =&gt; item.type === binding.value)</span><br><span class="line">                if (validObj.RegExp.test(e.target.value)) &#123;</span><br><span class="line">                    console.log(&quot;验证通过&quot;)</span><br><span class="line">                    e.target.classList.remove(options.errorClass)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // let span = document.createElement(&quot;span&quot;);</span><br><span class="line">                    // span.innerText = validObj.msg</span><br><span class="line">                    // e.target.parentNode.appendChild(span)</span><br><span class="line">                    console.log(&quot;格式错误&quot;)</span><br><span class="line">                    e.target.classList.add(options.errorClass)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">export default Valid</span><br></pre></td></tr></table></figure><br>2、使用：使用插件的时候，在main.js入口文件import引入，再使用use()方法使用即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line">import ElementUI from &#x27;element-ui&#x27;;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class="line">//引入axios</span><br><span class="line">import $http from &quot;@/plugins/$http&quot;;</span><br><span class="line">//引入自定义插件插件  v-vaild</span><br><span class="line">import Valid from &quot;@/plugins/validator&quot;;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line">//全局的axios</span><br><span class="line">Vue.use($http, &#123; timeout: 2000 &#125;);</span><br><span class="line">//自定义插件</span><br><span class="line">Vue.use(Valid, &#123;</span><br><span class="line">    triggEvent: &quot;blur&quot;, //triggEvent:事件  value值必须是字符串，</span><br><span class="line">    errorClass: &quot;vaild-error&quot; //errorClass：类名</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: h =&gt; h(App)</span><br><span class="line">        // created() &#123;</span><br><span class="line">        //     console.log(this)</span><br><span class="line">        // &#125;,</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>3、在组件中访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;login&quot;&gt; </span><br><span class="line">        &lt;header class=&quot;loginHeader&quot;&gt;登录/注册&lt;/header&gt;</span><br><span class="line">        &lt;main class=&quot;loginMain&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;con&quot;&gt;</span><br><span class="line">　　　　　　　　　　//在这里使用了自定义插件v-vaild</span><br><span class="line">                &lt;input v-valid=&quot;&#x27;phone&#x27;&quot; placeholder=&quot;请输入姓名&quot; v-model=&quot;user&quot; class=&quot;user&quot;/&gt;</span><br><span class="line">                &lt;input v-valid=&quot;&#x27;pwd&#x27;&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;password&quot; show-password class=&quot;pwd&quot;/&gt;</span><br><span class="line">                &lt;input v-valid=&quot;&#x27;code&#x27;&quot; placeholder=&quot;请输入验证码&quot; v-model=&quot;code&quot;  class=&quot;code&quot;/&gt;</span><br><span class="line">                &lt;span v-html=&quot;this.svg&quot; class=&quot;captch&quot; @click=&quot;upDataCaptch&quot;&gt;&lt;/span&gt;</span><br><span class="line">                &lt;el-button type=&quot;primary&quot; class=&quot;btn&quot; @click=&quot;handleLogin&quot;&gt;登录&lt;/el-button&gt;</span><br><span class="line">                &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/main&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            user:&quot;&quot;,</span><br><span class="line">            password:&quot;&quot;,</span><br><span class="line">            code:&quot;&quot;,</span><br><span class="line">            svg:&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        handleLogin()&#123;</span><br><span class="line">            let data=&#123;username:this.user,password:this.password,captcha:this.code&#125;</span><br><span class="line">            this.$http.post(&quot;/api/buyer/user/login&quot;,data).then(res=&gt;&#123;</span><br><span class="line">                window.sessionStorage.setItem(&quot;token&quot;,res.token)</span><br><span class="line">                console.log(res)</span><br><span class="line">                if(res.code===1)&#123;</span><br><span class="line">                   this.$router.push(&quot;/list&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).finally(()=&gt;&#123;</span><br><span class="line">                // 登录失败再次调用</span><br><span class="line">                this.upDataCaptch()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        upDataCaptch()&#123;</span><br><span class="line">            // 每次点击都请求一次验证码</span><br><span class="line">             this.$http.get(&quot;/api/buyer/user/captcha&quot;).then(res=&gt;&#123;</span><br><span class="line">                console.log(res)</span><br><span class="line">                this.svg=res.data</span><br><span class="line">            &#125;)  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        // 初始化</span><br><span class="line">        this.upDataCaptch()</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style  lang=&quot;scss&quot;&gt;</span><br><span class="line">*&#123;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">html,body&#123;</span><br><span class="line">     100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    font-size: calc(100/750*100vw);</span><br><span class="line">&#125;</span><br><span class="line">.login&#123;</span><br><span class="line">     100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    font-size: calc(.16rem*2);</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    background: #ebebec;</span><br><span class="line">&#125;</span><br><span class="line">.loginHeader&#123;</span><br><span class="line">     100%;</span><br><span class="line">    height: calc(.5rem*2);</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.loginMain&#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line">.con&#123;</span><br><span class="line">     80%;</span><br><span class="line">    height: 80%;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    input&#123;</span><br><span class="line">         100%;</span><br><span class="line">        height: calc(.3rem*2);</span><br><span class="line">    &#125;</span><br><span class="line">    .user&#123;</span><br><span class="line">        margin-top: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">    .pwd&#123;</span><br><span class="line">        margin-top: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">    .btn&#123;</span><br><span class="line">        100%;</span><br><span class="line">       height: 10%;</span><br><span class="line">       margin-top: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">    .code&#123;</span><br><span class="line">        margin-top: 20px;</span><br><span class="line">         50%;</span><br><span class="line">    &#125;</span><br><span class="line">     .captch&#123;</span><br><span class="line">        margin-top: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">插件的自定义方式</summary>
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>ajax原理是什么</title>
    <link href="http://example.com/2018/04/27/ajax%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/ajax%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://example.com/2018/04/27/ajax%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/ajax%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2018-04-27T14:06:00.000Z</published>
    <updated>2022-10-07T02:18:50.513Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>AJAX全称(Async Javascript and XML)</p><p>即异步的JavaScript 和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页</p><p>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面</p><p>流程图如下：<br><img src="https://static.vue-js.com/af42de10-7b2a-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>下面举个例子：</p><p>领导想找小李汇报一下工作，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作</p><p>Ajax请求数据流程与“领导想找小李汇报一下工作”类似，上述秘书就相当于XMLHttpRequest对象，领导相当于浏览器，响应数据相当于小李</p><p>浏览器可以发送HTTP请求后，接着做其他事情，等收到XHR返回来的数据再进行操作</p><p>#二、实现过程<br>实现 Ajax异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p><p>创建 Ajax的核心对象 XMLHttpRequest对象</p><p>通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接</p><p>构建请求所需的数据内容，并通过XMLHttpRequest 对象的 send() 方法发送给服务器端</p><p>通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态</p><p>接受并处理服务端向客户端响应的数据结果</p><p>将处理结果更新到 HTML页面中</p><p>#创建XMLHttpRequest对象<br>通过XMLHttpRequest() 构造函数用于初始化一个 XMLHttpRequest 实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br></pre></td></tr></table></figure><p>与服务器建立连接<br>通过 XMLHttpRequest 对象的 open() 方法与服务器建立连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(method, url, [async][, user][, password])</span><br></pre></td></tr></table></figure><p>参数说明：<br>method：表示当前的请求方式，常见的有GET、POST<br>url：服务端地址<br>async：布尔值，表示是否异步执行操作，默认为true<br>user: 可选的用户名用于认证用途；默认为<code>null password: 可选的密码用于认证用途，默认为</code>null<br>#给服务端发送数据<br>通过 XMLHttpRequest 对象的 send() 方法，将客户端页面的数据发送给服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send([body])</span><br></pre></td></tr></table></figure><p>body: 在 XHR 请求中要发送的数据体，如果不传递数据则为 null</p><p>如果使用GET请求发送数据的时候，需要注意如下：</p><p>将请求数据添加到open()方法中的url地址中<br>发送请求数据中的send()方法中参数设置为null<br>#绑定onreadystatechange事件<br>onreadystatechange 事件用于监听服务器端的通信状态，主要监听的属性为XMLHttpRequest.readyState ,</p><p>关于XMLHttpRequest.readyState属性有五个状态，如下图显示</p><p><img src="https://static.vue-js.com/9782fc90-7b31-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>只要 readyState属性值一变化，就会触发一次 readystatechange 事件</p><p>XMLHttpRequest.responseText属性用于接收服务器端的响应结果</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const request = new XMLHttpRequest()</span><br><span class="line">request.onreadystatechange = function(e)&#123;</span><br><span class="line">    if(request.readyState === 4)&#123; // 整个请求过程完毕</span><br><span class="line">        if(request.status &gt;= 200 &amp;&amp; request.status &lt;= 300)&#123;</span><br><span class="line">            console.log(request.responseText) // 服务端返回的结果</span><br><span class="line">        &#125;else if(request.status &gt;=400)&#123;</span><br><span class="line">            console.log(&quot;错误信息：&quot; + request.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">request.open(&#x27;POST&#x27;,&#x27;http://xxxx&#x27;)</span><br><span class="line">request.send()</span><br></pre></td></tr></table></figure><p>三、封装<br>通过上面对XMLHttpRequest对象的了解，下面来封装一个简单的ajax请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//封装一个ajax请求</span><br><span class="line">function ajax(options) &#123;</span><br><span class="line">    //创建XMLHttpRequest对象</span><br><span class="line">    const xhr = new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //初始化参数的内容</span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.type = (options.type || &#x27;GET&#x27;).toUpperCase()</span><br><span class="line">    options.dataType = options.dataType || &#x27;json&#x27;</span><br><span class="line">    const params = options.data</span><br><span class="line"></span><br><span class="line">    //发送请求</span><br><span class="line">    if (options.type === &#x27;GET&#x27;) &#123;</span><br><span class="line">        xhr.open(&#x27;GET&#x27;, options.url + &#x27;?&#x27; + params, true)</span><br><span class="line">        xhr.send(null)</span><br><span class="line">    &#125; else if (options.type === &#x27;POST&#x27;) &#123;</span><br><span class="line">        xhr.open(&#x27;POST&#x27;, options.url, true)</span><br><span class="line">        xhr.send(params)</span><br><span class="line">    //接收请求</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        if (xhr.readyState === 4) &#123;</span><br><span class="line">            let status = xhr.status</span><br><span class="line">            if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123;</span><br><span class="line">                options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                options.fail &amp;&amp; options.fail(status)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">    type: &#x27;post&#x27;,</span><br><span class="line">    dataType: &#x27;json&#x27;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    url: &#x27;https://xxxx&#x27;,</span><br><span class="line">    success: function(text,xml)&#123;//请求成功后的回调函数</span><br><span class="line">        console.log(text)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: function(status)&#123;////请求失败后的回调函数</span><br><span class="line">        console.log(status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、是什么&lt;br&gt;AJAX全称(Async Javascript and XML)&lt;/p&gt;
&lt;p&gt;即异步的JavaScript 和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页&lt;/p&gt;
&lt;p&gt;Ajax的原</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>说说new操作符具体干了什么</title>
    <link href="http://example.com/2018/04/20/%E8%AF%B4%E8%AF%B4new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/%E8%AF%B4%E8%AF%B4new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://example.com/2018/04/20/%E8%AF%B4%E8%AF%B4new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/%E8%AF%B4%E8%AF%B4new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2018-04-20T12:33:00.000Z</published>
    <updated>2022-10-06T10:55:09.783Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>在JavaScript中，new操作符用于创建一个给定构造函数的实例对象</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">const person1 = new Person(&#x27;Tom&#x27;, 20)</span><br><span class="line">console.log(person1)  // Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br><span class="line">t.sayName() // &#x27;Tom&#x27;</span><br></pre></td></tr></table></figure><p>从上面可以看到：</p><p>new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性<br>new 通过构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）<br>现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Test(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  return 1</span><br><span class="line">&#125;</span><br><span class="line">const t = new Test(&#x27;xxx&#x27;)</span><br><span class="line">console.log(t.name) // &#x27;xxx&#x27;</span><br></pre></td></tr></table></figure><p>可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用</p><p>下面在构造函数中返回一个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Test(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  console.log(this) // Test &#123; name: &#x27;xxx&#x27; &#125;</span><br><span class="line">  return &#123; age: 26 &#125;</span><br><span class="line">&#125;</span><br><span class="line">const t = new Test(&#x27;xxx&#x27;)</span><br><span class="line">console.log(t) // &#123; age: 26 &#125;</span><br><span class="line">console.log(t.name) // &#x27;undefined&#x27;</span><br></pre></td></tr></table></figure><p>二、流程<br>从上面介绍中，我们可以看到new关键字主要做了以下的工作：</p><p>创建一个新的对象obj</p><p>将对象与构建函数通过原型链连接起来</p><p>将构建函数中的this绑定到新建的对象obj上</p><p>根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">const person1 = new Person(&#x27;Tom&#x27;, 20)</span><br><span class="line">console.log(person1)  // Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br><span class="line">t.sayName() // &#x27;Tom&#x27;</span><br></pre></td></tr></table></figure><p>流程图如下：<br><img src="https://static.vue-js.com/b429b990-7a39-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>三、手写new操作符<br>现在我们已经清楚地掌握了new的执行过程</p><p>那么我们就动手来实现一下new</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function mynew(Func, ...args) &#123;</span><br><span class="line">    // 1.创建一个新对象</span><br><span class="line">    const obj = &#123;&#125;</span><br><span class="line">    // 2.新对象原型指向构造函数原型对象</span><br><span class="line">    obj.__proto__ = Func.prototype</span><br><span class="line">    // 3.将构建函数的this指向新对象</span><br><span class="line">    let result = Func.apply(obj, args)</span><br><span class="line">    // 4.根据返回值判断</span><br><span class="line">    return result instanceof Object ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function mynew(func, ...args) &#123;</span><br><span class="line">    const obj = &#123;&#125;</span><br><span class="line">    obj.__proto__ = func.prototype</span><br><span class="line">    let result = func.apply(obj, args)</span><br><span class="line">    return result instanceof Object ? result : obj</span><br><span class="line">&#125;</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = mynew(Person, &quot;huihui&quot;, 123)</span><br><span class="line">console.log(p) // Person &#123;name: &quot;huihui&quot;, age: 123&#125;</span><br><span class="line">p.say() // huihui</span><br></pre></td></tr></table></figure><p>可以发现，代码虽然很短，但是能够模拟实现new</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、是什么&lt;br&gt;在JavaScript中，new操作符用于创建一个给定构造函数的实例对象&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>解释下什么是事件代理及应用场景</title>
    <link href="http://example.com/2018/04/16/%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://example.com/2018/04/16/%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2018-04-16T10:13:00.000Z</published>
    <updated>2022-10-06T10:30:49.168Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>事件代理，俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素</p><p>前面讲到，事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件委托就是在冒泡阶段完成</p><p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素</p><p>当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p><p>下面举个例子：</p><p>比如一个宿舍的同学同时快递到了，一种笨方法就是他们一个个去领取</p><p>较优方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个同学</p><p>在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM元素，而出去统一领取快递的宿舍长就是代理的元素</p><p>所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个</p><p>#二、应用场景<br>如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 3&lt;/li&gt;</span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取目标元素</span><br><span class="line">const lis = document.getElementsByTagName(&quot;li&quot;)</span><br><span class="line">// 循环遍历绑定事件</span><br><span class="line">for (let i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    lis[i].onclick = function(e)&#123;</span><br><span class="line">        console.log(e.target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就可以事件委托，把点击事件绑定在父级元素ul上面，然后执行事件的时候再去匹配目标元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 给父层元素绑定事件</span><br><span class="line">document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    // 兼容性处理</span><br><span class="line">    var event = e || window.event;</span><br><span class="line">    var target = event.target || event.srcElement;</span><br><span class="line">    // 判断是否匹配目标元素</span><br><span class="line">    if (target.nodeName.toLocaleLowerCase === &#x27;li&#x27;) &#123;</span><br><span class="line">        console.log(&#x27;the content is: &#x27;, target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件</p><p>但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件</p><p>如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的</p><p>举个例子：</p><p>下面html结构中，点击input可以动态添加元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;btn&quot; value=&quot;添加&quot; /&gt;</span><br><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;item 3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;item 4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>使用事件委托</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const oBtn = document.getElementById(&quot;btn&quot;);</span><br><span class="line">const oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">const num = 4;</span><br><span class="line"></span><br><span class="line">//事件委托，添加的子元素也有事件</span><br><span class="line">oUl.onclick = function (ev) &#123;</span><br><span class="line">    ev = ev || window.event;</span><br><span class="line">    const target = ev.target || ev.srcElement;</span><br><span class="line">    if (target.nodeName.toLowerCase() == &#x27;li&#x27;) &#123;</span><br><span class="line">        console.log(&#x27;the content is: &#x27;, target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//添加新节点</span><br><span class="line">oBtn.onclick = function () &#123;</span><br><span class="line">    num++;</span><br><span class="line">    const oLi = document.createElement(&#x27;li&#x27;);</span><br><span class="line">    oLi.innerHTML = `item $&#123;num&#125;`;</span><br><span class="line">    oUl.appendChild(oLi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的</p><p>#三、总结<br>适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress</p><p>从上面应用场景中，我们就可以看到使用事件委托存在两大优点：</p><p>减少整个页面所需的内存，提升整体性能<br>动态绑定，减少重复工作<br>但是使用事件委托也是存在局限性：</p><p>focus、blur这些事件没有事件冒泡机制，所以无法进行委托绑定事件</p><p>mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</p><p>如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、是什么&lt;br&gt;事件代理，俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素&lt;/p&gt;
&lt;p&gt;前面讲到，事件流的都会经过三个阶段： 捕获阶段 -&amp;gt; 目标阶段 -&amp;gt; 冒泡阶段，而事件委托就是在冒泡阶段完成&lt;/p&gt;
&lt;p&gt;事件委</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>typeof 与 instanceof 区别</title>
    <link href="http://example.com/2018/04/07/%E5%8C%BA%E5%88%AB/%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2018/04/07/%E5%8C%BA%E5%88%AB/%E5%8C%BA%E5%88%AB/</id>
    <published>2018-04-07T14:05:00.000Z</published>
    <updated>2022-10-06T10:25:32.049Z</updated>
    
    <content type="html"><![CDATA[<p>一、typeof<br>typeof 操作符返回一个字符串，表示未经计算的操作数的类型</p><p>使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof operand</span><br><span class="line">typeof(operand)</span><br></pre></td></tr></table></figure><p>operand表示对象或原始值的表达式，其类型将被返回<br>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &#x27;number&#x27;</span><br><span class="line">typeof &#x27;1&#x27; // &#x27;string&#x27;</span><br><span class="line">typeof undefined // &#x27;undefined&#x27;</span><br><span class="line">typeof true // &#x27;boolean&#x27;</span><br><span class="line">typeof Symbol() // &#x27;symbol&#x27;</span><br><span class="line">typeof null // &#x27;object&#x27;</span><br><span class="line">typeof [] // &#x27;object&#x27;</span><br><span class="line">typeof &#123;&#125; // &#x27;object&#x27;</span><br><span class="line">typeof console // &#x27;object&#x27;</span><br><span class="line">typeof console.log // &#x27;function&#x27;</span><br></pre></td></tr></table></figure><p>从上面例子，前6个都是基础数据类型。虽然typeof null为object，但这只是JavaScript 存在的一个悠久 Bug，不代表null就是引用数据类型，并且null本身也不是对象</p><p>所以，null在 typeof之后返回的是有问题的结果，不能作为判断null的方法。如果你需要在 if 语句中判断是否为 null，直接通过===null来判断就好</p><p>同时，可以发现引用类型数据，用typeof来判断的话，除了function会被识别出来之外，其余的都输出object</p><p>如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a)， 若a未声明，则报错)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(typeof a != &#x27;undefined&#x27;)&#123;</span><br><span class="line">    //变量存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、instanceof<br>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p><p>使用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object instanceof constructor</span><br></pre></td></tr></table></figure><p>object为实例对象，constructor为构造函数</p><p>构造函数通过new可以实例对象，instanceof能判断这个对象是否是之前那个构造函数生成的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义构建函数</span><br><span class="line">let Car = function() &#123;&#125;</span><br><span class="line">let benz = new Car()</span><br><span class="line">benz instanceof Car // true</span><br><span class="line">let car = new String(&#x27;xxx&#x27;)</span><br><span class="line">car instanceof String // true</span><br><span class="line">let str = &#x27;xxx&#x27;</span><br><span class="line">str instanceof String // false</span><br></pre></td></tr></table></figure><p>关于instanceof的实现原理，可以参考下面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">    // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line">    if(typeof left !== &#x27;object&#x27; || left === null) return false;</span><br><span class="line">    // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line">    let proto = Object.getPrototypeOf(left);</span><br><span class="line">    while(true) &#123;                  </span><br><span class="line">        if(proto === null) return false;</span><br><span class="line">        if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line">        proto = Object.getPrototypeof(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是顺着原型链去找，直到找到相同的原型对象，返回true，否则为false</p><p>#三、区别<br>typeof与instanceof都是判断数据类型的方法，区别如下：</p><p>typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值</p><p>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</p><p>而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断</p><p>可以看到，上述两种方法都有弊端，并不能满足所有场景的需求</p><p>如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]”的字符串</p><p>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&#x27;1&#x27;)  // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br></pre></td></tr></table></figure><p>了解了toString的基本用法，下面就实现一个全局通用的数据类型判断方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &#x27;$1&#x27;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getType([])     // &quot;Array&quot; typeof []是object，因此toString返回</span><br><span class="line">getType(&#x27;123&#x27;)  // &quot;string&quot; typeof 直接返回</span><br><span class="line">getType(window) // &quot;Window&quot; toString返回</span><br><span class="line">getType(null)   // &quot;Null&quot;首字母大写，typeof null是object，需toString来判断</span><br><span class="line">getType(undefined)   // &quot;undefined&quot; typeof 直接返回</span><br><span class="line">getType()            // &quot;undefined&quot; typeof 直接返回</span><br><span class="line">getType(function()&#123;&#125;) // &quot;function&quot; typeof能判断，因此首字母小写</span><br><span class="line">getType(/123/g)      //&quot;RegExp&quot; toString返回</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、typeof&lt;br&gt;typeof 操作符返回一个字符串，表示未经计算的操作数的类型&lt;/p&gt;
&lt;p&gt;使用方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>谈谈this对象的理解</title>
    <link href="http://example.com/2018/03/22/%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2018/03/22/%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2018-03-22T12:25:00.000Z</published>
    <updated>2022-10-06T10:20:08.080Z</updated>
    
    <content type="html"><![CDATA[<p>一、定义<br>函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别</p><p>在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）</p><p>this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function baz() &#123;</span><br><span class="line">    // 当前调用栈是：baz</span><br><span class="line">    // 因此，当前调用位置是全局作用域</span><br><span class="line">    </span><br><span class="line">    console.log( &quot;baz&quot; );</span><br><span class="line">    bar(); // &lt;-- bar的调用位置</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">    // 当前调用栈是：baz --&gt; bar</span><br><span class="line">    // 因此，当前调用位置在baz中</span><br><span class="line">    </span><br><span class="line">    console.log( &quot;bar&quot; );</span><br><span class="line">    foo(); // &lt;-- foo的调用位置</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    // 当前调用栈是：baz --&gt; bar --&gt; foo</span><br><span class="line">    // 因此，当前调用位置在bar中</span><br><span class="line">    </span><br><span class="line">    console.log( &quot;foo&quot; );</span><br><span class="line">&#125;</span><br><span class="line">baz(); // &lt;-- baz的调用位置</span><br></pre></td></tr></table></figure><p>同时，this在函数执行过程中，this一旦被确定了，就不可以再更改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  this = obj; // 修改this，运行后会报错</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>二、绑定规则<br>根据不同的使用场合，this有不同的值，主要分为下面几种情况：</p><p>默认绑定</p><p>隐式绑定</p><p>new绑定</p><p>显示绑定</p><p>#默认绑定<br>全局环境中定义person函数，内部使用this关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;Jenny&#x27;;</span><br><span class="line">function person() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">console.log(person());  //Jenny</span><br></pre></td></tr></table></figure><p>上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny</p><p>注意：</p><p>严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p><p>#隐式绑定<br>函数还可以作为某个对象的方法调用，这时this就指这个上级对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.x = 1;</span><br><span class="line">obj.m = test;</span><br><span class="line"></span><br><span class="line">obj.m(); // 1</span><br></pre></td></tr></table></figure><p>这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    a:10,</span><br><span class="line">    b:&#123;</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.a); //undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn();</span><br></pre></td></tr></table></figure><p>上述代码中，this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined</p><p>这里再举一种特殊情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    a:10,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:12,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.a); //undefined</span><br><span class="line">            console.log(this); //window</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var j = o.b.fn;</span><br><span class="line">j();</span><br></pre></td></tr></table></figure><p>此时this指向的是window，这里的大家需要记住，this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向window</p><p>#new绑定<br>通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">　this.x = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = new test();</span><br><span class="line">obj.x // 1</span><br></pre></td></tr></table></figure><p>上述代码之所以能过输出1，是因为new关键字改变了this的指向</p><p>这里再列举一些特殊情况：</p><p>new过程遇到return一个对象，此时this指向为返回的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn()  </span><br><span class="line">&#123;  </span><br><span class="line">    this.user = &#x27;xxx&#x27;;  </span><br><span class="line">    return &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line">var a = new fn();  </span><br><span class="line">console.log(a.user); //undefined</span><br></pre></td></tr></table></figure><p>如果返回一个简单类型的时候，则this指向实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn()  </span><br><span class="line">&#123;  </span><br><span class="line">    this.user = &#x27;xxx&#x27;;  </span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">var a = new fn;  </span><br><span class="line">console.log(a.user); //xxx</span><br></pre></td></tr></table></figure><p>注意的是null虽然也是对象，但是此时new仍然指向实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn()  </span><br><span class="line">&#123;  </span><br><span class="line">    this.user = &#x27;xxx&#x27;;  </span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">var a = new fn;  </span><br><span class="line">console.log(a.user); //xxx</span><br></pre></td></tr></table></figure><p>显示修改<br>apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">function test() &#123;</span><br><span class="line">　console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.x = 1;</span><br><span class="line">obj.m = test;</span><br><span class="line">obj.m.apply(obj) // 1</span><br></pre></td></tr></table></figure><p>关于apply、call、bind三者的区别，我们后面再详细说</p><p>#三、箭头函数<br>在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定）</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  sayThis: () =&gt; &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayThis(); // window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了</span><br><span class="line">const globalSay = obj.sayThis;</span><br><span class="line">globalSay(); // window 浏览器中的 global 对象</span><br></pre></td></tr></table></figure><p>虽然箭头函数的this能够在编译的时候就确定了this的指向，但也需要注意一些潜在的坑</p><p>下面举个例子：</p><p>绑定事件监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const button = document.getElementById(&#x27;mngb&#x27;);</span><br><span class="line">button.addEventListener(&#x27;click&#x27;, ()=&gt; &#123;</span><br><span class="line">    console.log(this === window) // true</span><br><span class="line">    this.innerHTML = &#x27;clicked button&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述可以看到，我们其实是想要this为点击的button，但此时this指向了window</p><p>包括在原型上添加方法时候，此时this指向window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype.sayName = () =&gt; &#123;</span><br><span class="line">    console.log(this === window) //true</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">const cat = new Cat(&#x27;mm&#x27;);</span><br><span class="line">cat.sayName()</span><br></pre></td></tr></table></figure><p>同样的，箭头函数不能作为构建函数</p><p>#四、优先级<br>#隐式绑定 VS 显式绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    a: 3,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(); // 2</span><br><span class="line">obj2.foo(); // 3</span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2 ); // 3</span><br><span class="line">obj2.foo.call( obj1 ); // 2</span><br></pre></td></tr></table></figure><p>显然，显示绑定的优先级更高</p><p>#new绑定 VS 隐式绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">    this.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo( 2 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2, 3 );</span><br><span class="line">console.log( obj2.a ); // 3</span><br><span class="line"></span><br><span class="line">var bar = new obj1.foo( 4 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line">console.log( bar.a ); // 4</span><br></pre></td></tr></table></figure><p>可以看到，new绑定的优先级&gt;隐式绑定</p><p>#new绑定 VS 显式绑定<br>因为new和apply、call无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">    this.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.bind( obj1 );</span><br><span class="line">bar( 2 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line"></span><br><span class="line">var baz = new bar( 3 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line">console.log( baz.a ); // 3</span><br></pre></td></tr></table></figure><p>bar被绑定到obj1上，但是new bar(3) 并没有像我们预计的那样把obj1.a修改为3。但是，new修改了绑定调用bar()中的this</p><p>我们可认为new绑定优先级&gt;显式绑定</p><p>综上，new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>]]></content>
    
    
    <summary type="html">函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript如何实现继承?</title>
    <link href="http://example.com/2018/03/18/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
    <id>http://example.com/2018/03/18/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</id>
    <published>2018-03-18T14:30:00.000Z</published>
    <updated>2022-10-06T10:12:18.821Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>继承（inheritance）是面向对象软件技术当中的一个概念。</p><p>如果一个类别 B“继承自”另一个类别 A，就把这个 B 称为“A 的子类”，而把 A 称为“B 的父类别”也可以称“A 是 B 的超类”</p><p>继承的优点<br>继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码</p><p>在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能</p><p>虽然 JavaScript 并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富</p><p>关于继承，我们举个形象的例子：</p><p>定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">constructor(color,speed)&#123;</span><br><span class="line">this.color = color</span><br><span class="line">this.speed = speed</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 货车</span><br><span class="line">class Truck extends Car&#123;</span><br><span class="line">constructor(color,speed)&#123;</span><br><span class="line">super(color,speed)</span><br><span class="line">this.Container = true // 货箱</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性</p><p>在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Truck extends Car&#123;</span><br><span class="line">constructor(color,speed)&#123;</span><br><span class="line">super(color,speed)</span><br><span class="line">this.color = &quot;black&quot; //覆盖</span><br><span class="line">this.Container = true // 货箱</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系</p><p>#二、实现方式<br>下面给出 JavaScripy 常见的继承方式：</p><p>原型链继承</p><p>构造函数继承（借助 call）</p><p>组合继承</p><p>原型式继承</p><p>寄生式继承</p><p>寄生组合式继承</p><p>#原型链继承<br>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针</p><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">this.name = &#x27;parent1&#x27;;</span><br><span class="line">this.play = [1, 2, 3]</span><br><span class="line">&#125;</span><br><span class="line">function Child() &#123;</span><br><span class="line">this.type = &#x27;child2&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Child1.prototype = new Parent();</span><br><span class="line">console.log(new Child())</span><br></pre></td></tr></table></figure><p>上面代码看似没问题，实际存在潜在问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Child2();</span><br><span class="line">var s2 = new Child2();</span><br><span class="line">s1.play.push(4);</span><br><span class="line">console.log(s1.play, s2.play); // [1,2,3,4]</span><br></pre></td></tr></table></figure><p>改变 s1 的 play 属性，会发现 s2 也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的</p><p>#构造函数继承<br>借助 call 调用 Parent 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">this.name = &#x27;parent1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child()&#123;</span><br><span class="line">Parent1.call(this);</span><br><span class="line">this.type = &#x27;child&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let child = new Child();</span><br><span class="line">console.log(child); // 没问题</span><br><span class="line">console.log(child.getName()); // 会报错</span><br></pre></td></tr></table></figure><p>可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法</p><p>相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法</p><p>#组合继承<br>前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line">this.name = &#x27;parent3&#x27;;</span><br><span class="line">this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function Child3() &#123;</span><br><span class="line">// 第二次调用 Parent3()</span><br><span class="line">Parent3.call(this);</span><br><span class="line">this.type = &#x27;child3&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第一次调用 Parent3()</span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line">var s3 = new Child3();</span><br><span class="line">var s4 = new Child3();</span><br><span class="line">s3.play.push(4);</span><br><span class="line">console.log(s3.play, s4.play); // 不互相影响</span><br><span class="line">console.log(s3.getName()); // 正常输出&#x27;parent3&#x27;</span><br><span class="line">console.log(s4.getName()); // 正常输出&#x27;parent3&#x27;</span><br></pre></td></tr></table></figure><p>这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到 Parent3 执行了两次，造成了多构造一次的性能开销</p><p>#原型式继承<br>这里主要借助 Object.create 方法实现普通对象的继承</p><p>同样举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let parent4 = &#123;</span><br><span class="line">name: &quot;parent4&quot;,</span><br><span class="line">friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line">getName: function() &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let person4 = Object.create(parent4);</span><br><span class="line">person4.name = &quot;tom&quot;;</span><br><span class="line">person4.friends.push(&quot;jerry&quot;);</span><br><span class="line"></span><br><span class="line">let person5 = Object.create(parent4);</span><br><span class="line">person5.friends.push(&quot;lucy&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person4.name); // tom</span><br><span class="line">console.log(person4.name === person4.getName()); // true</span><br><span class="line">console.log(person5.name); // parent4</span><br><span class="line">console.log(person4.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span><br><span class="line">console.log(person5.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span><br></pre></td></tr></table></figure><p>这种继承方式的缺点也很明显，因为Object.create方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能</p><p>#寄生式继承<br>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let parent5 = &#123;</span><br><span class="line">    name: &quot;parent5&quot;,</span><br><span class="line">    friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function clone(original) &#123;</span><br><span class="line">    let clone = Object.create(original);</span><br><span class="line">    clone.getFriends = function() &#123;</span><br><span class="line">        return this.friends;</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person5 = clone(parent5);</span><br><span class="line"></span><br><span class="line">console.log(person5.getName()); // parent5</span><br><span class="line">console.log(person5.getFriends()); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;]</span><br></pre></td></tr></table></figure><p>其优缺点也很明显，跟上面讲的原型式继承一样</p><p>#寄生组合式继承<br>寄生组合式继承，借助解决普通对象的继承问题的Object.create 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function clone (parent, child) &#123;</span><br><span class="line">    // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br><span class="line">    child.prototype = Object.create(parent.prototype);</span><br><span class="line">    child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Parent6() &#123;</span><br><span class="line">    this.name = &#x27;parent6&#x27;;</span><br><span class="line">    this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">Parent6.prototype.getName = function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function Child6() &#123;</span><br><span class="line">    Parent6.call(this);</span><br><span class="line">    this.friends = &#x27;child5&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line"></span><br><span class="line">Child6.prototype.getFriends = function () &#123;</span><br><span class="line">    return this.friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person6 = new Child6();</span><br><span class="line">console.log(person6); //&#123;friends:&quot;child5&quot;,name:&quot;child5&quot;,play:[1,2,3],__proto__:Parent6&#125;</span><br><span class="line">console.log(person6.getName()); // parent6</span><br><span class="line">console.log(person6.getFriends()); // child5</span><br></pre></td></tr></table></figure><p>可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题</p><p>文章一开头，我们是使用ES6 中的extends关键字直接实现 JavaScript的继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  // 原型方法</span><br><span class="line">  // 即 Person.prototype.getName = function() &#123; &#125;</span><br><span class="line">  // 下面可以简写为 getName() &#123;...&#125;</span><br><span class="line">  getName = function () &#123;</span><br><span class="line">    console.log(&#x27;Person:&#x27;, this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Gamer extends Person &#123;</span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line">    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class="line">    super(name)</span><br><span class="line">    this.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const asuna = new Gamer(&#x27;Asuna&#x27;, 20)</span><br><span class="line">asuna.getName() // 成功访问到父类的方法</span><br></pre></td></tr></table></figure><p>利用babel工具进行转换，我们会发现extends实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式</p><p>#三、总结<br>下面以一张图作为总结<br><img src="https://static.vue-js.com/0df74700-731c-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>通过Object.create 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends 的语法糖和寄生组合继承的方式基本类似</p>]]></content>
    
    
    <summary type="html">继承（inheritance）是面向对象软件技术当中的一个概念。</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型和原型链 有什么特点？</title>
    <link href="http://example.com/2018/03/13/%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/"/>
    <id>http://example.com/2018/03/13/%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/</id>
    <published>2018-03-13T14:30:00.000Z</published>
    <updated>2022-10-06T10:05:12.399Z</updated>
    
    <content type="html"><![CDATA[<p>一、原型<br>JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p><p>准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的prototype属性上，而非实例对象本身</p><p>下面举个例子：</p><p>函数可以有属性。 每个函数都有一个特殊的属性叫作原型prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;&#125;</span><br><span class="line">console.log( doSomething.prototype );</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    constructor: ƒ doSomething(),</span><br><span class="line">    __proto__: &#123;</span><br><span class="line">        constructor: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个对象，就是大家常说的原型对象</p><p>可以看到，原型对象有一个自有属性constructor，这个属性指向该函数，如下图关系展示<br><img src="https://static.vue-js.com/56d87250-725e-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>二、原型链<br>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p><p>在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p><p>下面举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = 18;</span><br><span class="line">    this.sayName = function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二步 创建实例</span><br><span class="line">var person = new Person(&#x27;person&#x27;)</span><br></pre></td></tr></table></figure><p>根据代码，我们可以得到下图<br><img src="https://static.vue-js.com/60825aa0-725e-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>下面分析一下：</p><p>构造函数Person存在原型对象Person.prototype</p><p>构造函数生成实例对象person，person的__proto__指向构造函数Person原型对象</p><p>Person.prototype.<strong>proto</strong> 指向内置对象，因为 Person.prototype 是个对象，默认是由 Object函数作为类创建的，而 Object.prototype 为内置对象</p><p>Person.<strong>proto</strong> 指向内置匿名函数 anonymous，因为 Person 是个函数对象，默认由 Function 作为类创建</p><p>Function.prototype 和 Function.__proto__同时指向内置匿名函数 anonymous，这样原型链的终点就是 null</p><p>#三、总结<br>下面首先要看几个概念：</p><p>__proto__作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的</p><p><img src="https://static.vue-js.com/6a742160-725e-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>每个对象的__proto__都是指向它的构造函数的原型对象prototype的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.__proto__ === Person.prototype</span><br></pre></td></tr></table></figure><p>构造函数是一个函数对象，是通过 Function构造器产生的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.__proto__ === Function.prototype</span><br></pre></td></tr></table></figure><p>原型对象本身是一个普通对象，而普通对象的构造函数都是Object</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.__proto__ === Object.prototype</span><br></pre></td></tr></table></figure><p>刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function构造产生的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.__proto__ === Function.prototype</span><br></pre></td></tr></table></figure><p>Object的原型对象也有__proto__属性指向null，null是原型链的顶端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.__proto__ === nul</span><br></pre></td></tr></table></figure><p>下面作出总结：</p><p>一切对象都是继承自Object对象，Object 对象直接继承根源对象null</p><p>一切的函数对象（包括 Object 对象），都是继承自 Function 对象</p><p>Object 对象直接继承自 Function 对象</p><p>Function对象的__proto__会指向自己的原型对象，最终还是继承自Object对象</p>]]></content>
    
    
    <summary type="html">JavaScript原型和原型链</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>说说你对闭包的理解？闭包使用场景</title>
    <link href="http://example.com/2018/03/05/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://example.com/2018/03/05/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2018-03-05T13:30:00.000Z</published>
    <updated>2022-10-06T08:08:23.551Z</updated>
    
    <content type="html"><![CDATA[<p>一、是什么<br>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p><p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域</p><p>在 JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁</p><p>下面给出一个简单的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function init() &#123;</span><br><span class="line">    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量</span><br><span class="line">    function displayName() &#123; // displayName() 是内部函数，一个闭包</span><br><span class="line">        alert(name); // 使用了父函数中声明的变量</span><br><span class="line">    &#125;</span><br><span class="line">    displayName();</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure><p>displayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量</p><p>#二、使用场景<br>任何闭包的使用场景都离不开这两点：</p><p>创建私有变量<br>延长变量的生命周期<br>一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</p><p>下面举个例子：</p><p>在页面上添加一些可以调整字号的按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function makeSizer(size) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    document.body.style.fontSize = size + &#x27;px&#x27;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var size12 = makeSizer(12);</span><br><span class="line">var size14 = makeSizer(14);</span><br><span class="line">var size16 = makeSizer(16);</span><br><span class="line"></span><br><span class="line">document.getElementById(&#x27;size-12&#x27;).onclick = size12;</span><br><span class="line">document.getElementById(&#x27;size-14&#x27;).onclick = size14;</span><br><span class="line">document.getElementById(&#x27;size-16&#x27;).onclick = size16;</span><br></pre></td></tr></table></figure><p>柯里化函数<br>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 假设我们有一个求长方形面积的函数</span><br><span class="line">function getArea(width, height) &#123;</span><br><span class="line">    return width * height</span><br><span class="line">&#125;</span><br><span class="line">// 如果我们碰到的长方形的宽老是10</span><br><span class="line">const area1 = getArea(10, 20)</span><br><span class="line">const area2 = getArea(10, 30)</span><br><span class="line">const area3 = getArea(10, 40)</span><br><span class="line"></span><br><span class="line">// 我们可以使用闭包柯里化这个计算面积的函数</span><br><span class="line">function getArea(width) &#123;</span><br><span class="line">    return height =&gt; &#123;</span><br><span class="line">        return width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getTenWidthArea = getArea(10)</span><br><span class="line">// 之后碰到宽度为10的长方形就可以这样计算面积</span><br><span class="line">const area1 = getTenWidthArea(20)</span><br><span class="line"></span><br><span class="line">// 而且如果遇到宽度偶尔变化也可以轻松复用</span><br><span class="line">const getTwentyWidthArea = getArea(20)</span><br></pre></td></tr></table></figure><p>使用闭包模拟私有方法<br>在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法</p><p>下面举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var Counter = (function() &#123;</span><br><span class="line">  var privateCounter = 0;</span><br><span class="line">  function changeBy(val) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    increment: function() &#123;</span><br><span class="line">      changeBy(1);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: function() &#123;</span><br><span class="line">      changeBy(-1);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var Counter1 = makeCounter();</span><br><span class="line">var Counter2 = makeCounter();</span><br><span class="line">console.log(Counter1.value()); /* logs 0 */</span><br><span class="line">Counter1.increment();</span><br><span class="line">Counter1.increment();</span><br><span class="line">console.log(Counter1.value()); /* logs 2 */</span><br><span class="line">Counter1.decrement();</span><br><span class="line">console.log(Counter1.value()); /* logs 1 */</span><br><span class="line">console.log(Counter2.value()); /* logs 0 */</span><br></pre></td></tr></table></figure><p>上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式</p><p>两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量</p><p>#其他<br>例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期</p><p>#三、注意事项<br>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响</p><p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。</p><p>原因在于每个对象的创建，方法都会被重新赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function MyObject(name, message) &#123;</span><br><span class="line">  this.name = name.toString();</span><br><span class="line">  this.message = message.toString();</span><br><span class="line">  this.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  this.getMessage = function() &#123;</span><br><span class="line">    return this.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function MyObject(name, message) &#123;</span><br><span class="line">  this.name = name.toString();</span><br><span class="line">  this.message = message.toString();</span><br><span class="line">&#125;</span><br><span class="line">MyObject.prototype.getName = function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">MyObject.prototype.getMessage = function() &#123;</span><br><span class="line">  return this.message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
