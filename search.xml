<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>diff算法实现</title>
      <link href="/2018/06/20/diff/"/>
      <url>/2018/06/20/diff/</url>
      
        <content type="html"><![CDATA[<p>diff算法实现</p><ol><li>为什么要用Diff算法</li></ol><p>由于在浏览器中操作DOM是很昂贵的，频繁的操作DOM，会产生一定的性能问题，这就是虚拟DOM的产生原因。虚拟DOM本质上是JavaScript对象，是对真实DOM的抽象状态变更时，记录新树与旧树的差异，最后把差异更新到真正的DOM中。</p><p>即使使用了Virtual DOM来进行真实DOM的渲染，在页面更新的时候，也不能全量地将整颗Virtual DOM进行渲染，而是去渲染改变的部分，这时候就需要一个计算Virtual DOM树改变部分的算法了，这个算法就是Diff算法。</p><p>diff算法的作用：用来修改DOM的一小段，不会引起dom树的重绘</p><ol start="2"><li>传统的Diff算法</li></ol><p>传统的Diff算法通过循环递归对节点进行比较，然后判断每个节点的状态以及要做的操作（add，remove，change），最后 根据Virtual DOM进行DOM的渲染。</p><p>传统Diff算法的复杂度为O(n^3)，这个复杂度相对来说还是较高的。后来React开发者提供了一种复杂度仅为O(n) 的Diff算法。</p><ol start="3"><li>更高效的Diff算法</li></ol><p>React的开发者结合Web界面的特点做出了两个大胆的假设，使得Diff算法复杂度直接从O(n^3)降低到O(n)，假设如下：</p><p>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</p><p>基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)</p><p><strong>同层比较</strong><br>新的Diff算法是逐层进行比较，只比较同一层次的节点，不会跨层次比较，大大降低了复杂度</p><p><strong>不同类型节点的比较</strong><br>如果发现新旧两个节点类型不同时，Diff算法会直接删除旧的节点及其子节点并插入新的节点，这是由于前面提出的不同组件产生的DOM结构一般是不同的，所以可以不用浪费时间去比较。注意的是，删除节点意味着彻底销毁该节点，并不会将该节点去与后面的节点相比较。</p><p><strong>相同类型节点的比较</strong><br>若是两个节点类型相同时，Diff算法会重新设置该节点的属性，从而实现节点的更新。</p><p><strong>列表节点的比较</strong><br>列表节点的操作一般包括添加、删除和排序，列表节点需要我们给它一个key才能进行高效的比较。</p><p>4.Vue Diff算法的实现</p><p>了解了Diff算法的大体思路后，我们回过头来看下Vue中的Diff算法是如何实现的。</p><p>Vue的Diff算法与上面的思路大体相似，只比较同级的节点，若找不到与新节点类型相同的节点，则插入一个新节点，若有相同类型的节点则进行节点属性的更新，最后删除新节点列表中不包含的旧节点。具体的实现在vue源码的src/core/vdom/patch.js中的updateChildren方法中，由于代码较长，下面简单说一下整个的比较流程。</p><p>如上图，有一组新旧节点数组before：[A, B, C, D]、after：[E, C, F, G]，我们设置了四个哨兵节点，oldStartIdx、newStartIdx、oldEndIdx、newEndIdx分别指向新旧节点数组的起始下标和开始下标，值为0,0,3,3；oldStartVnode，newStartVnode，oldEndVnode，newEndVnode则分别指向了before和after节点列表中对应哨兵节点下标的值，值为before[oldStartVnode],after[newStartIdx],before[oldEndIdx],after[newEndIdx]。</p><p><strong>Diff</strong><br>当哨兵满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx的条件的时候，我们会循环进行一系列节点之间的比较。</p><p><strong>优先判断</strong><br>我们首先对上面声明的各个节点进行一些优先级较高的判断。</p><p>判断1：oldStartVnode是否为空，若为true则oldStartIdx向后移动，继续下一个节点的判断。判断代码如下：</p><p>判断2：oldEndVnode是否为空，若为true则oldEndIdx向前移动。判断代码如下：</p><p>判断3：使用 sameVnode判断before和after未判断的头节点是否为相同节点，若为true，则按照上面思路说的，对相同类型节点进行节点的属性的更新并修改哨兵位置。</p><p>判断4：使用上一步相同的方法对oldEndVnode和newEndVnode进行判断。并执行相同的更新操作。</p><p>判断5：使用sameVNode判断旧列表的头节点和新列表的尾节点进行判断，<br>sameVnode(oldStartVnode, newEndVnode)，若为true，更新相同节点，若该节点可以移动在真实DOM中将oldStartVnode，放到真实节点列表的最后。</p><p>判断6：使用sameVnode比较旧列表的尾节点和新列表的头节点，若为true，和上面一样，更新相同节点，将oldEndVnode放到真实节点列表的最开始。</p><p>通过这一系列的优先判断条件，一方面对于一些不需要做移动的DOM可以得到快速处理，另一方面使待处理节点变少，缩小了后续操作的处理范围，可以更快地完成同级节点的对比。</p><p>若节点不满足上面的所有判断，则会进入到最后一个条件分支，判断7：</p><p><strong>循环结束</strong><br>最后当oldStartIdx &gt; oldEndIdx || newStartIdx &gt; newEndIdx，也就是新或旧节点数组有一个被查找完之后则退出判断循环。当循环结束时，旧节点数组中剩下的节点即为要删除的节点，新节点数组中剩下的即为要新增的节点。只需要进行简单的新增和删除操作即可，代码如下：</p><p>经历过了这么多的判断之后，就完成了同级节点之间的Diff比较。</p><p><strong>就地复用</strong><br>在Diff中会使用到一种就地复用的策略。就地复用是指Vue会尽可能复用之前的DOM，尽可能不发生DOM的移动。</p><p>Vue判断新旧节点是否为相同节点（也就是上面的sameVnode方法），这个相同节点的意思并不是两个完全相同的节点，实际上它仅判断是否为同类节点（同类节点为类型相同且节点数据一致，如前后两个span，span标签上的属性没有改变，但是里面的内容变了，这样就算作同类节点），如果是同类节点，那么Vue会直接复用旧DOM节点，只要更新节点中的内容即可。这样可以大大减少列表中节点的移动操作。</p><p><strong>总结</strong><br>Vue中的Diff算法采用了React相似的思路，都是同层节点进行比较，在比较的过程中，使用了一些优先判断和就地复用策略，提高了Diff算法的效率。</p><p><strong>那么在面试工程中，可以怎么组织语言呢？</strong></p><p>答：diff算法的作用：用来修改DOM的一小段，不会引起dom树的重绘<br>diff算法的实现原理：diff算法将虚拟DOM的某个节点数据改变后生成新的的node节点与旧节点进行比较，并替换为新的节点，具体过程就是调用Patch方法，比较新旧节点，一边比较一边给真实DOM打补丁进行替换<br>简单来说，diff算法有以下过程<br>同级比较，再比较子节点<br>如果节点类型不同，直接干掉前面的节点，再创建并插入新节点，不会再比较这个节点以后的子节点。<br>（先判断一方有子节点一方 没有子节点的情况(如果新的children没有子节点，将旧的节点移除)）<br>比较都有子节点的情况(核心diff)<br>递归比较子节点<br>正常diff两个树的时间复杂度是O(n^3)， 但实际情况下我们很少会进行跨层级的移动DOM，所以vue将diff进行了优化，从O(n^3)–&gt;O(n)，只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较。<br>Vue2的核心diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助Key值找到可复用的节点，再进行相关操作。<br>新旧children中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的，需要在新旧children的节点中保存映射关系，以便能够在旧children的节点中找到可复用的节点。key也就是children中节点的唯一标识。<br>相比React的diff算法，同样情况下可以减少移动节点的次数，减少不必要的性能损耗，更加的优雅。<br>Vue3.x借鉴了ivi算法和inferno算法<br>在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升(实际的实现可以结合Vue3.x的源码看)<br>该算法中还运用了动态规划的思想求解最长递归子序列</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax原理是什么</title>
      <link href="/2018/04/27/ajax%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/ajax%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2018/04/27/ajax%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/ajax%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>一、是什么<br>AJAX全称(Async Javascript and XML)</p><p>即异步的JavaScript 和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页</p><p>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面</p><p>流程图如下：<br><img src="https://static.vue-js.com/af42de10-7b2a-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>下面举个例子：</p><p>领导想找小李汇报一下工作，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作</p><p>Ajax请求数据流程与“领导想找小李汇报一下工作”类似，上述秘书就相当于XMLHttpRequest对象，领导相当于浏览器，响应数据相当于小李</p><p>浏览器可以发送HTTP请求后，接着做其他事情，等收到XHR返回来的数据再进行操作</p><p>#二、实现过程<br>实现 Ajax异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p><p>创建 Ajax的核心对象 XMLHttpRequest对象</p><p>通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接</p><p>构建请求所需的数据内容，并通过XMLHttpRequest 对象的 send() 方法发送给服务器端</p><p>通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态</p><p>接受并处理服务端向客户端响应的数据结果</p><p>将处理结果更新到 HTML页面中</p><p>#创建XMLHttpRequest对象<br>通过XMLHttpRequest() 构造函数用于初始化一个 XMLHttpRequest 实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br></pre></td></tr></table></figure><p>与服务器建立连接<br>通过 XMLHttpRequest 对象的 open() 方法与服务器建立连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(method, url, [async][, user][, password])</span><br></pre></td></tr></table></figure><p>参数说明：<br>method：表示当前的请求方式，常见的有GET、POST<br>url：服务端地址<br>async：布尔值，表示是否异步执行操作，默认为true<br>user: 可选的用户名用于认证用途；默认为<code>null password: 可选的密码用于认证用途，默认为</code>null<br>#给服务端发送数据<br>通过 XMLHttpRequest 对象的 send() 方法，将客户端页面的数据发送给服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send([body])</span><br></pre></td></tr></table></figure><p>body: 在 XHR 请求中要发送的数据体，如果不传递数据则为 null</p><p>如果使用GET请求发送数据的时候，需要注意如下：</p><p>将请求数据添加到open()方法中的url地址中<br>发送请求数据中的send()方法中参数设置为null<br>#绑定onreadystatechange事件<br>onreadystatechange 事件用于监听服务器端的通信状态，主要监听的属性为XMLHttpRequest.readyState ,</p><p>关于XMLHttpRequest.readyState属性有五个状态，如下图显示</p><p><img src="https://static.vue-js.com/9782fc90-7b31-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>只要 readyState属性值一变化，就会触发一次 readystatechange 事件</p><p>XMLHttpRequest.responseText属性用于接收服务器端的响应结果</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const request = new XMLHttpRequest()</span><br><span class="line">request.onreadystatechange = function(e)&#123;</span><br><span class="line">    if(request.readyState === 4)&#123; // 整个请求过程完毕</span><br><span class="line">        if(request.status &gt;= 200 &amp;&amp; request.status &lt;= 300)&#123;</span><br><span class="line">            console.log(request.responseText) // 服务端返回的结果</span><br><span class="line">        &#125;else if(request.status &gt;=400)&#123;</span><br><span class="line">            console.log(&quot;错误信息：&quot; + request.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">request.open(&#x27;POST&#x27;,&#x27;http://xxxx&#x27;)</span><br><span class="line">request.send()</span><br></pre></td></tr></table></figure><p>三、封装<br>通过上面对XMLHttpRequest对象的了解，下面来封装一个简单的ajax请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//封装一个ajax请求</span><br><span class="line">function ajax(options) &#123;</span><br><span class="line">    //创建XMLHttpRequest对象</span><br><span class="line">    const xhr = new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //初始化参数的内容</span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.type = (options.type || &#x27;GET&#x27;).toUpperCase()</span><br><span class="line">    options.dataType = options.dataType || &#x27;json&#x27;</span><br><span class="line">    const params = options.data</span><br><span class="line"></span><br><span class="line">    //发送请求</span><br><span class="line">    if (options.type === &#x27;GET&#x27;) &#123;</span><br><span class="line">        xhr.open(&#x27;GET&#x27;, options.url + &#x27;?&#x27; + params, true)</span><br><span class="line">        xhr.send(null)</span><br><span class="line">    &#125; else if (options.type === &#x27;POST&#x27;) &#123;</span><br><span class="line">        xhr.open(&#x27;POST&#x27;, options.url, true)</span><br><span class="line">        xhr.send(params)</span><br><span class="line"></span><br><span class="line">    //接收请求</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        if (xhr.readyState === 4) &#123;</span><br><span class="line">            let status = xhr.status</span><br><span class="line">            if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123;</span><br><span class="line">                options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                options.fail &amp;&amp; options.fail(status)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">    type: &#x27;post&#x27;,</span><br><span class="line">    dataType: &#x27;json&#x27;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    url: &#x27;https://xxxx&#x27;,</span><br><span class="line">    success: function(text,xml)&#123;//请求成功后的回调函数</span><br><span class="line">        console.log(text)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: function(status)&#123;////请求失败后的回调函数</span><br><span class="line">        console.log(status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说new操作符具体干了什么</title>
      <link href="/2018/04/20/%E8%AF%B4%E8%AF%B4new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/%E8%AF%B4%E8%AF%B4new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2018/04/20/%E8%AF%B4%E8%AF%B4new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/%E8%AF%B4%E8%AF%B4new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>一、是什么<br>在JavaScript中，new操作符用于创建一个给定构造函数的实例对象</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">const person1 = new Person(&#x27;Tom&#x27;, 20)</span><br><span class="line">console.log(person1)  // Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br><span class="line">t.sayName() // &#x27;Tom&#x27;</span><br></pre></td></tr></table></figure><p>从上面可以看到：</p><p>new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性<br>new 通过构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）<br>现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Test(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  return 1</span><br><span class="line">&#125;</span><br><span class="line">const t = new Test(&#x27;xxx&#x27;)</span><br><span class="line">console.log(t.name) // &#x27;xxx&#x27;</span><br></pre></td></tr></table></figure><p>可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用</p><p>下面在构造函数中返回一个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Test(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  console.log(this) // Test &#123; name: &#x27;xxx&#x27; &#125;</span><br><span class="line">  return &#123; age: 26 &#125;</span><br><span class="line">&#125;</span><br><span class="line">const t = new Test(&#x27;xxx&#x27;)</span><br><span class="line">console.log(t) // &#123; age: 26 &#125;</span><br><span class="line">console.log(t.name) // &#x27;undefined&#x27;</span><br></pre></td></tr></table></figure><p>二、流程<br>从上面介绍中，我们可以看到new关键字主要做了以下的工作：</p><p>创建一个新的对象obj</p><p>将对象与构建函数通过原型链连接起来</p><p>将构建函数中的this绑定到新建的对象obj上</p><p>根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">const person1 = new Person(&#x27;Tom&#x27;, 20)</span><br><span class="line">console.log(person1)  // Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span><br><span class="line">t.sayName() // &#x27;Tom&#x27;</span><br></pre></td></tr></table></figure><p>流程图如下：<br><img src="https://static.vue-js.com/b429b990-7a39-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>三、手写new操作符<br>现在我们已经清楚地掌握了new的执行过程</p><p>那么我们就动手来实现一下new</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function mynew(Func, ...args) &#123;</span><br><span class="line">    // 1.创建一个新对象</span><br><span class="line">    const obj = &#123;&#125;</span><br><span class="line">    // 2.新对象原型指向构造函数原型对象</span><br><span class="line">    obj.__proto__ = Func.prototype</span><br><span class="line">    // 3.将构建函数的this指向新对象</span><br><span class="line">    let result = Func.apply(obj, args)</span><br><span class="line">    // 4.根据返回值判断</span><br><span class="line">    return result instanceof Object ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function mynew(func, ...args) &#123;</span><br><span class="line">    const obj = &#123;&#125;</span><br><span class="line">    obj.__proto__ = func.prototype</span><br><span class="line">    let result = func.apply(obj, args)</span><br><span class="line">    return result instanceof Object ? result : obj</span><br><span class="line">&#125;</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = mynew(Person, &quot;huihui&quot;, 123)</span><br><span class="line">console.log(p) // Person &#123;name: &quot;huihui&quot;, age: 123&#125;</span><br><span class="line">p.say() // huihui</span><br></pre></td></tr></table></figure><p>可以发现，代码虽然很短，但是能够模拟实现new</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释下什么是事件代理及应用场景</title>
      <link href="/2018/04/16/%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2018/04/16/%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>一、是什么<br>事件代理，俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素</p><p>前面讲到，事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件委托就是在冒泡阶段完成</p><p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素</p><p>当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p><p>下面举个例子：</p><p>比如一个宿舍的同学同时快递到了，一种笨方法就是他们一个个去领取</p><p>较优方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个同学</p><p>在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM元素，而出去统一领取快递的宿舍长就是代理的元素</p><p>所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个</p><p>#二、应用场景<br>如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 3&lt;/li&gt;</span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取目标元素</span><br><span class="line">const lis = document.getElementsByTagName(&quot;li&quot;)</span><br><span class="line">// 循环遍历绑定事件</span><br><span class="line">for (let i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    lis[i].onclick = function(e)&#123;</span><br><span class="line">        console.log(e.target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就可以事件委托，把点击事件绑定在父级元素ul上面，然后执行事件的时候再去匹配目标元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 给父层元素绑定事件</span><br><span class="line">document.getElementById(&#x27;list&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    // 兼容性处理</span><br><span class="line">    var event = e || window.event;</span><br><span class="line">    var target = event.target || event.srcElement;</span><br><span class="line">    // 判断是否匹配目标元素</span><br><span class="line">    if (target.nodeName.toLocaleLowerCase === &#x27;li&#x27;) &#123;</span><br><span class="line">        console.log(&#x27;the content is: &#x27;, target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件</p><p>但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件</p><p>如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的</p><p>举个例子：</p><p>下面html结构中，点击input可以动态添加元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;btn&quot; value=&quot;添加&quot; /&gt;</span><br><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;item 3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;item 4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>使用事件委托</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const oBtn = document.getElementById(&quot;btn&quot;);</span><br><span class="line">const oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">const num = 4;</span><br><span class="line"></span><br><span class="line">//事件委托，添加的子元素也有事件</span><br><span class="line">oUl.onclick = function (ev) &#123;</span><br><span class="line">    ev = ev || window.event;</span><br><span class="line">    const target = ev.target || ev.srcElement;</span><br><span class="line">    if (target.nodeName.toLowerCase() == &#x27;li&#x27;) &#123;</span><br><span class="line">        console.log(&#x27;the content is: &#x27;, target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//添加新节点</span><br><span class="line">oBtn.onclick = function () &#123;</span><br><span class="line">    num++;</span><br><span class="line">    const oLi = document.createElement(&#x27;li&#x27;);</span><br><span class="line">    oLi.innerHTML = `item $&#123;num&#125;`;</span><br><span class="line">    oUl.appendChild(oLi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的</p><p>#三、总结<br>适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress</p><p>从上面应用场景中，我们就可以看到使用事件委托存在两大优点：</p><p>减少整个页面所需的内存，提升整体性能<br>动态绑定，减少重复工作<br>但是使用事件委托也是存在局限性：</p><p>focus、blur这些事件没有事件冒泡机制，所以无法进行委托绑定事件</p><p>mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</p><p>如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeof 与 instanceof 区别</title>
      <link href="/2018/04/07/%E5%8C%BA%E5%88%AB/%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/04/07/%E5%8C%BA%E5%88%AB/%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>一、typeof<br>typeof 操作符返回一个字符串，表示未经计算的操作数的类型</p><p>使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof operand</span><br><span class="line">typeof(operand)</span><br></pre></td></tr></table></figure><p>operand表示对象或原始值的表达式，其类型将被返回<br>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &#x27;number&#x27;</span><br><span class="line">typeof &#x27;1&#x27; // &#x27;string&#x27;</span><br><span class="line">typeof undefined // &#x27;undefined&#x27;</span><br><span class="line">typeof true // &#x27;boolean&#x27;</span><br><span class="line">typeof Symbol() // &#x27;symbol&#x27;</span><br><span class="line">typeof null // &#x27;object&#x27;</span><br><span class="line">typeof [] // &#x27;object&#x27;</span><br><span class="line">typeof &#123;&#125; // &#x27;object&#x27;</span><br><span class="line">typeof console // &#x27;object&#x27;</span><br><span class="line">typeof console.log // &#x27;function&#x27;</span><br></pre></td></tr></table></figure><p>从上面例子，前6个都是基础数据类型。虽然typeof null为object，但这只是JavaScript 存在的一个悠久 Bug，不代表null就是引用数据类型，并且null本身也不是对象</p><p>所以，null在 typeof之后返回的是有问题的结果，不能作为判断null的方法。如果你需要在 if 语句中判断是否为 null，直接通过===null来判断就好</p><p>同时，可以发现引用类型数据，用typeof来判断的话，除了function会被识别出来之外，其余的都输出object</p><p>如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a)， 若a未声明，则报错)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(typeof a != &#x27;undefined&#x27;)&#123;</span><br><span class="line">    //变量存在</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、instanceof<br>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p><p>使用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object instanceof constructor</span><br></pre></td></tr></table></figure><p>object为实例对象，constructor为构造函数</p><p>构造函数通过new可以实例对象，instanceof能判断这个对象是否是之前那个构造函数生成的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义构建函数</span><br><span class="line">let Car = function() &#123;&#125;</span><br><span class="line">let benz = new Car()</span><br><span class="line">benz instanceof Car // true</span><br><span class="line">let car = new String(&#x27;xxx&#x27;)</span><br><span class="line">car instanceof String // true</span><br><span class="line">let str = &#x27;xxx&#x27;</span><br><span class="line">str instanceof String // false</span><br></pre></td></tr></table></figure><p>关于instanceof的实现原理，可以参考下面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">    // 这里先用typeof来判断基础数据类型，如果是，直接返回false</span><br><span class="line">    if(typeof left !== &#x27;object&#x27; || left === null) return false;</span><br><span class="line">    // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span><br><span class="line">    let proto = Object.getPrototypeOf(left);</span><br><span class="line">    while(true) &#123;                  </span><br><span class="line">        if(proto === null) return false;</span><br><span class="line">        if(proto === right.prototype) return true;//找到相同原型对象，返回true</span><br><span class="line">        proto = Object.getPrototypeof(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是顺着原型链去找，直到找到相同的原型对象，返回true，否则为false</p><p>#三、区别<br>typeof与instanceof都是判断数据类型的方法，区别如下：</p><p>typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值</p><p>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</p><p>而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断</p><p>可以看到，上述两种方法都有弊端，并不能满足所有场景的需求</p><p>如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]”的字符串</p><p>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString(&#123;&#125;)       // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok</span><br><span class="line">Object.prototype.toString.call(1)    // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&#x27;1&#x27;)  // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(true)  // &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;)  // &quot;[object Function]&quot;</span><br><span class="line">Object.prototype.toString.call(null)   //&quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(/123/g)    //&quot;[object RegExp]&quot;</span><br><span class="line">Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot;</span><br><span class="line">Object.prototype.toString.call([])       //&quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(document)  //&quot;[object HTMLDocument]&quot;</span><br><span class="line">Object.prototype.toString.call(window)   //&quot;[object Window]&quot;</span><br></pre></td></tr></table></figure><p>了解了toString的基本用法，下面就实现一个全局通用的数据类型判断方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getType(obj)&#123;</span><br><span class="line">  let type  = typeof obj;</span><br><span class="line">  if (type !== &quot;object&quot;) &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">    return type;</span><br><span class="line">  &#125;</span><br><span class="line">  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, &#x27;$1&#x27;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getType([])     // &quot;Array&quot; typeof []是object，因此toString返回</span><br><span class="line">getType(&#x27;123&#x27;)  // &quot;string&quot; typeof 直接返回</span><br><span class="line">getType(window) // &quot;Window&quot; toString返回</span><br><span class="line">getType(null)   // &quot;Null&quot;首字母大写，typeof null是object，需toString来判断</span><br><span class="line">getType(undefined)   // &quot;undefined&quot; typeof 直接返回</span><br><span class="line">getType()            // &quot;undefined&quot; typeof 直接返回</span><br><span class="line">getType(function()&#123;&#125;) // &quot;function&quot; typeof能判断，因此首字母小写</span><br><span class="line">getType(/123/g)      //&quot;RegExp&quot; toString返回</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈this对象的理解</title>
      <link href="/2018/03/22/%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/03/22/%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>一、定义<br>函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别</p><p>在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）</p><p>this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function baz() &#123;</span><br><span class="line">    // 当前调用栈是：baz</span><br><span class="line">    // 因此，当前调用位置是全局作用域</span><br><span class="line">    </span><br><span class="line">    console.log( &quot;baz&quot; );</span><br><span class="line">    bar(); // &lt;-- bar的调用位置</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">    // 当前调用栈是：baz --&gt; bar</span><br><span class="line">    // 因此，当前调用位置在baz中</span><br><span class="line">    </span><br><span class="line">    console.log( &quot;bar&quot; );</span><br><span class="line">    foo(); // &lt;-- foo的调用位置</span><br><span class="line">&#125;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    // 当前调用栈是：baz --&gt; bar --&gt; foo</span><br><span class="line">    // 因此，当前调用位置在bar中</span><br><span class="line">    </span><br><span class="line">    console.log( &quot;foo&quot; );</span><br><span class="line">&#125;</span><br><span class="line">baz(); // &lt;-- baz的调用位置</span><br></pre></td></tr></table></figure><p>同时，this在函数执行过程中，this一旦被确定了，就不可以再更改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20</span><br><span class="line">&#125;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  this = obj; // 修改this，运行后会报错</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>二、绑定规则<br>根据不同的使用场合，this有不同的值，主要分为下面几种情况：</p><p>默认绑定</p><p>隐式绑定</p><p>new绑定</p><p>显示绑定</p><p>#默认绑定<br>全局环境中定义person函数，内部使用this关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;Jenny&#x27;;</span><br><span class="line">function person() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">console.log(person());  //Jenny</span><br></pre></td></tr></table></figure><p>上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny</p><p>注意：</p><p>严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p><p>#隐式绑定<br>函数还可以作为某个对象的方法调用，这时this就指这个上级对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.x = 1;</span><br><span class="line">obj.m = test;</span><br><span class="line"></span><br><span class="line">obj.m(); // 1</span><br></pre></td></tr></table></figure><p>这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    a:10,</span><br><span class="line">    b:&#123;</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.a); //undefined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn();</span><br></pre></td></tr></table></figure><p>上述代码中，this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined</p><p>这里再举一种特殊情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    a:10,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:12,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.a); //undefined</span><br><span class="line">            console.log(this); //window</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var j = o.b.fn;</span><br><span class="line">j();</span><br></pre></td></tr></table></figure><p>此时this指向的是window，这里的大家需要记住，this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向window</p><p>#new绑定<br>通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">　this.x = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = new test();</span><br><span class="line">obj.x // 1</span><br></pre></td></tr></table></figure><p>上述代码之所以能过输出1，是因为new关键字改变了this的指向</p><p>这里再列举一些特殊情况：</p><p>new过程遇到return一个对象，此时this指向为返回的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn()  </span><br><span class="line">&#123;  </span><br><span class="line">    this.user = &#x27;xxx&#x27;;  </span><br><span class="line">    return &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line">var a = new fn();  </span><br><span class="line">console.log(a.user); //undefined</span><br></pre></td></tr></table></figure><p>如果返回一个简单类型的时候，则this指向实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn()  </span><br><span class="line">&#123;  </span><br><span class="line">    this.user = &#x27;xxx&#x27;;  </span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">var a = new fn;  </span><br><span class="line">console.log(a.user); //xxx</span><br></pre></td></tr></table></figure><p>注意的是null虽然也是对象，但是此时new仍然指向实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn()  </span><br><span class="line">&#123;  </span><br><span class="line">    this.user = &#x27;xxx&#x27;;  </span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">var a = new fn;  </span><br><span class="line">console.log(a.user); //xxx</span><br></pre></td></tr></table></figure><p>显示修改<br>apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">function test() &#123;</span><br><span class="line">　console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.x = 1;</span><br><span class="line">obj.m = test;</span><br><span class="line">obj.m.apply(obj) // 1</span><br></pre></td></tr></table></figure><p>关于apply、call、bind三者的区别，我们后面再详细说</p><p>#三、箭头函数<br>在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定）</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  sayThis: () =&gt; &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayThis(); // window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了</span><br><span class="line">const globalSay = obj.sayThis;</span><br><span class="line">globalSay(); // window 浏览器中的 global 对象</span><br></pre></td></tr></table></figure><p>虽然箭头函数的this能够在编译的时候就确定了this的指向，但也需要注意一些潜在的坑</p><p>下面举个例子：</p><p>绑定事件监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const button = document.getElementById(&#x27;mngb&#x27;);</span><br><span class="line">button.addEventListener(&#x27;click&#x27;, ()=&gt; &#123;</span><br><span class="line">    console.log(this === window) // true</span><br><span class="line">    this.innerHTML = &#x27;clicked button&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述可以看到，我们其实是想要this为点击的button，但此时this指向了window</p><p>包括在原型上添加方法时候，此时this指向window</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype.sayName = () =&gt; &#123;</span><br><span class="line">    console.log(this === window) //true</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">const cat = new Cat(&#x27;mm&#x27;);</span><br><span class="line">cat.sayName()</span><br></pre></td></tr></table></figure><p>同样的，箭头函数不能作为构建函数</p><p>#四、优先级<br>#隐式绑定 VS 显式绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    a: 3,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(); // 2</span><br><span class="line">obj2.foo(); // 3</span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2 ); // 3</span><br><span class="line">obj2.foo.call( obj1 ); // 2</span><br></pre></td></tr></table></figure><p>显然，显示绑定的优先级更高</p><p>#new绑定 VS 隐式绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">    this.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo( 2 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2, 3 );</span><br><span class="line">console.log( obj2.a ); // 3</span><br><span class="line"></span><br><span class="line">var bar = new obj1.foo( 4 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line">console.log( bar.a ); // 4</span><br></pre></td></tr></table></figure><p>可以看到，new绑定的优先级&gt;隐式绑定</p><p>#new绑定 VS 显式绑定<br>因为new和apply、call无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">    this.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.bind( obj1 );</span><br><span class="line">bar( 2 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line"></span><br><span class="line">var baz = new bar( 3 );</span><br><span class="line">console.log( obj1.a ); // 2</span><br><span class="line">console.log( baz.a ); // 3</span><br></pre></td></tr></table></figure><p>bar被绑定到obj1上，但是new bar(3) 并没有像我们预计的那样把obj1.a修改为3。但是，new修改了绑定调用bar()中的this</p><p>我们可认为new绑定优先级&gt;显式绑定</p><p>综上，new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript如何实现继承?</title>
      <link href="/2018/03/18/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/03/18/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>一、是什么<br>继承（inheritance）是面向对象软件技术当中的一个概念。</p><p>如果一个类别 B“继承自”另一个类别 A，就把这个 B 称为“A 的子类”，而把 A 称为“B 的父类别”也可以称“A 是 B 的超类”</p><p>继承的优点<br>继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码</p><p>在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能</p><p>虽然 JavaScript 并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富</p><p>关于继承，我们举个形象的例子：</p><p>定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">constructor(color,speed)&#123;</span><br><span class="line">this.color = color</span><br><span class="line">this.speed = speed</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 货车</span><br><span class="line">class Truck extends Car&#123;</span><br><span class="line">constructor(color,speed)&#123;</span><br><span class="line">super(color,speed)</span><br><span class="line">this.Container = true // 货箱</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性</p><p>在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Truck extends Car&#123;</span><br><span class="line">constructor(color,speed)&#123;</span><br><span class="line">super(color,speed)</span><br><span class="line">this.color = &quot;black&quot; //覆盖</span><br><span class="line">this.Container = true // 货箱</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系</p><p>#二、实现方式<br>下面给出 JavaScripy 常见的继承方式：</p><p>原型链继承</p><p>构造函数继承（借助 call）</p><p>组合继承</p><p>原型式继承</p><p>寄生式继承</p><p>寄生组合式继承</p><p>#原型链继承<br>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针</p><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">this.name = &#x27;parent1&#x27;;</span><br><span class="line">this.play = [1, 2, 3]</span><br><span class="line">&#125;</span><br><span class="line">function Child() &#123;</span><br><span class="line">this.type = &#x27;child2&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Child1.prototype = new Parent();</span><br><span class="line">console.log(new Child())</span><br></pre></td></tr></table></figure><p>上面代码看似没问题，实际存在潜在问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Child2();</span><br><span class="line">var s2 = new Child2();</span><br><span class="line">s1.play.push(4);</span><br><span class="line">console.log(s1.play, s2.play); // [1,2,3,4]</span><br></pre></td></tr></table></figure><p>改变 s1 的 play 属性，会发现 s2 也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的</p><p>#构造函数继承<br>借助 call 调用 Parent 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">this.name = &#x27;parent1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child()&#123;</span><br><span class="line">Parent1.call(this);</span><br><span class="line">this.type = &#x27;child&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let child = new Child();</span><br><span class="line">console.log(child); // 没问题</span><br><span class="line">console.log(child.getName()); // 会报错</span><br></pre></td></tr></table></figure><p>可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法</p><p>相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法</p><p>#组合继承<br>前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Parent3 () &#123;</span><br><span class="line">this.name = &#x27;parent3&#x27;;</span><br><span class="line">this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = function () &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function Child3() &#123;</span><br><span class="line">// 第二次调用 Parent3()</span><br><span class="line">Parent3.call(this);</span><br><span class="line">this.type = &#x27;child3&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第一次调用 Parent3()</span><br><span class="line">Child3.prototype = new Parent3();</span><br><span class="line">// 手动挂上构造器，指向自己的构造函数</span><br><span class="line">Child3.prototype.constructor = Child3;</span><br><span class="line">var s3 = new Child3();</span><br><span class="line">var s4 = new Child3();</span><br><span class="line">s3.play.push(4);</span><br><span class="line">console.log(s3.play, s4.play); // 不互相影响</span><br><span class="line">console.log(s3.getName()); // 正常输出&#x27;parent3&#x27;</span><br><span class="line">console.log(s4.getName()); // 正常输出&#x27;parent3&#x27;</span><br></pre></td></tr></table></figure><p>这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到 Parent3 执行了两次，造成了多构造一次的性能开销</p><p>#原型式继承<br>这里主要借助 Object.create 方法实现普通对象的继承</p><p>同样举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let parent4 = &#123;</span><br><span class="line">name: &quot;parent4&quot;,</span><br><span class="line">friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line">getName: function() &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let person4 = Object.create(parent4);</span><br><span class="line">person4.name = &quot;tom&quot;;</span><br><span class="line">person4.friends.push(&quot;jerry&quot;);</span><br><span class="line"></span><br><span class="line">let person5 = Object.create(parent4);</span><br><span class="line">person5.friends.push(&quot;lucy&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person4.name); // tom</span><br><span class="line">console.log(person4.name === person4.getName()); // true</span><br><span class="line">console.log(person5.name); // parent4</span><br><span class="line">console.log(person4.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span><br><span class="line">console.log(person5.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;]</span><br></pre></td></tr></table></figure><p>这种继承方式的缺点也很明显，因为Object.create方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能</p><p>#寄生式继承<br>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let parent5 = &#123;</span><br><span class="line">    name: &quot;parent5&quot;,</span><br><span class="line">    friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function clone(original) &#123;</span><br><span class="line">    let clone = Object.create(original);</span><br><span class="line">    clone.getFriends = function() &#123;</span><br><span class="line">        return this.friends;</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person5 = clone(parent5);</span><br><span class="line"></span><br><span class="line">console.log(person5.getName()); // parent5</span><br><span class="line">console.log(person5.getFriends()); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;]</span><br></pre></td></tr></table></figure><p>其优缺点也很明显，跟上面讲的原型式继承一样</p><p>#寄生组合式继承<br>寄生组合式继承，借助解决普通对象的继承问题的Object.create 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function clone (parent, child) &#123;</span><br><span class="line">    // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br><span class="line">    child.prototype = Object.create(parent.prototype);</span><br><span class="line">    child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Parent6() &#123;</span><br><span class="line">    this.name = &#x27;parent6&#x27;;</span><br><span class="line">    this.play = [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">Parent6.prototype.getName = function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function Child6() &#123;</span><br><span class="line">    Parent6.call(this);</span><br><span class="line">    this.friends = &#x27;child5&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clone(Parent6, Child6);</span><br><span class="line"></span><br><span class="line">Child6.prototype.getFriends = function () &#123;</span><br><span class="line">    return this.friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person6 = new Child6();</span><br><span class="line">console.log(person6); //&#123;friends:&quot;child5&quot;,name:&quot;child5&quot;,play:[1,2,3],__proto__:Parent6&#125;</span><br><span class="line">console.log(person6.getName()); // parent6</span><br><span class="line">console.log(person6.getFriends()); // child5</span><br></pre></td></tr></table></figure><p>可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题</p><p>文章一开头，我们是使用ES6 中的extends关键字直接实现 JavaScript的继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  // 原型方法</span><br><span class="line">  // 即 Person.prototype.getName = function() &#123; &#125;</span><br><span class="line">  // 下面可以简写为 getName() &#123;...&#125;</span><br><span class="line">  getName = function () &#123;</span><br><span class="line">    console.log(&#x27;Person:&#x27;, this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Gamer extends Person &#123;</span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line">    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class="line">    super(name)</span><br><span class="line">    this.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const asuna = new Gamer(&#x27;Asuna&#x27;, 20)</span><br><span class="line">asuna.getName() // 成功访问到父类的方法</span><br></pre></td></tr></table></figure><p>利用babel工具进行转换，我们会发现extends实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式</p><p>#三、总结<br>下面以一张图作为总结<br><img src="https://static.vue-js.com/0df74700-731c-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>通过Object.create 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends 的语法糖和寄生组合继承的方式基本类似</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型和原型链 有什么特点？</title>
      <link href="/2018/03/13/%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/"/>
      <url>/2018/03/13/%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>一、原型<br>JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p><p>准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的prototype属性上，而非实例对象本身</p><p>下面举个例子：</p><p>函数可以有属性。 每个函数都有一个特殊的属性叫作原型prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;&#125;</span><br><span class="line">console.log( doSomething.prototype );</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    constructor: ƒ doSomething(),</span><br><span class="line">    __proto__: &#123;</span><br><span class="line">        constructor: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个对象，就是大家常说的原型对象</p><p>可以看到，原型对象有一个自有属性constructor，这个属性指向该函数，如下图关系展示<br><img src="https://static.vue-js.com/56d87250-725e-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>二、原型链<br>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p><p>在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p><p>下面举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = 18;</span><br><span class="line">    this.sayName = function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二步 创建实例</span><br><span class="line">var person = new Person(&#x27;person&#x27;)</span><br></pre></td></tr></table></figure><p>根据代码，我们可以得到下图<br><img src="https://static.vue-js.com/60825aa0-725e-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>下面分析一下：</p><p>构造函数Person存在原型对象Person.prototype</p><p>构造函数生成实例对象person，person的__proto__指向构造函数Person原型对象</p><p>Person.prototype.<strong>proto</strong> 指向内置对象，因为 Person.prototype 是个对象，默认是由 Object函数作为类创建的，而 Object.prototype 为内置对象</p><p>Person.<strong>proto</strong> 指向内置匿名函数 anonymous，因为 Person 是个函数对象，默认由 Function 作为类创建</p><p>Function.prototype 和 Function.__proto__同时指向内置匿名函数 anonymous，这样原型链的终点就是 null</p><p>#三、总结<br>下面首先要看几个概念：</p><p>__proto__作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的</p><p><img src="https://static.vue-js.com/6a742160-725e-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>每个对象的__proto__都是指向它的构造函数的原型对象prototype的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.__proto__ === Person.prototype</span><br></pre></td></tr></table></figure><p>构造函数是一个函数对象，是通过 Function构造器产生的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.__proto__ === Function.prototype</span><br></pre></td></tr></table></figure><p>原型对象本身是一个普通对象，而普通对象的构造函数都是Object</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.__proto__ === Object.prototype</span><br></pre></td></tr></table></figure><p>刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function构造产生的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.__proto__ === Function.prototype</span><br></pre></td></tr></table></figure><p>Object的原型对象也有__proto__属性指向null，null是原型链的顶端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.__proto__ === nul</span><br></pre></td></tr></table></figure><p>下面作出总结：</p><p>一切对象都是继承自Object对象，Object 对象直接继承根源对象null</p><p>一切的函数对象（包括 Object 对象），都是继承自 Function 对象</p><p>Object 对象直接继承自 Function 对象</p><p>Function对象的__proto__会指向自己的原型对象，最终还是继承自Object对象</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说你对闭包的理解？闭包使用场景</title>
      <link href="/2018/03/05/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2018/03/05/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>一、是什么<br>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p><p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域</p><p>在 JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁</p><p>下面给出一个简单的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function init() &#123;</span><br><span class="line">    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量</span><br><span class="line">    function displayName() &#123; // displayName() 是内部函数，一个闭包</span><br><span class="line">        alert(name); // 使用了父函数中声明的变量</span><br><span class="line">    &#125;</span><br><span class="line">    displayName();</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure><p>displayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量</p><p>#二、使用场景<br>任何闭包的使用场景都离不开这两点：</p><p>创建私有变量<br>延长变量的生命周期<br>一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</p><p>下面举个例子：</p><p>在页面上添加一些可以调整字号的按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function makeSizer(size) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    document.body.style.fontSize = size + &#x27;px&#x27;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var size12 = makeSizer(12);</span><br><span class="line">var size14 = makeSizer(14);</span><br><span class="line">var size16 = makeSizer(16);</span><br><span class="line"></span><br><span class="line">document.getElementById(&#x27;size-12&#x27;).onclick = size12;</span><br><span class="line">document.getElementById(&#x27;size-14&#x27;).onclick = size14;</span><br><span class="line">document.getElementById(&#x27;size-16&#x27;).onclick = size16;</span><br></pre></td></tr></table></figure><p>柯里化函数<br>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 假设我们有一个求长方形面积的函数</span><br><span class="line">function getArea(width, height) &#123;</span><br><span class="line">    return width * height</span><br><span class="line">&#125;</span><br><span class="line">// 如果我们碰到的长方形的宽老是10</span><br><span class="line">const area1 = getArea(10, 20)</span><br><span class="line">const area2 = getArea(10, 30)</span><br><span class="line">const area3 = getArea(10, 40)</span><br><span class="line"></span><br><span class="line">// 我们可以使用闭包柯里化这个计算面积的函数</span><br><span class="line">function getArea(width) &#123;</span><br><span class="line">    return height =&gt; &#123;</span><br><span class="line">        return width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getTenWidthArea = getArea(10)</span><br><span class="line">// 之后碰到宽度为10的长方形就可以这样计算面积</span><br><span class="line">const area1 = getTenWidthArea(20)</span><br><span class="line"></span><br><span class="line">// 而且如果遇到宽度偶尔变化也可以轻松复用</span><br><span class="line">const getTwentyWidthArea = getArea(20)</span><br></pre></td></tr></table></figure><p>使用闭包模拟私有方法<br>在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法</p><p>下面举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var Counter = (function() &#123;</span><br><span class="line">  var privateCounter = 0;</span><br><span class="line">  function changeBy(val) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    increment: function() &#123;</span><br><span class="line">      changeBy(1);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: function() &#123;</span><br><span class="line">      changeBy(-1);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: function() &#123;</span><br><span class="line">      return privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var Counter1 = makeCounter();</span><br><span class="line">var Counter2 = makeCounter();</span><br><span class="line">console.log(Counter1.value()); /* logs 0 */</span><br><span class="line">Counter1.increment();</span><br><span class="line">Counter1.increment();</span><br><span class="line">console.log(Counter1.value()); /* logs 2 */</span><br><span class="line">Counter1.decrement();</span><br><span class="line">console.log(Counter1.value()); /* logs 1 */</span><br><span class="line">console.log(Counter2.value()); /* logs 0 */</span><br></pre></td></tr></table></figure><p>上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式</p><p>两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量</p><p>#其他<br>例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期</p><p>#三、注意事项<br>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响</p><p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。</p><p>原因在于每个对象的创建，方法都会被重新赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function MyObject(name, message) &#123;</span><br><span class="line">  this.name = name.toString();</span><br><span class="line">  this.message = message.toString();</span><br><span class="line">  this.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  this.getMessage = function() &#123;</span><br><span class="line">    return this.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function MyObject(name, message) &#123;</span><br><span class="line">  this.name = name.toString();</span><br><span class="line">  this.message = message.toString();</span><br><span class="line">&#125;</span><br><span class="line">MyObject.prototype.getName = function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">MyObject.prototype.getMessage = function() &#123;</span><br><span class="line">  return this.message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说你对作用域链的理解</title>
      <link href="/2018/02/02/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/02/02/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>一、作用域<br>作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合</p><p>换句话说，作用域决定了代码区块中变量和其他资源的可见性</p><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function myFunction() &#123;</span><br><span class="line">    let inVariable = &quot;函数内部变量&quot;;</span><br><span class="line">&#125;</span><br><span class="line">myFunction();//要先执行这个函数，否则根本不知道里面是啥</span><br><span class="line">console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined</span><br></pre></td></tr></table></figure><p>上述例子中，函数myFunction内部创建一个inVariable变量，当我们在全局访问这个变量的时候，系统会报错</p><p>这就说明我们在全局是无法获取到（闭包除外）函数内部的变量</p><p>我们一般将作用域分成：</p><p>全局作用域</p><p>函数作用域</p><p>块级作用域</p><p>#全局作用域<br>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量</span><br><span class="line">var greeting = &#x27;Hello World!&#x27;;</span><br><span class="line">function greet() &#123;</span><br><span class="line">  console.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &#x27;Hello World!&#x27;</span><br><span class="line">greet();</span><br></pre></td></tr></table></figure><p>函数作用域<br>函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function greet() &#123;</span><br><span class="line">  var greeting = &#x27;Hello World!&#x27;;</span><br><span class="line">  console.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &#x27;Hello World!&#x27;</span><br><span class="line">greet();</span><br><span class="line">// 报错： Uncaught ReferenceError: greeting is not defined</span><br><span class="line">console.log(greeting);</span><br></pre></td></tr></table></figure><p>可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域</p><p>#块级作用域<br>ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 块级作用域中的变量</span><br><span class="line">  let greeting = &#x27;Hello World!&#x27;;</span><br><span class="line">  var lang = &#x27;English&#x27;;</span><br><span class="line">  console.log(greeting); // Prints &#x27;Hello World!&#x27;</span><br><span class="line">&#125;</span><br><span class="line">// 变量 &#x27;English&#x27;</span><br><span class="line">console.log(lang);</span><br><span class="line">// 报错：Uncaught ReferenceError: greeting is not defined</span><br><span class="line">console.log(greeting);</span><br></pre></td></tr></table></figure><p>二、词法作用域<br>词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">function foo()&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">function bar()&#123;</span><br><span class="line">    var a = 3;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>上述代码改变成一张图<br><img src="https://static.vue-js.com/29fab3d0-718f-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>由于JavaScript遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出2</p><p>#三、作用域链<br>当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域</p><p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错</p><p>这里拿《你不知道的Javascript(上)》中的一张图解释：</p><p>把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域<br><img src="https://static.vue-js.com/33f9c100-718f-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止</p><p>下面代码演示下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var sex = &#x27;男&#x27;;</span><br><span class="line">function person() &#123;</span><br><span class="line">    var name = &#x27;张三&#x27;;</span><br><span class="line">    function student() &#123;</span><br><span class="line">        var age = 18;</span><br><span class="line">        console.log(name); // 张三</span><br><span class="line">        console.log(sex); // 男 </span><br><span class="line">    &#125;</span><br><span class="line">    student();</span><br><span class="line">    console.log(age); // Uncaught ReferenceError: age is not defined</span><br><span class="line">&#125;</span><br><span class="line">person();</span><br></pre></td></tr></table></figure><p>上述代码主要主要做了以下工作：</p><p>student函数内部属于最内层作用域，找不到name，向上一层作用域person函数内部找，找到了输出“张三”<br>student内部输出sex时找不到，向上一层作用域person函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男”<br>在person函数内部输出age时找不到，向上一层作用域找，即全局作用域，还是找不到则报错</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的常用方法有哪些？</title>
      <link href="/2017/12/29/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
      <url>/2017/12/29/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>一、操作方法<br>数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会</p><p>下面对数组常用的操作方法做一个归纳</p><p>#增<br>下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响</p><p>push()<br>unshift()<br>splice()<br>concat()<br>#push()<br>push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = []; // 创建一个数组</span><br><span class="line">let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项</span><br><span class="line">console.log(count) // 2</span><br></pre></td></tr></table></figure><p>unshift()<br>unshift()在数组开头添加任意多个值，然后返回新的数组长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = new Array(); // 创建一个数组</span><br><span class="line">let count = colors.unshift(&quot;red&quot;, &quot;green&quot;); // 从数组开头推入两项</span><br><span class="line">alert(count); // 2</span><br></pre></td></tr></table></figure><p>splice<br>传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">let removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;)</span><br><span class="line">console.log(colors) // red,yellow,orange,green,blue</span><br><span class="line">console.log(removed) // []</span><br></pre></td></tr></table></figure><p>concat()<br>首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">let colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);</span><br><span class="line">console.log(colors); // [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]</span><br><span class="line">console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span><br></pre></td></tr></table></figure><p>删<br>下面三种都会影响原数组，最后一项不影响原数组：</p><p>pop()<br>shift()<br>splice()<br>slice()<br>#pop()<br>pop() 方法用于删除数组的最后一项，同时减少数组的length 值，返回被删除的项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;]</span><br><span class="line">let item = colors.pop(); // 取得最后一项</span><br><span class="line">console.log(item) // green</span><br><span class="line">console.log(colors.length) // 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>shift()<br>shift()方法用于删除数组的第一项，同时减少数组的length 值，返回被删除的项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;]</span><br><span class="line">let item = colors.shift(); // 取得第一项</span><br><span class="line">console.log(item) // red</span><br><span class="line">console.log(colors.length) // 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>splice()<br>传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">let removed = colors.splice(0,1); // 删除第一项</span><br><span class="line">console.log(colors); // green,blue</span><br><span class="line">console.log(removed); // red，只有一个元素的数组</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>slice()<br>slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];</span><br><span class="line">let colors2 = colors.slice(1);</span><br><span class="line">let colors3 = colors.slice(1, 4);</span><br><span class="line">console.log(colors)   // red,green,blue,yellow,purple</span><br><span class="line">concole.log(colors2); // green,blue,yellow,purple</span><br><span class="line">concole.log(colors3); // green,blue,yellow</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改<br>即修改原来数组的内容，常用splice</p><p>#splice()<br>传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">let removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两个值，删除一个元素</span><br><span class="line">console.log(colors); // red,red,purple,blue</span><br><span class="line">console.log(removed); // green，只有一个元素的数组</span><br></pre></td></tr></table></figure><p>查<br>即查找元素，返回元素坐标或者元素值</p><p>indexOf()<br>includes()<br>find()<br>#indexOf()<br>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">numbers.indexOf(4) // 3</span><br></pre></td></tr></table></figure><p>includes()<br>返回要查找的元素在数组中的位置，找到返回true，否则false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">numbers.includes(4) // true</span><br></pre></td></tr></table></figure><p>find()<br>返回第一个匹配的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const people = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;Matt&quot;,</span><br><span class="line">        age: 27</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &quot;Nicholas&quot;,</span><br><span class="line">        age: 29</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">people.find((element, index, array) =&gt; element.age &lt; 28) // // &#123;name: &quot;Matt&quot;, age: 27&#125;</span><br></pre></td></tr></table></figure><p>二、排序方法<br>数组有两个方法可以用来对元素重新排序：</p><p>reverse()<br>sort()<br>reverse()<br>顾名思义，将数组元素方向反转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let values = [1, 2, 3, 4, 5];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values); // 5,4,3,2,1</span><br></pre></td></tr></table></figure><p>sort()<br>sort()方法接受一个比较函数，用于判断哪个值应该排在前面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function compare(value1, value2) &#123;</span><br><span class="line">    if (value1 &lt; value2) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (value1 &gt; value2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let values = [0, 1, 5, 10, 15];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); // 0,1,5,10,15</span><br></pre></td></tr></table></figure><p>三、转换方法<br>常见的转换方法有：</p><p>#join()<br>join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">alert(colors.join(&quot;,&quot;)); // red,green,blue</span><br><span class="line">alert(colors.join(&quot;||&quot;)); // red||green||blue</span><br></pre></td></tr></table></figure><p>四、迭代方法<br>常用来迭代数组的方法（都不改变原数组）有如下：</p><p>some()<br>every()<br>forEach()<br>filter()<br>map()<br>#some()<br>对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">let someResult = numbers.some((item, index, array) =&gt; item &gt; 2);</span><br><span class="line">console.log(someResult) // true</span><br></pre></td></tr></table></figure><p>every()<br>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2);</span><br><span class="line">console.log(everyResult) // false</span><br></pre></td></tr></table></figure><p>forEach()<br>对数组每一项都运行传入的函数，没有返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">numbers.forEach((item, index, array) =&gt; &#123;</span><br><span class="line">    // 执行某些操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>filter()<br>对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2);</span><br><span class="line">console.log(filterResult); // 3,4,5,4,3</span><br></pre></td></tr></table></figure><p>map()<br>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">let mapResult = numbers.map((item, index, array) =&gt; item * 2);</span><br><span class="line">console.log(mapResult) // 2,4,6,8,10,8,6,4,2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现单行／多行文本溢出的省略样式？</title>
      <link href="/2017/12/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%8C%EF%BC%8F%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E7%9C%81%E7%95%A5%E6%A0%B7%E5%BC%8F%EF%BC%9F/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%8C%EF%BC%8F%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E7%9C%81%E7%95%A5%E6%A0%B7%E5%BC%8F%EF%BC%9F/"/>
      <url>/2017/12/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%8C%EF%BC%8F%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E7%9C%81%E7%95%A5%E6%A0%B7%E5%BC%8F%EF%BC%9F/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%8C%EF%BC%8F%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E7%9C%81%E7%95%A5%E6%A0%B7%E5%BC%8F%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>一、前言<br>在日常开发展示页面，如果一段文本的数量过长，受制于元素宽度的因素，有可能不能完全显示，为了提高用户的使用体验，这个时候就需要我们把溢出的文本显示成省略号</p><p>对于文本的溢出，我们可以分成两种形式：</p><p>单行文本溢出<br>多行文本溢出<br>#二、实现方式<br>#单行文本溢出省略<br>理解也很简单，即文本在一行内显示，超出部分以省略号的形式展现</p><p>实现方式也很简单，涉及的css属性有：</p><p>text-overflow：规定当文本溢出时，显示省略符号来代表被修剪的文本<br>white-space：设置文字在一行显示，不能换行<br>overflow：文字长度超出限定宽度，则隐藏超出的内容<br>overflow设为hidden，普通情况用在块级元素的外层隐藏内部溢出元素，或者配合下面两个属性实现文本溢出省略</p><p>white-space:nowrap，作用是设置文本不换行，是overflow:hidden和text-overflow：ellipsis生效的基础</p><p>text-overflow属性值有如下：</p><p>clip：当对象内文本溢出部分裁切掉<br>ellipsis：当对象内文本溢出时显示省略标记（…）<br>text-overflow只有在设置了overflow:hidden和white-space:nowrap才能够生效的</p><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    p&#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        line-height: 40px;</span><br><span class="line">        width:400px;</span><br><span class="line">        height:40px;</span><br><span class="line">        border:1px solid red;</span><br><span class="line">        text-overflow: ellipsis;</span><br><span class="line">        white-space: nowrap;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p 这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本&lt;/p &gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://static.vue-js.com/bb3048e0-a0e9-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>可以看到，设置单行文本溢出较为简单，并且省略号显示的位置较好</p><p>#多行文本溢出省略<br>多行文本溢出的时候，我们可以分为两种情况：</p><p>基于高度截断<br>基于行数截断<br>#基于高度截断<br>#伪元素 + 定位<br>核心的css代码结构如下：</p><p>position: relative：为伪元素绝对定位<br>overflow: hidden：文本溢出限定的宽度就隐藏内容）<br>position: absolute：给省略号绝对定位<br>line-height: 20px：结合元素高度,高度固定的情况下,设定行高, 控制显示行数<br>height: 40px：设定当前元素高度<br>::after {} ：设置省略号样式<br>代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .demo &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        line-height: 20px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .demo::after &#123;</span><br><span class="line">        content: &quot;...&quot;;</span><br><span class="line">        position: absolute;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        padding: 0 20px 0 10px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/styl&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&#x27;demo&#x27;&gt;这是一段很长的文本&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>实现原理很好理解，就是通过伪元素绝对定位到行尾并遮住文字，再通过 overflow: hidden 隐藏多余文字</p><p>这种实现具有以下优点：</p><p>兼容性好，对各大主流浏览器有好的支持<br>响应式截断，根据不同宽度做出调整<br>一般文本存在英文的时候，可以设置word-break: break-all使一个单词能够在换行时进行拆分</p><p>#基于行数截断<br>纯css实现也非常简单，核心的css代码如下：</p><p>-webkit-line-clamp: 2：用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的WebKit属性）<br>display: -webkit-box：和1结合使用，将对象作为弹性伸缩盒子模型显示<br>-webkit-box-orient: vertical：和1结合使用 ，设置或检索伸缩盒对象的子元素的排列方式<br>overflow: hidden：文本溢出限定的宽度就隐藏内容<br>text-overflow: ellipsis：多行文本的情况下，用省略号“…”隐藏溢出范围的文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    p &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        border-radius: 1px solid red;</span><br><span class="line">        -webkit-line-clamp: 2;</span><br><span class="line">        display: -webkit-box;</span><br><span class="line">        -webkit-box-orient: vertical;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        text-overflow: ellipsis;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">    这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本</span><br><span class="line">    这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本</span><br><span class="line">&lt;/p &gt;</span><br></pre></td></tr></table></figure><p>可以看到，上述使用了webkit的CSS属性扩展，所以兼容浏览器范围是PC端的webkit内核的浏览器，由于移动端大多数是使用webkit，所以移动端常用该形式</p><p>需要注意的是，如果文本为一段很长的英文或者数字，则需要添加word-wrap: break-word属性</p><p>还能通过使用javascript实现配合css，实现代码如下所示：</p><p>css结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 400px;</span><br><span class="line">    line-height: 20px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.p-after:after&#123;</span><br><span class="line">    content: &quot;...&quot;; </span><br><span class="line">    position: absolute; </span><br><span class="line">    bottom: 0; </span><br><span class="line">    right: 0; </span><br><span class="line">    padding-left: 40px;</span><br><span class="line">    background: -webkit-linear-gradient(left, transparent, #fff 55%);</span><br><span class="line">    background: -moz-linear-gradient(left, transparent, #fff 55%);</span><br><span class="line">    background: -o-linear-gradient(left, transparent, #fff 55%);</span><br><span class="line">    background: linear-gradient(to right, transparent, #fff 55%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javascript代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line"> //获取文本的行高，并获取文本的高度，假设我们规定的行数是五行，那么对超过行数的部分进行限制高度，并加上省略号</span><br><span class="line">   $(&#x27;p&#x27;).each(function(i, obj)&#123;</span><br><span class="line">        var lineHeight = parseInt($(this).css(&quot;line-height&quot;));</span><br><span class="line">        var height = parseInt($(this).height());</span><br><span class="line">        if((height / lineHeight) &gt;3 )&#123;</span><br><span class="line">            $(this).addClass(&quot;p-after&quot;)</span><br><span class="line">            $(this).css(&quot;height&quot;,&quot;60px&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $(this).removeClass(&quot;p-after&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝的区别？如何实现一个深拷贝？</title>
      <link href="/2017/10/18/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/"/>
      <url>/2017/10/18/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>一、数据类型存储<br>前面文章我们讲到，JavaScript中存在两大数据类型：</p><p>基本类型<br>引用类型<br>基本类型数据保存在在栈内存中</p><p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p><p>#二、浅拷贝<br>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p><p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p><p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p><p>下面简单实现一个浅拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;big&quot;&gt;</span><br><span class="line">    function shallowClone(obj) &#123;</span><br><span class="line">    const newObj = &#123;&#125;;</span><br><span class="line">    for(let prop in obj) &#123;</span><br><span class="line">        if(obj.hasOwnProperty(prop))&#123;</span><br><span class="line">            newObj[prop] = obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在JavaScript中，存在浅拷贝的现象有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign</span><br><span class="line">Array.prototype.slice(), Array.prototype.concat()</span><br></pre></td></tr></table></figure><p>使用拓展运算符实现的复制</p><p>#Object.assign</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    age: 18,</span><br><span class="line">    nature: [&#x27;smart&#x27;, &#x27;good&#x27;],</span><br><span class="line">    names: &#123;</span><br><span class="line">        name1: &#x27;fx&#x27;,</span><br><span class="line">        name2: &#x27;xka&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    love: function () &#123;</span><br><span class="line">        console.log(&#x27;fx is a great girl&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var newObj = Object.assign(&#123;&#125;, fxObj);</span><br></pre></td></tr></table></figure><p>#slice()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">const fxArrs = fxArr.slice(0)</span><br><span class="line">fxArrs[1] = &quot;love&quot;;</span><br><span class="line">console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span><br></pre></td></tr></table></figure><p>#concat()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">const fxArrs = fxArr.concat()</span><br><span class="line">fxArrs[1] = &quot;love&quot;;</span><br><span class="line">console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span><br></pre></td></tr></table></figure><p>#拓展运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fxArr = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">const fxArrs = [...fxArr]</span><br><span class="line">fxArrs[1] = &quot;love&quot;;</span><br><span class="line">console.log(fxArr) // [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span><br><span class="line">console.log(fxArrs) // [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span><br></pre></td></tr></table></figure><p>#三、深拷贝<br>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p><p>常见的深拷贝方式有：</p><blockquote><p>_.cloneDeep()<br>jQuery.extend()<br>JSON.stringify()</p></blockquote><p>手写循环递归</p><p>#_.cloneDeep()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const _ = require(&#x27;lodash&#x27;);</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">const obj2 = _.cloneDeep(obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f);// false</span><br></pre></td></tr></table></figure><p>#jQuery.extend()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const $ = require(&#x27;jquery&#x27;);</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">const obj2 = $.extend(true, &#123;&#125;, obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f); // false</span><br></pre></td></tr></table></figure><p>#JSON.stringify()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj2=JSON.parse(JSON.stringify(obj1));</span><br></pre></td></tr></table></figure><p>但是这种方式存在弊端，会忽略undefined、symbol和函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    name: &#x27;A&#x27;,</span><br><span class="line">    name1: undefined,</span><br><span class="line">    name3: function() &#123;&#125;,</span><br><span class="line">    name4:  Symbol(&#x27;A&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">const obj2 = JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(obj2); // &#123;name: &quot;A&quot;&#125;</span><br></pre></td></tr></table></figure><p>#循环递归</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj, hash = new WeakMap()) &#123;</span><br><span class="line">  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作</span><br><span class="line">  if (obj instanceof Date) return new Date(obj);</span><br><span class="line">  if (obj instanceof RegExp) return new RegExp(obj);</span><br><span class="line">  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span><br><span class="line">  if (typeof obj !== &quot;object&quot;) return obj;</span><br><span class="line">  // 是对象的话就要进行深拷贝</span><br><span class="line">  if (hash.get(obj)) return hash.get(obj);</span><br><span class="line">  let cloneObj = new obj.constructor();</span><br><span class="line">  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      // 实现一个递归拷贝</span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#四、区别<br>下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别<br><img src="https://static.vue-js.com/d9862c00-69b8-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样</p><p>浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浅拷贝</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">    name : &#x27;init&#x27;,</span><br><span class="line">    arr : [1,[2,3],4],</span><br><span class="line">&#125;;</span><br><span class="line">const obj3=shallowClone(obj1) // 一个浅拷贝方法</span><br><span class="line">obj3.name = &quot;update&quot;;</span><br><span class="line">obj3.arr[1] = [5,6,7] ; // 新旧对象还是共享同一块内存</span><br><span class="line"></span><br><span class="line">console.log(&#x27;obj1&#x27;,obj1) // obj1 &#123; name: &#x27;init&#x27;,  arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="line">console.log(&#x27;obj3&#x27;,obj3) // obj3 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br></pre></td></tr></table></figure><p>但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 深拷贝</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">    name : &#x27;init&#x27;,</span><br><span class="line">    arr : [1,[2,3],4],</span><br><span class="line">&#125;;</span><br><span class="line">const obj4=deepClone(obj1) // 一个深拷贝方法</span><br><span class="line">obj4.name = &quot;update&quot;;</span><br><span class="line">obj4.arr[1] = [5,6,7] ; // 新对象跟原对象不共享内存</span><br><span class="line"></span><br><span class="line">console.log(&#x27;obj1&#x27;,obj1) // obj1 &#123; name: &#x27;init&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;</span><br><span class="line">console.log(&#x27;obj4&#x27;,obj4) // obj4 &#123; name: &#x27;update&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br></pre></td></tr></table></figure><p>#小结<br>前提为拷贝类型为引用类型的情况下：<br>1.浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址<br>2.深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说JavaScript中的数据类型？存储上的差别？</title>
      <link href="/2017/09/25/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F/"/>
      <url>/2017/09/25/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F/%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>前言<br>在JavaScript中，我们可以分成两种类型：</p><p>基本类型<br>复杂类型<br>两种类型的区别是：存储位置不同</p><p>#一、基本类型<br>基本类型主要为以下6种：</p><p>Number<br>String<br>Boolean<br>Undefined<br>null<br>symbol<br>#Number<br>数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let intNum = 55 // 10进制的55</span><br><span class="line">let num1 = 070 // 8进制的56</span><br><span class="line">let hexNum1 = 0xA //16进制的10</span><br></pre></td></tr></table></figure><p>浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let floatNum1 = 1.1;</span><br><span class="line">let floatNum2 = 0.1;</span><br><span class="line">let floatNum3 = .1; // 有效，但不推荐</span><br><span class="line">let floatNum = 3.125e7; // 等于 31250000</span><br></pre></td></tr></table></figure><p>在数值类型中，存在一个特殊数值NaN，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(0/0); // NaN</span><br><span class="line">console.log(-0/+0); // NaN</span><br></pre></td></tr></table></figure><p>Undefined<br>Undefined 类型只有一个值，就是特殊值 undefined。当使用 var或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let message;</span><br><span class="line">console.log(message == undefined); // true</span><br></pre></td></tr></table></figure><p>包含undefined 值的变量跟未定义变量是有区别的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let message; // 这个变量被声明了，只是值为 undefined</span><br><span class="line"></span><br><span class="line">console.log(message); // &quot;undefined&quot;</span><br><span class="line">console.log(age); // 没有声明过这个变量，报错</span><br></pre></td></tr></table></figure><p>String<br>字符串可以使用双引号（”）、单引号（’）或反引号（`）标示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let firstName = &quot;John&quot;;</span><br><span class="line">let lastName = &#x27;Jacob&#x27;;</span><br><span class="line">let lastName = `Jingleheimerschmidt`</span><br></pre></td></tr></table></figure><p>字符串是不可变的，意思是一旦创建，它们的值就不能变了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let lang = &quot;Java&quot;;</span><br><span class="line">lang = lang + &quot;Script&quot;;  // 先销毁再创建</span><br></pre></td></tr></table></figure><p>Null<br>Null类型同样只有一个值，即特殊值 null</p><p>逻辑上讲， null 值表示一个空对象指针，这也是给typeof传一个 null 会返回 “object” 的原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let car = null;</span><br><span class="line">console.log(typeof car); // &quot;object&quot;</span><br></pre></td></tr></table></figure><p>undefined 值是由 null值派生而来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(null == undefined); // true</span><br></pre></td></tr></table></figure><p>只要变量要保存对象，而当时又没有那个对象可保存，就可用 null来填充该变量</p><p>#Boolean<br>Boolean（布尔值）类型有两个字面值： true 和false<br>通过Boolean可以将其他类型的数据转化成布尔值<br>规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型      转换为 true 的值      转换为 false 的值</span><br><span class="line"> String         非空字符串          &quot;&quot; </span><br><span class="line"> Number 非零数值（包括无穷值）0 、 NaN </span><br><span class="line"> Object  任意对象    null</span><br><span class="line">Undefined N/A （不存在） undefined</span><br></pre></td></tr></table></figure><p>Symbol<br>Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let genericSymbol = Symbol();</span><br><span class="line">let otherGenericSymbol = Symbol();</span><br><span class="line">console.log(genericSymbol == otherGenericSymbol); // false</span><br><span class="line"></span><br><span class="line">let fooSymbol = Symbol(&#x27;foo&#x27;);</span><br><span class="line">let otherFooSymbol = Symbol(&#x27;foo&#x27;);</span><br><span class="line">console.log(fooSymbol == otherFooSymbol); // false</span><br></pre></td></tr></table></figure><p>二、引用类型<br>复杂类型统称为Object，我们这里主要讲述下面三种：</p><p>Object<br>Array<br>Function<br>#Object<br>创建object常用方式为对象字面量表示法，属性名可以是字符串或数值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Nicholas&quot;,</span><br><span class="line">    &quot;age&quot;: 29,</span><br><span class="line">    5: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Array<br>JavaScript数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, 2, &#123;age: 20 &#125;]</span><br><span class="line">colors.push(2)</span><br></pre></td></tr></table></figure><p>Function<br>函数实际上是对象，每个函数都是 Function类型的实例，而 Function也有属性和方法，跟其他引用类型一样<br>函数存在三种常见的表达方式：<br>函数声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sum = function(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数：函数声明和函数表达式两种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sum = (num1, num2) =&gt; &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>三、存储区别<br>基本数据类型和引用数据类型存储在内存中的位置不同：</p><p>基本数据类型存储在栈中</p><p>引用类型的对象存储于堆中</p><p>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值</p><p>下面来举个例子</p><p>#基本类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 10;</span><br><span class="line">let b = a; // 赋值操作</span><br><span class="line">b = 20;</span><br><span class="line">console.log(a); // 10值</span><br></pre></td></tr></table></figure><p>a的值为一个基本类型，是存储在栈中，将a的值赋给b，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址</p><p>下图演示了基本类型赋值的过程：</p><p><img src="https://static.vue-js.com/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>引用类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;&#125;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.name = &quot;Xxx&quot;;</span><br><span class="line">console.log(obj1.name); // xxx</span><br></pre></td></tr></table></figure><p>引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。</p><p>obj1是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了obj2，实际上他们共同指向了同一个堆内存对象，所以更改obj2会对obj1产生影响</p><p>下图演示这个引用类型赋值过程<br><img src="https://static.vue-js.com/a34bdd10-6463-11eb-ab90-d9ae814b240d.png" loading="lazy"></p><p>小结<br>声明变量时不同的内存地址分配：<br>简单类型的值存放在栈中，在栈中存放的是对应的值<br>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址<br>不同的类型数据导致赋值变量时的不同：<br>简单类型赋值，是生成相同的值，两个对象对应不同的地址<br>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS提高性能的方法有哪些?</title>
      <link href="/2017/09/13/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
      <url>/2017/09/13/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/CSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
      
        <content type="html"><![CDATA[<p>一、前言<br>每一个网页都离不开css，但是很多人又认为，css主要是用来完成页面布局的，像一些细节或者优化，就不需要怎么考虑，实际上这种想法是不正确的</p><p>作为页面渲染和内容展现的重要环节，css影响着用户对整个网站的第一体验</p><p>因此，在整个产品研发过程中，css性能优化同样需要贯穿全程</p><p>#二、实现方式<br>实现方式有很多种，主要有如下：</p><p>内联首屏关键CSS<br>异步加载CSS<br>资源压缩<br>合理使用选择器<br>减少使用昂贵的属性<br>不要使用@import<br>#内联首屏关键CSS<br>在打开一个页面，页面首要内容出现在屏幕的时间影响着用户的体验，而通过内联css关键代码能够使浏览器在下载完html后就能立刻渲染</p><p>而如果外部引用css代码，在解析html结构过程中遇到外部css文件，才会开始下载css代码，再渲染</p><p>所以，CSS内联使用使渲染时间提前</p><p>注意：但是较大的css代码并不合适内联（初始拥塞窗口、没有缓存），而其余代码则采取外部引用方式</p><p>#异步加载CSS<br>在CSS文件请求、下载、解析完成之前，CSS会阻塞渲染，浏览器将不会渲染任何已处理的内容</p><p>前面加载内联代码后，后面的外部引用css则没必要阻塞浏览器渲染。这时候就可以采取异步加载的方案，主要有如下：</p><p>使用javascript将link标签插到head标签最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建link标签</span><br><span class="line">const myCSS = document.createElement( &quot;link&quot; );</span><br><span class="line">myCSS.rel = &quot;stylesheet&quot;;</span><br><span class="line">myCSS.href = &quot;mystyles.css&quot;;</span><br><span class="line">// 插入到header的最后位置</span><br><span class="line">document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling );</span><br></pre></td></tr></table></figure><p>设置link标签media属性为noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将media的值设为screen或all，从而让浏览器开始解析CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;mystyles.css&quot; media=&quot;noexist&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure><p>通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel设回stylesheet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;alternate stylesheet&quot; href=&quot;mystyles.css&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure><p>资源压缩<br>利用webpack、gulp/grunt、rollup等模块化工具，将css代码进行压缩，使文件变小，大大降低了浏览器的加载时间</p><p>#合理使用选择器<br>css匹配的规则是从右往左开始匹配，例如#markdown .content h3匹配规则如下：</p><p>先找到h3标签元素<br>然后去除祖先不是.content的元素<br>最后去除祖先不是#markdown的元素<br>如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高</p><p>所以我们在编写选择器的时候，可以遵循以下规则：</p><p>不要嵌套使用过多复杂选择器，最好不要三层以上<br>使用id选择器就没必要再进行嵌套<br>通配符和属性选择器效率最低，避免使用<br>#减少使用昂贵的属性<br>在页面发生重绘的时候，昂贵属性如box-shadow/border-radius/filter/透明度/:nth-child等，会降低浏览器的渲染性能</p><p>#不要使用@import<br>css样式文件有两种引入方式，一种是link元素，另一种是@import</p><p>@import会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时</p><p>而且多个@import可能会导致下载顺序紊乱</p><p>比如一个css文件index.css包含了以下内容：@import url(“reset.css”)</p><p>那么浏览器就必须先把index.css下载、解析和执行后，才下载、解析和执行第二个文件reset.css</p><p>#其他<br>减少重排操作，以及减少不必要的重绘<br>了解哪些属性可以继承而来，避免对这些属性重复编写<br>cssSprite，合成所有icon图片，用宽高加上backgroud-position的背景图方式显现出我们要的icon图，减少了http请求<br>把小的icon图片转成base64编码<br>CSS3动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性<br>#三、总结<br>css实现性能的方式可以从选择器嵌套、属性特性、减少http这三面考虑，同时还要注意css代码的加载顺序</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3新增了哪些新特性？</title>
      <link href="/2017/08/30/CSS3%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F/CSS3%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F/"/>
      <url>/2017/08/30/CSS3%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F/CSS3%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>一、是什么<br>css，即层叠样式表（Cascading Style Sheets）的简称，是一种标记语言，由浏览器解释执行用来使页面变得更美观</p><p>css3是css的最新标准，是向后兼容的，CSS1/2的特性在CSS3 里都是可以使用的</p><p>而CSS3 也增加了很多新特性，为开发带来了更佳的开发体验</p><p>#二、选择器<br>css3中新增了一些选择器，主要为如下图所示：<br><img src="https://static.vue-js.com/e368cf20-9b5e-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>三、新样式<br>#边框<br>css3新增了三个边框属性，分别是：</p><p>border-radius：创建圆角边框</p><p>box-shadow：为元素添加阴影</p><p>border-image：使用图片来绘制边框</p><p>#box-shadow<br>设置元素阴影，设置属性如下：</p><p>水平阴影<br>垂直阴影<br>模糊距离(虚实)<br>阴影尺寸(影子大小)<br>阴影颜色<br>内/外阴影<br>其中水平阴影和垂直阴影是必须设置的</p><p>#背景<br>新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break</p><p>#background-clip<br>用于确定背景画区，有以下几种可能的属性：</p><p>background-clip: border-box; 背景从border开始显示<br>background-clip: padding-box; 背景从padding开始显示<br>background-clip: content-box; 背景显content区域开始显示<br>background-clip: no-clip; 默认属性，等同于border-box<br>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围</p><p>#background-origin<br>当我们设置背景图片时，图片是会以左上角对齐，但是是以border的左上角对齐还是以padding的左上角或者content的左上角对齐? border-origin正是用来设置这个的</p><p>background-origin: border-box; 从border开始计算background-position<br>background-origin: padding-box; 从padding开始计算background-position<br>background-origin: content-box; 从content开始计算background-position<br>默认情况是padding-box，即以padding的左上角为原点</p><p>#background-size<br>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p><p>background-size: contain; 缩小图片以适合元素（维持像素长宽比）<br>background-size: cover; 扩展元素以填补元素（维持像素长宽比）<br>background-size: 100px 100px; 缩小图片至指定的大小<br>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸<br>#background-break<br>元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示</p><p>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）<br>background-break: bounding-box; 把盒之间的距离计算在内；<br>background-break: each-box; 为每个盒子单独重绘背景<br>#文字<br>#word-wrap<br>语法：word-wrap: normal|break-word</p><p>normal：使用浏览器默认的换行<br>break-all：允许在单词内换行<br>#text-overflow<br>text-overflow设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：</p><p>clip：修剪文本<br>ellipsis：显示省略符号来代表被修剪的文本<br>#text-shadow<br>text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p><p>#text-decoration<br>CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p><p>text-fill-color: 设置文字内部填充颜色</p><p>text-stroke-color: 设置文字边界填充颜色</p><p>text-stroke-width: 设置文字边界宽度</p><p>#颜色<br>css3新增了新的颜色表示方式rgba与hsla</p><p>rgba分为两部分，rgb为颜色值，a为透明度<br>hala分为四部分，h为色相，s为饱和度，l为亮度，a为透明度<br>#四、transition 过渡<br>transition属性可以被指定为一个或多个CSS属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：</p><p>过度效果<br>持续时间<br>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)</span><br></pre></td></tr></table></figure><p>上面为简写模式，也可以分开写各个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transition-property: width; </span><br><span class="line">transition-duration: 1s;</span><br><span class="line">transition-timing-function: linear;</span><br><span class="line">transition-delay: 2s;</span><br></pre></td></tr></table></figure><p>五、transform 转换<br>transform属性允许你旋转，缩放，倾斜或平移给定元素</p><p>transform-origin：转换元素的位置（围绕那个点进行转换），默认值为(x,y,z):(50%,50%,0)</p><p>使用方式：</p><p>transform: translate(120px, 50%)：位移<br>transform: scale(2, 0.5)：缩放<br>transform: rotate(0.5turn)：旋转<br>transform: skew(30deg, 20deg)：倾斜<br>#六、animation 动画<br>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬</p><p>animation也有很多的属性</p><p>animation-name：动画名称<br>animation-duration：动画持续时间<br>animation-timing-function：动画时间函数<br>animation-delay：动画延迟时间<br>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite，意思是无限循环<br>animation-direction：动画执行方向<br>animation-paly-state：动画播放状态<br>animation-fill-mode：动画填充模式<br>#七、渐变<br>颜色渐变是指在两个颜色之间平稳的过渡，css3渐变包括</p><p>linear-gradient：线性渐变<br>background-image: linear-gradient(direction, color-stop1, color-stop2, …);</p><p>radial-gradient：径向渐变<br>linear-gradient(0deg, red, green);</p><p>#八、其他<br>关于css3其他的新特性还包括flex弹性布局、Grid栅格布局，这两个布局在以前就已经讲过，这里就不再展示</p><p>除此之外，还包括多列布局、媒体查询、混合模式等等…..</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中，有哪些方式可以隐藏页面元素？区别?</title>
      <link href="/2017/07/19/css%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%9F%E5%8C%BA%E5%88%AB/css%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%9F%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/07/19/css%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%9F%E5%8C%BA%E5%88%AB/css%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%EF%BC%9F%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>一、前言<br>在平常的样式排版中，我们经常遇到将某个模块隐藏的场景</p><p>通过css隐藏元素的方法有很多种，它们看起来实现的效果是一致的</p><p>但实际上每一种方法都有一丝轻微的不同，这些不同决定了在一些特定场合下使用哪一种方法</p><p>#二、实现方式<br>通过css实现隐藏元素方法有如下：</p><p>display:none<br>visibility:hidden<br>opacity:0<br>设置height、width模型属性为0<br>position:absolute<br>clip-path<br>#display:none<br>设置元素的display为none是最常用的隐藏元素的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">    display:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将元素设置为display:none后，元素在页面上将彻底消失</p><p>元素本身占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘</p><p>消失后，自身绑定的事件不会触发，也不会有过渡效果</p><p>特点：元素不可见，不占据空间，无法响应点击事件</p><p>#visibility:hidden<br>设置元素的visibility为hidden也是一种常用的隐藏元素的方法</p><p>从页面上仅仅是隐藏该元素，DOM结果均会存在，只是当时在一个不可见的状态，不会触发重排，但是会触发重绘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.hidden&#123;</span><br><span class="line">    visibility:hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给人的效果是隐藏了，所以他自身的事件不会触发</p><p>特点：元素不可见，占据页面空间，无法响应点击事件</p><p>#opacity:0<br>opacity属性表示元素的透明度，将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的</p><p>不会引发重排，一般情况下也会引发重绘</p><p>如果利用 animation 动画，对 opacity 做变化（animation会默认触发GPU加速），则只会触发 GPU 层面的 composite，不会触发重绘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.transparent &#123;</span><br><span class="line">    opacity:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于其仍然是存在于页面上的，所以他自身的的事件仍然是可以触发的，但被他遮挡的元素是不能触发其事件的</p><p>需要注意的是：其子元素不能设置opacity来达到显示的效果</p><p>特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件</p><p>#设置height、width属性为0<br>将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其overflow:hidden来隐藏其子元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.hiddenBox &#123;</span><br><span class="line">    margin:0;     </span><br><span class="line">    border:0;</span><br><span class="line">    padding:0;</span><br><span class="line">    height:0;</span><br><span class="line">    width:0;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：元素不可见，不占据页面空间，无法响应点击事件</p><p>#position:absolute<br>将元素移出可视区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">   position: absolute;</span><br><span class="line">   top: -9999px;</span><br><span class="line">   left: -9999px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：元素不可见，不影响页面布局</p><p>#clip-path<br>通过裁剪的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.hide &#123;</span><br><span class="line">  clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：元素不可见，占据页面空间，无法响应点击事件</p><p>#小结<br>最常用的还是display:none和visibility:hidden，其他的方式只能认为是奇招，它们的真正用途并不是用于隐藏元素，所以并不推荐使用它们</p><p>#三、区别<br>关于display: none、visibility: hidden、opacity: 0的区别，如下表所示：</p><blockquote><pre><code>        display: none    visibility: hidden    opacity: 0</code></pre><p>页面中            不存在                存在                存在<br>重排            会                    不会                不会<br>重绘            会                    会                    不一定<br>自身绑定事件    不触发                不触发                   可触发<br>transition        不支持                支持                   支持<br>子元素可复原    不能                能                       不能<br>被遮挡的元素可触发事件    能             能                        不能</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说em/px/rem/vh/vw区别?</title>
      <link href="/2017/06/08/%E8%AF%B4%E8%AF%B4em-px-rem-vh-vw%E5%8C%BA%E5%88%AB/%E8%AF%B4%E8%AF%B4em-px-rem-vh-vw%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/06/08/%E8%AF%B4%E8%AF%B4em-px-rem-vh-vw%E5%8C%BA%E5%88%AB/%E8%AF%B4%E8%AF%B4em-px-rem-vh-vw%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>一、介绍<br>传统的项目开发中，我们只会用到px、%、em这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性</p><p>从CSS3开始，浏览器对计量单位的支持又提升到了另外一个境界，新增了rem、vh、vw、vm等一些新的计量单位</p><p>利用这些新的单位开发出比较良好的响应式页面，适应多种不同分辨率的终端，包括移动设备等</p><p>#二、单位<br>在css单位中，可以分为长度单位、绝对单位，如下表所指示</p><p>CSS单位<br>相对长度单位    em、ex、ch、rem、vw、vh、vmin、vmax、%<br>绝对长度单位    cm、mm、in、px、pt、pc<br>这里我们主要讲述px、em、rem、vh、vw</p><p>#px<br>px，表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的，所以像素为计量单位被分在了绝对长度单位中</p><p>有些人会把px认为是相对长度，原因在于在移动端中存在设备像素比，px实际显示的大小是不确定的</p><p>这里之所以认为px为绝对单位，在于px的大小和元素的其他属性无关</p><p>#em<br>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em = 16px）</p><p>为了简化 font-size 的换算，我们需要在css中的 body 选择器中声明font-size= 62.5%，这就使 em 值变为 16px*62.5% = 10px</p><p>这样 12px = 1.2em, 10px = 1em, 也就是说只需要将你的原来的px 数值除以 10，然后换上 em作为单位就行了</p><p>特点：</p><p>em 的值并不是固定的<br>em 会继承父级元素的字体大小<br>em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸<br>任意浏览器的默认字体高都是 16px<br>举个例子</p><blockquote><div class="big">    我是14px=1.4rem<div class="small">我是12px=1.2rem</div></div></blockquote><p>样式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    html &#123;font-size: 10px;  &#125; /*  公式16px*62.5%=10px  */  </span><br><span class="line">    .big&#123;font-size: 1.4rem&#125;</span><br><span class="line">    .small&#123;font-size: 1.2rem&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这时候.big元素的font-size为14px，而.small元素的font-size为12px<br>#rem<br>rem，相对单位，相对的只是HTML根元素font-size的值<br>同理，如果想要简化font-size的转化，我们可以在根元素html中加入font-size: 62.5%</p><blockquote><p>html {font-size: 62.5%;  } /*  公式16px*62.5%=10px  */ </p></blockquote><p>这样页面中1rem=10px、1.2rem=12px、1.4rem=14px、1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助<br>特点：<br>rem单位可谓集相对大小和绝对大小的优点于一身<br>和em不同的是rem总是相对于根元素，而不像em一样使用级联的方式来计算尺寸<br>#vh、vw<br>vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，vh则为窗口的高度<br>这里的窗口分成几种情况：<br>在桌面端，指的是浏览器的可视区域<br>移动端指的就是布局视口<br>像vw、vh，比较容易混淆的一个单位是%，不过百分比宽泛的讲是相对于父元素：<br>对于普通定位元素就是我们理解的父元素<br>对于position: absolute;的元素是相对于已定位的父元素<br>对于position: fixed;的元素是相对于 ViewPort（可视窗口）<br>#三、总结<br>px：绝对单位，页面按精确像素展示<br>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算，整个页面内1em不是一个固定的值<br>rem：相对单位，可理解为root em, 相对根节点html的字体大小来计算<br>vh、vw：主要用于页面视口大小布局，在页面布局上更加方便简单</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css选择器有哪些？优先级？哪些属性可以继承？</title>
      <link href="/2017/05/11/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/"/>
      <url>/2017/05/11/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>一、选择器<br>CSS选择器是CSS规则的第一部分</p><p>它是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式</p><p>选择器所选择的元素，叫做“选择器的对象”</p><p>我们从一个Html结构开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;one&quot;&gt;</span><br><span class="line">        &lt;p class=&quot;one_1&quot;&gt;</span><br><span class="line">        &lt;/p &gt;</span><br><span class="line">        &lt;p class=&quot;one_1&quot;&gt;</span><br><span class="line">        &lt;/p &gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>关于css属性选择器常用的有：</p><p>id选择器（#box），选择id为box的元素</p><p>类选择器（.one），选择类名为one的所有元素</p><p>标签选择器（div），选择标签为div的所有元素</p><p>后代选择器（#box div），选择id为box元素内部所有的div元素</p><p>子选择器（.one&gt;one_1），选择父元素为.one的所有.one_1的元素</p><p>相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素</p><p>群组选择器（div,p），选择div、p的所有元素</p><p>还有一些使用频率相对没那么多的选择器：</p><p>伪类选择器</p><blockquote><p>:link ：选择未被访问的链接<br>:visited：选取已被访问的链接<br>:active：选择活动链接<br>:hover ：鼠标指针浮动在上面的元素<br>:focus ：选择具有焦点的<br>:first-child：父元素的首个子元素</p></blockquote><p>伪元素选择器</p><blockquote><p>:first-letter ：用于选取指定选择器的首字母<br>:first-line ：选取指定选择器的首行<br>:before : 选择器在被选元素的内容前面插入内容<br>:after : 选择器在被选元素的内容后面插入内容</p></blockquote><p>属性选择器</p><blockquote><p>[attribute] 选择带有attribute属性的元素<br>[attribute=value] 选择所有使用attribute=value的元素<br>[attribute~=value] 选择attribute属性包含value的元素<br>[attribute|=value]：选择attribute属性以value开头的元素</p></blockquote><p>在CSS3中新增的选择器有如下：<br>层次选择器（p~ul），选择前面有p元素的每个ul元素<br>伪类选择器</p><blockquote><p>:first-of-type 表示一组同级元素中其类型的第一个元素<br>:last-of-type 表示一组同级元素中其类型的最后一个元素<br>:only-of-type 表示没有同类型兄弟元素的元素<br>:only-child 表示没有任何兄弟的元素<br>:nth-child(n) 根据元素在一组同级中的位置匹配元素<br>:nth-last-of-type(n) 匹配给定类型的元素，基于它们在一组兄弟元素中的位置，从末尾开始计数<br>:last-child 表示一组兄弟元素中的最后一个元素<br>:root 设置HTML文档<br>:empty 指定空的元素<br>:enabled 选择可用元素<br>:disabled 选择被禁用元素<br>:checked 选择选中的元素<br>:not(selector) 选择与 <selector> 不匹配的所有元素</selector></p></blockquote><p>属性选择器</p><blockquote><p>[attribute*=value]：选择attribute属性值包含value的所有元素<br>[attribute^=value]：选择attribute属性开头为value的所有元素<br>[attribute$=value]：选择attribute属性结尾为value的所有元素</p></blockquote><p>二、优先级<br>相信大家对CSS选择器的优先级都不陌生：</p><p>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器<br>到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><p>如果存在内联样式，那么 A = 1, 否则 A = 0</p><p>B的值等于 ID选择器出现的次数</p><p>C的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数</p><p>D 的值等于 标签选择器 和 伪元素 出现的总次数</p><p>这里举个例子：</p><blockquote><p>#nav-global &gt; ul &gt; li &gt; a.nav-link</p></blockquote><p>套用上面的算法，依次求出 A B C D 的值：<br>因为没有内联样式 ，所以 A = 0<br>ID选择器总共出现了1次， B = 1<br>类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 C = (1 + 0 + 0) = 1<br>标签选择器出现了3次， 伪元素出现了0次，所以 D = (3 + 0) = 3</p><p>上面算出的A 、 B、C、D 可以简记作：(0, 1, 1, 3)</p><p>知道了优先级是如何计算之后，就来看看比较规则：</p><p>从左往右依次进行比较 ，较大者优先级更高<br>如果相等，则继续往右移动一位进行比较<br>如果4位全部相等，则后面的会覆盖前面的<br>经过上面的优先级计算规则，我们知道内联样式的优先级最高，如果外部样式需要覆盖内联样式，就需要使用!important</p><p>#三、继承属性<br>在css中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性</p><p>关于继承属性，可以分成：</p><p>字体系列属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">font:组合字体</span><br><span class="line">font-family:规定元素的字体系列</span><br><span class="line">font-weight:设置字体的粗细</span><br><span class="line">font-size:设置字体的尺寸</span><br><span class="line">font-style:定义字体的风格</span><br><span class="line">font-variant:偏大或偏小的字体</span><br></pre></td></tr></table></figure><p>文本系列属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">text-indent：文本缩进</span><br><span class="line">text-align：文本水平对刘</span><br><span class="line">line-height：行高</span><br><span class="line">word-spacing：增加或减少单词间的空白</span><br><span class="line">letter-spacing：增加或减少字符间的空白</span><br><span class="line">text-transform：控制文本大小写</span><br><span class="line">direction：规定文本的书写方向</span><br><span class="line">color：文本颜色</span><br></pre></td></tr></table></figure><p>元素可见性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visibility</span><br></pre></td></tr></table></figure><p>表格布局属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caption-side：定位表格标题位置</span><br><span class="line">border-collapse：合并表格边框</span><br><span class="line">border-spacing：设置相邻单元格的边框间的距离</span><br><span class="line">empty-cells：单元格的边框的出现与消失</span><br><span class="line">table-layout：表格的宽度由什么决定</span><br></pre></td></tr></table></figure><p>列表属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list-style-type：文字前面的小点点样式</span><br><span class="line">list-style-position：小点点位置</span><br><span class="line">list-style：以上的属性可通过这属性集合</span><br></pre></td></tr></table></figure><p>引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotes：设置嵌套引用的引号类型</span><br></pre></td></tr></table></figure><p>光标属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor：箭头可以变成需要的形状</span><br></pre></td></tr></table></figure><p>继承中比较特殊的几点：<br>a 标签的字体颜色不能被继承<br>h1-h6标签字体的大下也是不能被继承的</p><p>#无继承的属性<br>display<br>文本属性：vertical-align、text-decoration<br>盒子模型的属性：宽度、高度、内外边距、边框等<br>背景属性：背景图片、颜色、位置等<br>定位属性：浮动、清除浮动、定位position等<br>生成内容属性：content、counter-reset、counter-increment<br>轮廓样式属性：outline-style、outline-width、outline-color、outline<br>页面样式属性：size、page-break-before、page-break-after</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈你对盒子模型的理解</title>
      <link href="/2017/05/09/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/05/09/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>一、是什么？<br>当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）<br>一个盒子由四个部分组成：content、padding、border、margin<br><img src="https://static.vue-js.com/976789a0-8f9b-11eb-85f6-6fac77c0c9b3.png" loading="lazy"><br>content，即实际内容，显示文本和图像<br>boreder，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成<br>padding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的background属性影响<br>margin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域<br>上述是一个从二维的角度观察盒子，下面再看看看三维图：</p><p><img src="https://static.vue-js.com/b2548b00-8f9b-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>下面来段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  盒子模型</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>当我们在浏览器查看元素时，却发现元素的大小变成了240px</p><p>这是因为，在CSS中，盒子模型可以分成：</p><p>W3C 标准盒子模型<br>IE 怪异盒子模型<br>默认情况下，盒子模型为W3C 标准盒子模型</p><p>#二、标准盒子模型<br>标准盒子模型，是浏览器默认的盒子模型</p><p>下面看看标准盒子模型的模型图：<br><img src="https://static.vue-js.com/c0e1d2e0-8f9b-11eb-85f6-6fac77c0c9b3.png" loading="lazy"></p><p>从上图可以看到：</p><p>盒子总宽度 = width + padding + border + margin;</p><p>盒子总高度 = height + padding + border + margin</p><p>也就是，width/height 只是内容高度，不包含 padding 和 border值</p><p>所以上面问题中，设置width为200px，但由于存在padding，但实际上盒子的宽度有240px</p><p>#三、IE 怪异盒子模型<br>同样看看IE 怪异盒子模型的模型图：<br><img src="https://static.vue-js.com/cfbb3ef0-8f9b-11eb-ab90-d9ae814b240d.png" loading="lazy"><br>从上图可以看到：</p><p>盒子总宽度 = width + margin;</p><p>盒子总高度 = height + margin;</p><p>也就是，width/height 包含了 padding和 border值</p><p>#Box-sizing<br>CSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选择器具有优先级</span><br><span class="line">box-sizing: content-box|border-box|inherit:</span><br></pre></td></tr></table></figure><p>content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致<br>border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致<br>inherit 指定 box-sizing 属性的值，应该从父元素继承<br>回到上面的例子里，设置盒子为 border-box 模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">选择器具有优先级</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">  盒子模型</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这时候，就可以发现盒子的所占据的宽度为200px</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="https://www.bilibili.com/video/BV1R4411d7BH/?spm_id_from=333.788.recommend_more_video.0&vd_source=5d6cc5bbdeda6999838ad14775716893&t=7.5" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css基础概念</title>
      <link href="/2017/05/08/css%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2017/05/08/css%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>一、css基础概念<br>1、描述<br>css叫做层叠样式表，或者级联样式表，用来控制网页的样式。</p><blockquote><p>说明：制作网页的三要素<br>1、html文档：做网页的布局（结构）————结构层<br>2、css：控制显示的样式（美观）————行为层<br>3、js：控制网页的行为（与用户交互）————交互层</p></blockquote><p>2、css的作用<br>使内容与表现完全分离<br>提高了代码的可重用性和可维护性，一个css文件可以被多个html引入，一个html文件可以引入多个css文件<br>3、引入css样式的方式<br>行内样式（内联样式）：<br>在标签内部使用 style属性进行设置，只对当前行生效，功能单一<br>内部样式：在head标签里，通过style标签引入，只对当前html文件生效<br>外部样式：在head标签里，通过link外部css文件的方式，方便多处使用，可重用、可维护性高<br>导入式：在head标签里的style里，通过@import的方式引入css文件</p><blockquote><p>说明：link和@import的区别<br>@import是先加载html文件再加载css，而link是同时加载hmtl和css文件<br>@import只能引入css文件，link可以引入多种文件，比如icon<br>@import具有兼容性，link没有兼容性<br>js只能操作link引入的样式，不能操作@import引入的样式</p></blockquote><p>二、css的特点<br>1、继承性<br>color、 text-开头的、line-开头的、font-开头的属性这些关于文字样式的，都可以被子代继承，所有关于盒子的、定位的、布局的属性都不能继承。</p><p>2、优先级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选择器具有优先级</span><br><span class="line">Id&gt;class&gt;元素&gt;通配符*（全局选择器）</span><br></pre></td></tr></table></figure><p>3、层叠性<br>CSS异常冲突处理能力—层叠性。</p><p>层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！<br>CSS像艺术家一样优雅，像工程师一样严谨。</p><p>当选择器，选择上了某个元素的时候，那么要这么统计权重：</p><p>id的数量，类的数量，标签的数量，还有先后顺序，当优先级相同的情况下，写在后面的会覆盖前面的样式</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础</title>
      <link href="/2017/05/05/HTML%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/05/05/HTML%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>简释：一种为普通文件中某些字句加上标示的语言，其目的在于运用标记（tag）使文件达到预期的显示效果。<br>HTML 是在 SGML 定义下的一个描述性语言，或可说 HTML 是 SGML 的一个应用程式，HTML 不是程式语言，如 C++ 和 Java 之类，它只是标示语言，基本上你只要明白了各种 标记的用法便算学懂了 HTML，HTML 的格式非常简单，只是由文字及标记组合而成，于 编辑方面，任何文字编辑器都可以，只要能将文件另存成 ASCII 纯文字格式即可，当然 以专业的网页编辑软件为佳。<br>阅读须知：<br>这一篇HTML剖析偏重于标记的介绍，考虑到易懂及每节的篇幅问题，我并不按 W3C 的 HTML 分类，这可令你更易选择有兴趣的标记，其中只有文件标记是必读的，其 余可任意选择。这一篇不会提及任何网页编辑软件，只要掌握了 HTML ，任何网页 编辑工具都可以变成一把利器。<br>标记写法：<br>任何标记皆由”&lt;”及”&gt;”所围住，如</p><p>标记名与小于号之间不能留有空白字符。<br>某些标记　要加上参数，某些则不必。如 Hello<br>参数只可加于起始标记中。<br>在起始标记之标记名前加上符号”/“便是其终结标记，如<br>标记字母大小写皆可。</p><p>围堵标记与空标记：<br>标记按型态分为围堵标记与空标记<br>围堵标记<br>顾名思义，它以起始标记及终结标记将文字围住，令其达到预期显示效果。<br>例如 HTML Source ： Creation of Webpage is my favourite.<br>显示成： Creation of Webpage is my favourite.</p><p>其中 便称为围堵标记。<br>它以起始标记及终结标记标示文字 Creation of webpage ，令它显示成粗体，两者失其一都会发生错误显示。</p><p>空标记<br>是指标记单独出现，只有起始标记没有终结标记。<br>例如 HTML Source：<br>I love Creation of Webpage.<br>It’s a wonderful place.<br>显示成：<br>I love Creation of Webpage.<br>It’s a wonderful place.</p><p>其中换行标记<br>便属空标记。<br>它的作用便是将标记后所有东西显示于下一行，可见终结标记于它是没意义的， 但有些人会为空标记加上终结标记，这是为方便记认而己，对 HTML 没有影响。</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/2016/10/05/%E5%85%B3%E4%BA%8E/"/>
      <url>/2016/10/05/%E5%85%B3%E4%BA%8E/</url>
      
        <content type="html"><![CDATA[<p>我的学习经历和心路历程！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
